<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>MySQL 原理 | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="MySQL 原理 - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/notes/2024-11-4-mysql_principles/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/notes/2024-11-4-mysql_principles/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      MySQL 原理
    </h1>
    <div class="post-meta"><span title='2024-11-04 00:00:00 +0000 UTC'>November 4, 2024</span>

</div>
  </header> 
  <div class="post-content"><h2 id="一存储引擎">一、存储引擎<a hidden class="anchor" aria-hidden="true" href="#一存储引擎">#</a></h2>
<h3 id="1mysql体系结构">1.MySQL体系结构<a hidden class="anchor" aria-hidden="true" href="#1mysql体系结构">#</a></h3>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/11/BzcbPkRofES7x5q.png"></p>
<ul>
<li>连接层：一些客户端和连接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>服务层：第二层架构主要完成大多数的核心服务功能，如 SQL 接口，并完成缓存的查询、SQL的分析和优化、部分内置函数的执行。所有跨存储引擎的功能也在这一层实现。</li>
<li>引擎层：存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 和存储引擎进行通信。不同的存储引擎具有不同的功能。</li>
<li>存储层：将数据存储在文件系统之上，完成与存储引擎的交互。</li>
</ul>
<h3 id="2存储引擎">2.存储引擎<a hidden class="anchor" aria-hidden="true" href="#2存储引擎">#</a></h3>
<ul>
<li>存储引擎简介：存储引擎就是存储数据、建立索引、更新/查询数据等技术的<strong>实现方式</strong>。存储引擎是基于表的，<strong>不同的表可以用不同的存储引擎</strong>，因此存储引擎也被称为<strong>表类型</strong>。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/11/CTX2eud8OYJW5kP.png"></p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/11/PYZ63as8gji9QAR.png"></p>
<p>图中可以看出 <strong>MySQL 的默认存储引擎是 InnoDB</strong>。</p>
<ul>
<li>
<p><strong>InnoDB</strong></p>
<ul>
<li>介绍：一种兼顾高可靠性和高性能的通用存储引擎，MySQL 5.5 之后，InnoDB 是默认的存储引擎。</li>
<li>特点
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li><strong>行级锁</strong>，提高并发访问性能</li>
<li>支持<strong>外键</strong>约束，保证数据的完整和可靠性</li>
</ul>
</li>
<li>文件：<em>xxx.ibd</em> ：<em>xxx</em> 代表的是表名，InnoDB 引擎的每张表都对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引</li>
<li>以下是 InnoDB 的逻辑存储结构</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/11/SdZrBR51cXMNJ83.png"></p>
</li>
<li>
<p><strong>存储引擎的选择</strong></p>
</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/11/MQyCxX9EPGhHVtu.png"></p>
<h2 id="二索引">二、索引<a hidden class="anchor" aria-hidden="true" href="#二索引">#</a></h2>
<h3 id="1索引概述">1.索引概述<a hidden class="anchor" aria-hidden="true" href="#1索引概述">#</a></h3>
<ul>
<li>
<p>概念：索引（index）是帮助 <em>MySQL</em> <strong>高效获取数据</strong>的<strong>数据结构</strong>（有序）。这些数据结构满足特定查找算法，并且以某种方式指向数据，这样就可以在这些数据结构上实现高级查找算法。</p>
</li>
<li>
<p>优缺点：</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>优势</th>
          <th>劣势</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>提高数据检索效率，降低数据库 IO 成本</td>
          <td>索引列也要占据空间</td>
      </tr>
      <tr>
          <td>通过索引列对数据进行排序，降低数据排序成本，降低 CPU 的消耗</td>
          <td>索引大大提高了查询效率，但降低了表的更新速度（更新表时需要操作对应的索引）</td>
      </tr>
  </tbody>
</table>
<h3 id="2索引结构">2.索引结构<a hidden class="anchor" aria-hidden="true" href="#2索引结构">#</a></h3>
<ul>
<li>索引结构：MySQL 的索引在存储引擎层实现，不同的存储引擎有不同的结构</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/izNCLWFbGBVUDad.png"></p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/gTdYnLGwFSVuQfK.png"></p>
<p>以 <strong>B-Tree和 B+Tree</strong> 为例</p>
<ol>
<li><em>B-Tree</em> （多路平衡查找树）</li>
</ol>
<p>下面是一棵最大度数为 5 的 <em>B-Tree</em> ，每层的节点都会携带数据</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/WqCQUXkgfl6oYr3.png"></p>
<ol start="2">
<li><em>B+Tree</em></li>
</ol>
<p>下面是一棵最大度数为 4 的 <em>B+Tree</em> ，只有叶子节点会携带数据，其他节点仅仅用作索引。并且在叶子节点层，节点与节点之间会形成一个有序的链表。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/uDCqNXSKy4Ggra6.png"></p>
<ul>
<li><em>MySQL</em> 中的 <em>B+Tree</em></li>
</ul>
<p><em>MySQL</em> 索引数据结构对经典的 <em>B+Tree</em> 进行了优化。在原有的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 <em>B+Tree</em> ，提高区间访问的性能。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/BKE72RHNQ8vCriY.png"></p>
<p>补充：<em>MySQL</em> 具有自适应 <em>hash</em> 功能，<em>hash</em> 索引是存储引擎根据 <em>B+Tree</em> 索引在指定条件下自动构建的。</p>
<p><strong>为什么 <em>InnoDB</em> 引擎选择使用 <em>B+Tree</em> 索引结构？</strong></p>
<ol>
<li>相对于二叉搜索树与红黑树，层级更少，搜索效率高；</li>
<li>对于 <em>B-Tree</em> ，无论是叶子节点还是非叶子节点，都会保存数据，这样<strong>导致一页中存储的键值总数减少</strong>，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li>
<li>相对 <em>Hash</em> 索引，<em>B+Tree</em> 支持范围匹配及排序操作</li>
</ol>
<h3 id="3索引分类">3.索引分类<a hidden class="anchor" aria-hidden="true" href="#3索引分类">#</a></h3>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/H4DCPA5EkN1lQJT.png"></p>
<p>在 <em>InnoDB</em> 存储引擎中，根据索引的存储形式，可以分为以下两种：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/7bUJmVwdjyGNeMZ.png"></p>
<p>聚集索引选取规则：</p>
<ol>
<li>如果存在主键，主键就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一（<em>UNIQUE</em>）索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则 <em>InnoDB</em> 会自动生成一个 <em>rowid</em> 作为隐藏的聚集索引</li>
</ol>
<p>上面的讲解可能比较抽象，下面这张图可以比较清楚的理解<strong>聚集索引和二级索引的区别</strong>：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/fCKgrNwbjXY4mSz.png"></p>
<p>解释如下：</p>
<ol>
<li>上图中的表结构有主键 <em>id</em> ，因此 <em>InnoDB</em> 将 <em>id</em> 作为聚集索引来构建一棵 <em>B+Tree</em> ，<strong>并且聚集索引唯一</strong>。<strong>这棵 <em>B+Tree</em> 的叶子节点存放的是行数据</strong>。</li>
<li>然后我们用 <em>name</em> 字段去构建一棵 <em>B+Tree</em> 作为二级索引辅助查找，<strong>这棵 <em>B+Tree</em> 的叶子节点存放的是对应的主键</strong>。</li>
</ol>
<p>以一条 SQL 查询为例：<code>select * from user where name = 'Arm';</code></p>
<p>查询过程：查询条件给的是 <em>name</em> 字段，因此需要在二级索引中查找到 <em>Arm</em> 这个叶子节点，然后查出该叶子节点存放的主键 <em>id</em> 数据。因为需要返回的是一行数据，所以还需要回到聚集索引的 <em>B+Tree</em> 中，根据二级索引中查到的主键 <em>id</em> 查找一整行的数据。<strong>这个过程被称为回表查询</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/14/4yHa1jueFlKE6S9.png"></p>
<h3 id="4索引语法">4.索引语法<a hidden class="anchor" aria-hidden="true" href="#4索引语法">#</a></h3>
<ul>
<li>创建索引</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> [<span style="color:#66d9ef">UNIQUE</span><span style="color:#f92672">|</span><span style="color:#66d9ef">FULLTEXT</span>] <span style="color:#66d9ef">INDEX</span> index_name <span style="color:#66d9ef">ON</span> <span style="color:#a6e22e">table_name</span> (index_col_name,...);
</span></span></code></pre></div><ul>
<li>查看索引</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> table_name;
</span></span></code></pre></div><ul>
<li>删除索引</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span> index_name <span style="color:#66d9ef">ON</span> table_name;
</span></span></code></pre></div><h3 id="5-sql-性能分析">5. SQL 性能分析<a hidden class="anchor" aria-hidden="true" href="#5-sql-性能分析">#</a></h3>
<ul>
<li>SQL 执行频率</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/OX1AFlUa32fnLmi.png"></p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/pB5oNvZkw7A8WfH.png"></p>
<ul>
<li>慢查询日志</li>
</ul>
<p>首先需要修改 <em>mysql</em> 配置文件 <code>/etc/my.cnf</code> ，在其中添加如下内容：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/dYZDcXmfjy4F9vJ.png"></p>
<p>然后重启 mysql ，再登录 mysql 看慢查询日志是否已经启动</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/PkmdA2jStz4QWwu.png"></p>
<p>启动之后，慢查询日志将记录到 <code>/var/lib/mysql/localhost-slow.log</code> 文件中</p>
<ul>
<li>profile 详情</li>
</ul>
<p><code>show profiles</code> 能够在做 SQL 优化时帮助我们了解时间耗费在哪里。通过 <code>have_profiling</code> 参数，能够看到 <em>mysql</em> 是否支持 <em>profile</em> 操作</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/1gKPtG36cWNbh7a.png"></p>
<p>默认 <em>profiling</em> 是关闭的，可以通过 <em>set</em> 语句在 <em>session/global</em> 级别开启 <em>profiling</em>：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/uaDWFHS7UQAsTtk.png"></p>
<p>开启之后就可以通过如下指令查看之前 SQL 指令的执行耗时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#查看每一条 SQL 的耗时基本情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> profiles;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看指定 query_id 的 SQL 语句各个阶段的耗时情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> profile <span style="color:#66d9ef">for</span> query query_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看指定 query_id 的 SQL 语句 CPU 的使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> profile cpu <span style="color:#66d9ef">for</span> query query_id;
</span></span></code></pre></div><ul>
<li><em>explain</em> 执行计划</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/dnSjNq4guXO5R39.png"></p>
<p><img alt="1.jpg" loading="lazy" src="https://s2.loli.net/2024/10/21/EMb2376jRvqHBxw.jpg"></p>
<p><img alt="aa8739ff2bcb098721ddc3dc5a43502d.png" loading="lazy" src="https://s2.loli.net/2024/10/21/sqMZBkHdcQaKwEx.png"></p>
<h3 id="6索引使用">6.索引使用<a hidden class="anchor" aria-hidden="true" href="#6索引使用">#</a></h3>
<ol>
<li>最左前缀法则：如果索引关联了多列（联合索引），要遵守该法则。最左前缀法则指的是查询从索引的<strong>最左列</strong>开始，并且<strong>不跳过</strong>索引中的列。如果跳跃某一列，<strong>索引将部分失效（后面的字段索引失效）</strong></li>
</ol>
<p>比如下面的第三个 <em>explain</em> ，profession 是最左列，但此处并没有用到最左列，所以<strong>索引全部失效</strong>。</p>
<p><img alt="1.jpg" loading="lazy" src="https://s2.loli.net/2024/10/21/6UaebCTWRi7k9nc.jpg"></p>
<ol start="2">
<li>范围查询：联合索引中，出现范围查询(&gt;,&lt;)，<strong>范围查询右侧的列索引失效</strong>。在业务允许的情况下，如果需要进行范围查询，尽量用<strong>大于等于或小于等于</strong>这种范围查询，这样所有的列索引都不会失效。</li>
<li>索引列运算：不要在索引列上进行运算操作，<strong>索引会失效</strong>。</li>
<li>字符串不加单引号：字符串类型字段使用时，<strong>不加引号索引将失效</strong>。</li>
<li>模糊查询：如果仅仅是<strong>尾部模糊匹配</strong>，索引<strong>不会失效</strong>。如果是<strong>头部模糊匹配</strong>，索引<strong>会失效</strong>。</li>
<li>or 连接的条件：用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
<li>数据分布影响：如果 <em>mysql</em> 评估使用索引比全表扫描更慢，则不使用索引。</li>
</ol>
<p><strong>补充：</strong></p>
<ol>
<li>SQL 提示</li>
</ol>
<p><img alt="1.jpg" loading="lazy" src="https://s2.loli.net/2024/10/21/aVg3HLKE57XtoBO.jpg"></p>
<ol start="2">
<li>覆盖索引</li>
</ol>
<p><strong>覆盖索引</strong>是指当一个索引包含了查询语句中所需要的所有列时，MySQL可以不必加载表中的实际数据行，而是直接从索引中获取查询结果。这意味着查询可以直接使用索引来找到并返回所需的数据，而不需要回到主键索引或者实际的数据行（这个过程叫做回表查询），这可以减少磁盘I/O操作，提高查询效率。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/CTNz9lMPfgiqGYV.png"></p>
<ol start="3">
<li>前缀索引</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/vhalfVSy72O43r8.png"></p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/21/7Uc9KPBsWHnSF4g.png"></p>
<h3 id="7索引设计原则">7.索引设计原则<a hidden class="anchor" aria-hidden="true" href="#7索引设计原则">#</a></h3>
<ol>
<li>针对数据量较大（超过100w），且查询频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>尽量选择<strong>区分度高</strong>的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点建立<strong>前缀索引</strong>。</li>
<li><strong>尽量使用联合索引</strong>，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表查询。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价越大，会影响增删改的效率。</li>
<li>如果索引列不能存 <em>NULL</em> 值，请在创建表时使用 <em>NOT NULL</em> 约束它。当优化器知道每列是否包含 <em>NULL</em> 值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<h2 id="三sql优化">三、SQL优化<a hidden class="anchor" aria-hidden="true" href="#三sql优化">#</a></h2>
<h3 id="1插入数据">1.插入数据<a hidden class="anchor" aria-hidden="true" href="#1插入数据">#</a></h3>
<ul>
<li>
<p><em>insert</em></p>
<ul>
<li>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;tom&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;cat&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;jerry&#39;</span>);
</span></span><span style="display:flex;"><span>.....
</span></span></code></pre></div><ul>
<li>优化方案一：批量插入数据</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">Insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;Cat&#39;</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;Jerry&#39;</span>);
</span></span></code></pre></div><ul>
<li>优化方案二：手动控制事务</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>start transaction;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;Cat&#39;</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;Jerry&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>),(<span style="color:#ae81ff">5</span>,<span style="color:#e6db74">&#39;Cat&#39;</span>),(<span style="color:#ae81ff">6</span>,<span style="color:#e6db74">&#39;Jerry&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_test <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">7</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>),(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#39;Cat&#39;</span>),(<span style="color:#ae81ff">9</span>,<span style="color:#e6db74">&#39;Jerry&#39;</span>);
</span></span><span style="display:flex;"><span>commit;
</span></span></code></pre></div><ul>
<li>优化方案三：主键<strong>顺序</strong>插入，性能要高于<strong>乱序</strong>插入</li>
</ul>
<pre tabindex="0"><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
</code></pre></li>
<li>
<p>大批量插入数据</p>
<ul>
<li>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用 <em>insert</em> 语句插入性能较低，此时可以使用 <em>MySQL</em> 数据库提供的 <em>load</em> 指令进行插入。操作如下：</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/mMzY2pj4QSF6vgI.png"></p>
<ul>
<li>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 客户端连接服务端时，加上参数 -–local-infile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql <span style="color:#960050;background-color:#1e0010">–</span><span style="color:#f92672">-</span>local<span style="color:#f92672">-</span><span style="color:#66d9ef">infile</span> <span style="color:#f92672">-</span>u root <span style="color:#f92672">-</span>p
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> global local_infile <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 执行load指令将准备好的数据，加载到表结构中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">load</span> data local <span style="color:#66d9ef">infile</span> <span style="color:#e6db74">&#39;/root/sql1.log&#39;</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">table</span> tb_user fields
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#66d9ef">lines</span> <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#e6db74">&#39;\n&#39;</span> ;
</span></span></code></pre></div><p>同样的，主键顺序插入性能高于乱序插入，一下面的插入过程为例：</p>
<ol>
<li>创建表结构</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>tb_user<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">INT</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">VARCHAR</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">VARCHAR</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">VARCHAR</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>birthday<span style="color:#f92672">`</span> <span style="color:#66d9ef">DATE</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>sex<span style="color:#f92672">`</span> <span style="color:#66d9ef">CHAR</span>(<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>unique_user_username<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span>)
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>INNODB <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CHARSET</span><span style="color:#f92672">=</span>utf8 ;
</span></span></code></pre></div><ol start="2">
<li>设置参数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 客户端连接服务端时，加上参数 -–local-infile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql <span style="color:#960050;background-color:#1e0010">–</span><span style="color:#f92672">-</span>local<span style="color:#f92672">-</span><span style="color:#66d9ef">infile</span> <span style="color:#f92672">-</span>u root <span style="color:#f92672">-</span>p
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> global local_infile <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><ol start="3">
<li><em>load</em> 加载数据</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">load</span> data local <span style="color:#66d9ef">infile</span> <span style="color:#e6db74">&#39;/root/load_user_100w_sort.sql&#39;</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">table</span> tb_user
</span></span><span style="display:flex;"><span>fields <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#66d9ef">lines</span> <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#e6db74">&#39;\n&#39;</span> ;
</span></span></code></pre></div><p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/MwhOjYHyceW4EDA.png"></p>
</li>
</ul>
<h3 id="2主键优化">2.主键优化<a hidden class="anchor" aria-hidden="true" href="#2主键优化">#</a></h3>
<p>在上面提到过这样的说法：<strong>主键顺序插入的性能是要高于乱序插入的</strong>，这是为什么呢？这部分来说明具体的原因，然后再分析一下主键又该如何设计。</p>
<ol>
<li>
<p>数据组织方式</p>
<ul>
<li>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。<img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/vH3plaWItXTYCeS.png"></li>
</ul>
<p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/XOEU8jgVaHdZWfF.png"></p>
<p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，<strong>将会存储到下一个页中</strong>，页与页之间会通过指针连接。</p>
</li>
<li>
<p>页分裂</p>
<ul>
<li>
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
</li>
<li>
<p>主键顺序插入结果如下：</p>
<ol>
<li>从磁盘中申请页， 主键顺序插入</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/ORQdcPTYyvaBqpC.png"></p>
<ol start="2">
<li>第一个页没有满，继续往第一页插入</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/6qgvFiMUk58AuHm.png"></p>
<ol start="3">
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/k1L9SgZXs3Bo7AQ.png"></p>
<ol start="4">
<li>当第二页写满了，再往第三页写入</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/LXkifd726Whmeyz.png"></p>
</li>
<li>
<p>主键乱序插入效果</p>
<ol>
<li>假如1#,2#页<strong>都已经写满了</strong>，存放了如图所示的数据</li>
</ol>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/BMcxXqWNYC7olsp.png"></p>
<ol start="2">
<li>
<p>此时再插入id为50的记录，我们来看看会发生什么现象</p>
<p>会再次开启一个页，写入新的页中吗？</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/7dfl9EeS1YmPsMQ.png"></p>
<p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/D5LoGpHWx3Pewml.png"></p>
<p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/exSMLFJXz5Rwnd8.png"></p>
<p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/GElhFmfygQx4WMK.png"></p>
<p>移动数据并插入id为50的数据之后，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/YSUTyruRVHplQJ2.png"></p>
<p>上述的这种现象，称之为 &ldquo;页分裂&rdquo;，是比较耗费性能的操作。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>页合并</p>
<ul>
<li>目前表中已有数据的索引结构(叶子节点)如下：</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/eqKjEMHRp1s8WNO.png"></p>
<ul>
<li>当我们对已有数据进行删除时，具体的效果：当删除一行记录时，实际上<strong>记录并没有被物理删除</strong>，只是记录被标记（flaged）为删除并且它的空间变得<strong>允许被其他记录声明使用</strong>。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/ny79zwBHI4MAULJ.png"></p>
<ul>
<li>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/WKi8acprbLnhZRY.png"></p>
<ul>
<li>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/lQagt6GimqjLZrM.png"></p>
<p>这个里面所发生的合并页的这个现象，就称之为 &ldquo;页合并&rdquo;。</p>
<p><strong>注：MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</strong></p>
</li>
<li>
<p>索引设计原则</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
</li>
</ol>
<h3 id="3order-by-优化">3.order by 优化<a hidden class="anchor" aria-hidden="true" href="#3order-by-优化">#</a></h3>
<p>MySQL的排序，有两种方式：</p>
<ol>
<li><strong>Using filesort</strong> : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，<strong>所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</strong>。</li>
<li><strong>Using index</strong> : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li>
</ol>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，<strong>我们在优化排序操作时，尽量要优化为 Using index</strong>。</p>
<p><strong>order by优化原则:</strong></p>
<ol>
<li>根据排序字段建立合适的索引，多字段排序时，也要遵循<strong>最左前缀法则</strong>。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以<strong>适当增大排序缓冲区大小sort_buffer_size(默认256k)</strong>。</li>
</ol>
<h3 id="4group-by-优化">4.group by 优化<a hidden class="anchor" aria-hidden="true" href="#4group-by-优化">#</a></h3>
<p>在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p>
<ol>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
<h3 id="5limit-优化">5.limit 优化<a hidden class="anchor" aria-hidden="true" href="#5limit-优化">#</a></h3>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/UAaWofOV5DkqBip.png"></p>
<p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p>
<p>因为，当在进行分页查询时，如果执行 <code>limit 2000000,10</code> ，此时需要MySQL排序前 2000010 条记录，<strong>仅仅返回 2000000 - 2000010 的记录</strong>，其他记录丢弃，查询排序的代价非常大 。</p>
<p>优化思路: 一般分页查询时，通过创建 <strong>覆盖索引</strong> 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tb_sku t , (<span style="color:#66d9ef">select</span> id <span style="color:#66d9ef">from</span> tb_sku <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> id <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">2000000</span>,<span style="color:#ae81ff">10</span>) a <span style="color:#66d9ef">where</span> t.id <span style="color:#f92672">=</span> a.id;
</span></span></code></pre></div><h3 id="6count-优化">6.count 优化<a hidden class="anchor" aria-hidden="true" href="#6count-优化">#</a></h3>
<ol>
<li>
<p>概述</p>
<ul>
<li>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> tb_user ;
</span></span></code></pre></div><ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会<strong>直接返回这个数</strong>，效率很高； 但是如果是带条件的count，MyISAM也慢。</li>
<li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
<li>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：<strong>自己计数</strong>(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</li>
</ul>
</li>
<li>
<p>count 用法</p>
<ul>
<li>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。</li>
<li>用法：count（*）、count（主键）、count（字段）、count（数字）</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/24/78sCbvuhl9QBS2W.png"></p>
<ul>
<li>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em><strong><strong>)，所以尽量使用 count(</strong></strong></em>)。</li>
</ul>
</li>
</ol>
<h3 id="7update-优化">7.update 优化<a hidden class="anchor" aria-hidden="true" href="#7update-优化">#</a></h3>
<p>我们主要需要注意一下update语句执行时的注意事项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">update</span> course <span style="color:#66d9ef">set</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;javaEE&#39;</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> ;
</span></span></code></pre></div><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p>
<p>但是当我们在执行如下SQL时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">update</span> course <span style="color:#66d9ef">set</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;SpringBoot&#39;</span> <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;PHP&#39;</span> ;
</span></span></code></pre></div><p>当我们开启多个事务，在执行上述的SQL时，我们发现<strong>行锁升级为了表锁</strong>。 导致该update语句的性能大大降低。</p>
<p><strong>因此，我们需要注意：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</strong></p>
<h2 id="四视图存储过程触发器">四、视图/存储过程/触发器<a hidden class="anchor" aria-hidden="true" href="#四视图存储过程触发器">#</a></h2>
<h3 id="1视图">1.视图<a hidden class="anchor" aria-hidden="true" href="#1视图">#</a></h3>
<ol>
<li>介绍：视图（View）是一种<strong>虚拟存在的表</strong>。视图中的数据并不在数据库中实际存在，行和列数据来自于定义视图的查询中使用的表，并且是在使用视图时动态生成的。</li>
</ol>
<ul>
<li>
<p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
</li>
<li>
<p>视图的主要用途包括：</p>
<ul>
<li><strong>简化复杂的查询</strong>：通过创建视图，可以将复杂的SQL查询语句封装起来，使得后续使用更加简单。</li>
<li><strong>数据抽象和安全</strong>：视图可以用来隐藏底层表的实际结构，仅暴露给用户需要的部分数据，从而实现<strong>数据抽象</strong>。同时，通过限制对某些列或行的访问，可以增强数据库的安全性。</li>
<li><strong>数据整合</strong>：当数据分布在多个表中时，可以通过创建视图来整合这些数据，提供一个统一的访问接口。</li>
</ul>
</li>
</ul>
<p>举个例子：假设有一个员工表 <code>employees</code> 和一个部门表 <code>departments</code>，可以创建一个视图来显示每个部门的员工姓名和部门名称，而不是每次都写复杂的JOIN查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> VIEW department_employees <span style="color:#66d9ef">AS</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> e.name, d.department_name
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> employees e
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">JOIN</span> departments d <span style="color:#66d9ef">ON</span> e.department_id <span style="color:#f92672">=</span> d.department_id;
</span></span></code></pre></div><p>之后，可以像查询普通表一样查询这个视图：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> department_employees;
</span></span></code></pre></div><p>这将返回所有员工的名字以及他们所在的部门名称。</p>
<ul>
<li>注意事项
<ul>
<li>视图本身并不存储数据，它只是一个查询的外壳。因此，更新视图实际上是在更新底层的表。</li>
<li>并不是所有的视图都支持更新操作，这取决于视图的定义和所使用的数据库系统。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>语法</p>
<ul>
<li>创建：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> [<span style="color:#66d9ef">OR</span> <span style="color:#66d9ef">REPLACE</span>] VIEW <span style="color:#960050;background-color:#1e0010">视图名称</span>[(<span style="color:#960050;background-color:#1e0010">列名列表</span>)] <span style="color:#66d9ef">AS</span> SELECT语句 [ <span style="color:#66d9ef">WITH</span> [ CASCADED <span style="color:#f92672">|</span> LOCAL ] <span style="color:#66d9ef">CHECK</span> <span style="color:#66d9ef">OPTION</span> ]
</span></span></code></pre></div><ul>
<li>查询：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">查看创建视图语句：</span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">CREATE</span> VIEW <span style="color:#960050;background-color:#1e0010">视图名称</span>;
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">查看视图数据：</span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#960050;background-color:#1e0010">视图名称</span> ...... ;
</span></span></code></pre></div><ul>
<li>修改：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">方式一：</span><span style="color:#66d9ef">CREATE</span> [<span style="color:#66d9ef">OR</span> <span style="color:#66d9ef">REPLACE</span>] VIEW <span style="color:#960050;background-color:#1e0010">视图名称</span>[(<span style="color:#960050;background-color:#1e0010">列名列表</span>)] <span style="color:#66d9ef">AS</span> SELECT语句[ <span style="color:#66d9ef">WITH</span> [ CASCADED <span style="color:#f92672">|</span> LOCAL ] <span style="color:#66d9ef">CHECK</span> <span style="color:#66d9ef">OPTION</span> ]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">方式二：</span><span style="color:#66d9ef">ALTER</span> VIEW <span style="color:#960050;background-color:#1e0010">视图名称</span>[(<span style="color:#960050;background-color:#1e0010">列名列表</span>)] <span style="color:#66d9ef">AS</span> SELECT语句 [ <span style="color:#66d9ef">WITH</span> [ CASCADED <span style="color:#f92672">|</span> LOCAL ] <span style="color:#66d9ef">CHECK</span> <span style="color:#66d9ef">OPTION</span> ]
</span></span></code></pre></div><ul>
<li>删除：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> VIEW [<span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span>] <span style="color:#960050;background-color:#1e0010">视图名称</span> [,<span style="color:#960050;background-color:#1e0010">视图名称</span>] ...
</span></span></code></pre></div><ul>
<li>示例如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 创建视图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">or</span> <span style="color:#66d9ef">replace</span> view stu_v_1 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> id,name <span style="color:#66d9ef">from</span> student <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 查询视图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> view stu_v_1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> stu_v_1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> stu_v_1 <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 修改视图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">or</span> <span style="color:#66d9ef">replace</span> view stu_v_1 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> id,name,no <span style="color:#66d9ef">from</span> student <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> view stu_v_1 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> id,name <span style="color:#66d9ef">from</span> student <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 删除视图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">drop</span> view <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">exists</span> stu_v_1;
</span></span></code></pre></div><p>上述我们演示了，视图应该如何创建、查询、修改、删除，那么我们能不能通过视图来插入、更新数据呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">or</span> <span style="color:#66d9ef">replace</span> view stu_v_1 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> id,name <span style="color:#66d9ef">from</span> student <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">10</span> ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> stu_v_1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> stu_v_1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">6</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> stu_v_1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">17</span>,<span style="color:#e6db74">&#39;Tom22&#39;</span>);
</span></span></code></pre></div><p>执行上述的SQL会发现，id为6和17的数据都是可以<strong>成功插入</strong>的。 但是我们执行查询，查询出来的数据，<strong>却没有id为17的记录</strong>。</p>
<p>因为我们在创建视图的时候，指定的条件为 <strong>id&lt;=10</strong>, id为17的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是<strong>已经成功的插入到了基表中</strong>。</p>
<p>如果我们定义视图时，如果指定了条件，然后我们在<strong>插入、修改、删除</strong>数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的<strong>检查</strong>选项了。</p>
</li>
<li>
<p>检查选项</p>
<p>当使用<strong>WITH CHECK OPTION</strong>子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 <strong>MySQL允许基于另一个视图创建视图</strong>，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p>
<ul>
<li>
<p><strong>CASCADED级联</strong></p>
<ul>
<li>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/27/T4OQdIwufjyrgLE.png"></p>
</li>
</ul>
</li>
<li>
<p><strong>LOCAL本地</strong></p>
<ul>
<li>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/27/MpdkxvgQXAtw7lj.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>视图的更新</p>
<ul>
<li>
<p>要使视图可更新，视图中的行与基础表中的行之间<strong>必须存在一对一的关系</strong>。如果视图包含以下任何一项，则该视图不可更新：</p>
<ul>
<li>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION 或者 UNION ALL</li>
</ul>
</li>
<li>
<p>示例演示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> view stu_v_count <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> student;
</span></span></code></pre></div><p>上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错。</p>
</li>
</ul>
</li>
<li>
<p>视图的作用</p>
<ul>
<li>简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li>安全：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</li>
<li>数据独立：视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ul>
</li>
<li>
<p>案例</p>
<ul>
<li>
<p>为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> view tb_user_view <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> id,name,profession,age,gender,status,createtime <span style="color:#66d9ef">from</span> tb_user;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tb_user_view;
</span></span></code></pre></div></li>
<li>
<p>查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操作，定义一个视图。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> view tb_stu_course_view <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> s.name student_name, s.no student_no, c.name course_name <span style="color:#66d9ef">from</span> student s, student_course sc, course c <span style="color:#66d9ef">where</span> s.id <span style="color:#f92672">=</span> sc.studentid <span style="color:#66d9ef">and</span> sc.courseid <span style="color:#f92672">=</span> c.id;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tb_stu_course_view;
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="2存储过程">2.存储过程<a hidden class="anchor" aria-hidden="true" href="#2存储过程">#</a></h3>
<ol>
<li>
<p>介绍：<strong>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合</strong>，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，<strong>就是数据库 SQL 语言层面的代码封装与重用</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/27/Vwv3Z97fXNCKD4F.png"></p>
<p>特点：</p>
<ul>
<li>封装，复用：可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。</li>
<li>可以接收参数，也可以返回数据：在存储过程中，可以传递参数，也可以接收返回值。</li>
<li>减少网络交互，效率提升：如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li>
</ul>
</li>
<li>
<p>基本语法：</p>
<ul>
<li>
<p>创建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#960050;background-color:#1e0010">存储过程名称</span> ([ <span style="color:#960050;background-color:#1e0010">参数列表</span> ])
</span></span><span style="display:flex;"><span>BEGIN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- SQL语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>END ;
</span></span></code></pre></div></li>
<li>
<p>调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> <span style="color:#960050;background-color:#1e0010">名称</span> ([ <span style="color:#960050;background-color:#1e0010">参数</span> ]);
</span></span></code></pre></div></li>
<li>
<p>查看：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> INFORMATION_SCHEMA.ROUTINES <span style="color:#66d9ef">WHERE</span> ROUTINE_SCHEMA <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;xxx&#39;</span>; <span style="color:#75715e">-- 查询指定数据库的存储过程及状态信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#960050;background-color:#1e0010">存储过程名称</span> ; <span style="color:#75715e">-- 查询某个存储过程的定义
</span></span></span></code></pre></div></li>
<li>
<p>删除</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">PROCEDURE</span> [ <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> ] <span style="color:#960050;background-color:#1e0010">存储过程名称</span> <span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></div><p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。因为命令行中SQL语句的结束符默认是分号 <code>;</code> ，如果在IDE中执行则不需要指定。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/27/PBx4riEMjnXsmQJ.png"></p>
</li>
<li>
<p>演示示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 存储过程基本语法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- 创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p1</span>()
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> student;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p1</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 查看
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> information_schema.ROUTINES <span style="color:#66d9ef">where</span> ROUTINE_SCHEMA <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;itcast&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> p1;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">procedure</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">exists</span> p1;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>变量</p>
<p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p>
<ol>
<li>
<p><strong>系统变量</strong>：系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p>
<ul>
<li>
<p>查看系统变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> [ SESSION <span style="color:#f92672">|</span> GLOBAL ] VARIABLES ; <span style="color:#75715e">-- 查看所有系统变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SHOW</span> [ SESSION <span style="color:#f92672">|</span> GLOBAL ] VARIABLES <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;......&#39;</span>; <span style="color:#75715e">-- 可以通过LIKE模糊匹配方式查找变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">@@</span>[SESSION <span style="color:#f92672">|</span> GLOBAL] <span style="color:#960050;background-color:#1e0010">系统变量名</span>; <span style="color:#75715e">-- 查看指定变量的值
</span></span></span></code></pre></div></li>
<li>
<p>设置系统变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> [ SESSION <span style="color:#f92672">|</span> GLOBAL ] <span style="color:#960050;background-color:#1e0010">系统变量名</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">值</span> ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#f92672">@@</span>[SESSION <span style="color:#f92672">|</span> GLOBAL]<span style="color:#960050;background-color:#1e0010">系统变量名</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">值</span> ;
</span></span></code></pre></div><p>注意：如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。mysql服务重新启动之后，<strong>所设置的全局参数会失效</strong>，要想不失效，可以在 /etc/my.cnf 中配置。</p>
<ul>
<li>全局变量(GLOBAL): 全局变量针对于所有的会话。</li>
<li>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</li>
</ul>
</li>
<li>
<p>演示示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 查看系统变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> session variables ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">show</span> session variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;auto%&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">show</span> global variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;auto%&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@@</span>global.autocommit;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@@</span>session.autocommit;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 设置系统变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> session autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">course</span>(id, name) <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#39;ES&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> global autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@@</span>global.autocommit;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>用户定义变量</strong>：用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 &ldquo;@变量名&rdquo; 使用就可以。其作用域为当前连接。</p>
<ul>
<li>
<p>赋值（赋值时，可以使用 = ，也可以使用 := ）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#方式一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SET</span> <span style="color:#f92672">@</span>var_name <span style="color:#f92672">=</span> expr [, <span style="color:#f92672">@</span>var_name <span style="color:#f92672">=</span> expr] ... ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#f92672">@</span>var_name :<span style="color:#f92672">=</span> expr [, <span style="color:#f92672">@</span>var_name :<span style="color:#f92672">=</span> expr] ... ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#方式二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">@</span>var_name :<span style="color:#f92672">=</span> expr [, <span style="color:#f92672">@</span>var_name :<span style="color:#f92672">=</span> expr] ... ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">@</span>var_name <span style="color:#66d9ef">FROM</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
</span></span></code></pre></div></li>
<li>
<p>使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">@</span>var_name ;
</span></span></code></pre></div><p>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
</li>
<li>
<p>演示示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>myname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;itcast&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>myage :<span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>mygender :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#f92672">@</span>myhobby :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;java&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@</span>mycolor :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;red&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">into</span> <span style="color:#f92672">@</span>mycount <span style="color:#66d9ef">from</span> tb_user;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@</span>myname,<span style="color:#f92672">@</span>myage,<span style="color:#f92672">@</span>mygender,<span style="color:#f92672">@</span>myhobby;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@</span>mycolor , <span style="color:#f92672">@</span>mycount;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@</span>abc;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>局部变量</strong>：局部变量是根据需要定义的在局部生效的变量，访问之前，需要<strong>DECLARE</strong>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN &hellip; END块。</p>
<ul>
<li>
<p>声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DECLARE</span> <span style="color:#960050;background-color:#1e0010">变量名</span> <span style="color:#960050;background-color:#1e0010">变量类型</span> [<span style="color:#66d9ef">DEFAULT</span> ... ] ;
</span></span></code></pre></div><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。DEFAULT是指定局部变量的默认值。</p>
</li>
<li>
<p>赋值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#960050;background-color:#1e0010">变量名</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">值</span> ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#960050;background-color:#1e0010">变量名</span> :<span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">值</span> ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#66d9ef">INTO</span> <span style="color:#960050;background-color:#1e0010">变量名</span> <span style="color:#66d9ef">FROM</span> <span style="color:#960050;background-color:#1e0010">表名</span> ... ;
</span></span></code></pre></div></li>
<li>
<p>演示示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 声明局部变量 - declare
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- 赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p2</span>()
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">declare</span> stu_count <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将学生表的数据个数赋值给 stu_count 这个局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">into</span> stu_count <span style="color:#66d9ef">from</span> student;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> stu_count;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p2</span>();
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
</li>
<li>
<p>if</p>
<ul>
<li>
<p>介绍：if 用于做条件判断，具体的语法结构为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">IF</span> <span style="color:#960050;background-color:#1e0010">条件</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">THEN</span>
</span></span><span style="display:flex;"><span>.....
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ELSEIF</span> <span style="color:#960050;background-color:#1e0010">条件</span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">THEN</span> <span style="color:#75715e">-- 可选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.....
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ELSE</span> <span style="color:#75715e">-- 可选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>.....
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">IF</span>;
</span></span></code></pre></div><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p>
</li>
<li>
<p>案例：根据定义的分数score变量，判定当前分数对应的分数等级</p>
<ul>
<li>score &gt;= 85分，等级为优秀。</li>
<li>score &gt;= 60分 且 score &lt; 85分，等级为及格。</li>
<li>score &lt; 60分，等级为不及格。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p3</span>()
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> score <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">58</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> result <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;优秀&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elseif</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">60</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;及格&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;不及格&#39;</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">if</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> result;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p3</span>();
</span></span></code></pre></div><p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且对于最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。</p>
<p>那么我们能不能<strong>把score分数动态的传递进来</strong>，计算出来的分数等级是否可以作为返回值返回呢？答案是肯定的，我们可以通过接下来所讲解的 <strong>参数</strong> 来解决上述的问题。</p>
</li>
</ul>
</li>
<li>
<p>参数</p>
<ul>
<li>参数的类型主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</li>
</ul>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>含义</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>IN</td>
          <td>该类参数作为输入，也就是需要调用时传入值</td>
          <td>默认</td>
      </tr>
      <tr>
          <td>OUT</td>
          <td>该类参数作为输出，也就是该参数可以作为返回值</td>
          <td></td>
      </tr>
      <tr>
          <td>INOUT</td>
          <td>既可以作为输入参数，也可以作为输出参数</td>
          <td></td>
      </tr>
  </tbody>
</table>
<ul>
<li>用法：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#960050;background-color:#1e0010">存储过程名称</span> ([ <span style="color:#66d9ef">IN</span><span style="color:#f92672">/</span><span style="color:#66d9ef">OUT</span><span style="color:#f92672">/</span><span style="color:#66d9ef">INOUT</span> <span style="color:#960050;background-color:#1e0010">参数名</span> <span style="color:#960050;background-color:#1e0010">参数类型</span> ])
</span></span><span style="display:flex;"><span>BEGIN
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- SQL语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>END ;
</span></span></code></pre></div><p>于是上面 <strong>if</strong> 中的案例可以改成下面形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p4</span>(<span style="color:#66d9ef">in</span> score <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">out</span> result <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;优秀&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">elseif</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">60</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;及格&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;不及格&#39;</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">if</span>;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p4</span>(<span style="color:#ae81ff">18</span>, <span style="color:#f92672">@</span>result);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@</span>result;
</span></span></code></pre></div></li>
<li>
<p>case</p>
<ul>
<li>
<p>语法</p>
<ul>
<li>
<p>语法1：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 含义：当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">CASE</span> case_value
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">WHEN</span> when_value1 <span style="color:#66d9ef">THEN</span> statement_list1
</span></span><span style="display:flex;"><span>	[ <span style="color:#66d9ef">WHEN</span> when_value2 <span style="color:#66d9ef">THEN</span> statement_list2] ...
</span></span><span style="display:flex;"><span>	[ <span style="color:#66d9ef">ELSE</span> statement_list ]
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">CASE</span>;
</span></span></code></pre></div></li>
<li>
<p>语法2：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 含义：当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">CASE</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">WHEN</span> search_condition1 <span style="color:#66d9ef">THEN</span> statement_list1
</span></span><span style="display:flex;"><span>	[<span style="color:#66d9ef">WHEN</span> search_condition2 <span style="color:#66d9ef">THEN</span> statement_list2] ...
</span></span><span style="display:flex;"><span>	[<span style="color:#66d9ef">ELSE</span> statement_list]
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">CASE</span>;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>案例：</p>
<ul>
<li>
<p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p>
<ul>
<li>1-3月份，为第一季度</li>
<li>4-6月份，为第二季度</li>
<li>7-9月份，为第三季度</li>
<li>10-12月份，为第四季度</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p6</span>(<span style="color:#66d9ef">in</span> month <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> result <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">when</span> month <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">and</span> month <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;第一季度&#39;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">when</span> month <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">4</span> <span style="color:#66d9ef">and</span> month <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;第二季度&#39;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">when</span> month <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">7</span> <span style="color:#66d9ef">and</span> month <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;第三季度&#39;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">when</span> month <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">and</span> month <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">12</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;第四季度&#39;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> result :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;非法参数&#39;</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">case</span> ;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> <span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#39;您输入的月份为: &#39;</span>,month, <span style="color:#e6db74">&#39;, 所属的季度为: &#39;</span>,result);
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p6</span>(<span style="color:#ae81ff">16</span>);
</span></span></code></pre></div><p><strong>注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>while</p>
<ul>
<li>
<p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">WHILE</span> <span style="color:#960050;background-color:#1e0010">条件</span> DO
</span></span><span style="display:flex;"><span>	SQL逻辑...
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">WHILE</span>;
</span></span></code></pre></div></li>
<li>
<p>案例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- A. 定义局部变量, 记录累加之后的值;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p7</span>(<span style="color:#66d9ef">in</span> n <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> total <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> do
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> total :<span style="color:#f92672">=</span> total <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">while</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> total;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p7</span>(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>repeat</p>
<ul>
<li>
<p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">REPEAT</span>
</span></span><span style="display:flex;"><span>	SQL逻辑...
</span></span><span style="display:flex;"><span>UNTIL <span style="color:#960050;background-color:#1e0010">条件</span>
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">REPEAT</span>;
</span></span></code></pre></div></li>
<li>
<p>案例：计算从1累加到n的值，n为传入的参数值。(使用repeat实现)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- A. 定义局部变量, 记录累加之后的值;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p8</span>(<span style="color:#66d9ef">in</span> n <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> total <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">repeat</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> total :<span style="color:#f92672">=</span> total <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	until n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">repeat</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> total;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p8</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p8</span>(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>loop</p>
<ul>
<li>
<p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</p>
<ul>
<li>LEAVE ：配合循环使用，退出循环。</li>
<li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>[begin_label:] <span style="color:#66d9ef">LOOP</span>
</span></span><span style="display:flex;"><span>	SQL逻辑...
</span></span><span style="display:flex;"><span>END <span style="color:#66d9ef">LOOP</span> [end_label];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LEAVE</span> label; <span style="color:#75715e">-- 退出指定标记的循环体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">ITERATE</span> label; <span style="color:#75715e">-- 直接进入下一次循环
</span></span></span></code></pre></div><p>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</p>
</li>
<li>
<p>案例一：计算从1累加到n的值，n为传入的参数值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- A. 定义局部变量, 记录累加之后的值;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p9</span>(<span style="color:#66d9ef">in</span> n <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> total <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	sum:<span style="color:#66d9ef">loop</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> n<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">leave</span> sum;
</span></span><span style="display:flex;"><span>		end <span style="color:#66d9ef">if</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> total :<span style="color:#f92672">=</span> total <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">loop</span> sum;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> total;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p9</span>(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div></li>
<li>
<p>案例二：计算从1到n之间的偶数累加的值，n为传入的参数值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- A. 定义局部变量, 记录累加之后的值;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p10</span>(<span style="color:#66d9ef">in</span> n <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> total <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	sum:<span style="color:#66d9ef">loop</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> n<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">leave</span> sum;
</span></span><span style="display:flex;"><span>		end <span style="color:#66d9ef">if</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> n<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">iterate</span> sum;
</span></span><span style="display:flex;"><span>		end <span style="color:#66d9ef">if</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> total :<span style="color:#f92672">=</span> total <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">loop</span> sum;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> total;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p10</span>(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>游标</p>
</li>
</ol>
<ul>
<li>
<p>游标（CURSOR）是用来<strong>存储查询结果集</strong>的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<ul>
<li>
<p>声明游标</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DECLARE</span> <span style="color:#960050;background-color:#1e0010">游标名称</span> <span style="color:#66d9ef">CURSOR</span> <span style="color:#66d9ef">FOR</span> <span style="color:#960050;background-color:#1e0010">查询语句</span> ;
</span></span></code></pre></div></li>
<li>
<p>打开游标</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>OPEN <span style="color:#960050;background-color:#1e0010">游标名称</span> ;
</span></span></code></pre></div></li>
<li>
<p>获取游标记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">FETCH</span> <span style="color:#960050;background-color:#1e0010">游标名称</span> <span style="color:#66d9ef">INTO</span> <span style="color:#960050;background-color:#1e0010">变量</span> [, <span style="color:#960050;background-color:#1e0010">变量</span> ] ;
</span></span></code></pre></div></li>
<li>
<p>关闭游标</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>CLOSE <span style="color:#960050;background-color:#1e0010">游标名称</span> ;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>案例：根据传入的参数uage，来查询用户表<strong>tb_user</strong>中，所有的用户年龄小于等于<strong>uage</strong>的用户姓名**（name）<strong>和专业</strong>（profession）<strong>，并将用户的姓名和专业插入到所创建的一张新表</strong>(id,name,profession)**中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 逻辑:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- A. 声明游标, 存储查询结果集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 准备: 创建表结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- C. 开启游标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- D. 获取游标中的记录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- E. 插入数据到新表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- F. 关闭游标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p11</span>(<span style="color:#66d9ef">in</span> uage <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> uname <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> upro <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 注意游标的声明要在普通变量声明之后，否则会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">declare</span> u_cursor <span style="color:#66d9ef">cursor</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">select</span> name,profession <span style="color:#66d9ef">from</span> tb_user <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&lt;=</span> uage;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">exists</span> tb_user_pro;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">exists</span> <span style="color:#a6e22e">tb_user_pro</span>(
</span></span><span style="display:flex;"><span>		id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
</span></span><span style="display:flex;"><span>		name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>		profession <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	);	
</span></span><span style="display:flex;"><span>	open u_cursor;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">true</span> do
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">fetch</span> u_cursor <span style="color:#66d9ef">into</span> uname,upro;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_user_pro <span style="color:#66d9ef">values</span> (<span style="color:#66d9ef">null</span>, uname, upro);
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">while</span>;
</span></span><span style="display:flex;"><span>	close u_cursor;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p11</span>(<span style="color:#ae81ff">30</span>);
</span></span></code></pre></div><p>上述的存储过程，最终我们在调用的过程中会报错，之所以报错是因为在上面的while循环中并没有退出条件。当游标的数据集获取完毕之后，再次获取数据就会报错（游标中已经没有数据可供获取），从而终止了程序的执行。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/28/PyaFSIQpnL4bcgA.png"></p>
<p>但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/10/28/bzPZQFGjdmk8WiU.png"></p>
<p>上述的功能虽然我们实现了，但是逻辑并不完善，而且程序执行完毕获取不到数据，数据库还报错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。</p>
<p>要想解决这个问题，就需要通过MySQL中提供的 <strong>条件处理程序 Handler</strong> 来解决。</p>
</li>
</ul>
<ol start="11">
<li>
<p>条件处理程序</p>
<ul>
<li>
<p><strong>条件处理程序（Handler）<strong>可以用来定义在流程控制结构执行过程中</strong>遇到问题时相应的处理步骤</strong>。具体语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DECLARE</span> handler_action HANDLER <span style="color:#66d9ef">FOR</span> condition_value [, condition_value] ... statement ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>handler_action <span style="color:#960050;background-color:#1e0010">的取值：</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">CONTINUE</span>: <span style="color:#960050;background-color:#1e0010">继续执行当前程序</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">EXIT</span>: <span style="color:#960050;background-color:#1e0010">终止执行当前程序</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>condition_value <span style="color:#960050;background-color:#1e0010">的取值：</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SQLSTATE</span> sqlstate_value: <span style="color:#960050;background-color:#1e0010">状态码，如</span> <span style="color:#ae81ff">02000</span><span style="color:#960050;background-color:#1e0010">（表示没有数据了）</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SQLWARNING</span>: <span style="color:#960050;background-color:#1e0010">所有以</span><span style="color:#ae81ff">01</span><span style="color:#960050;background-color:#1e0010">开头的</span>SQLSTATE代码的简写
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">NOT</span> FOUND: <span style="color:#960050;background-color:#1e0010">所有以</span><span style="color:#ae81ff">02</span><span style="color:#960050;background-color:#1e0010">开头的</span>SQLSTATE代码的简写
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SQLEXCEPTION</span>: <span style="color:#960050;background-color:#1e0010">所有没有被</span>SQLWARNING <span style="color:#960050;background-color:#1e0010">或</span> <span style="color:#66d9ef">NOT</span> FOUND捕获的SQLSTATE代码的简写
</span></span></code></pre></div></li>
<li>
<p>案例：我们继续来完成在上一小节提出的这个需求，并解决其中的问题。根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p>
<ul>
<li>
<p>通过SQLSTATE指定具体的状态码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 逻辑:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- A. 声明游标, 存储查询结果集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- B. 准备: 创建表结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- C. 开启游标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- D. 获取游标中的记录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- E. 插入数据到新表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-- F. 关闭游标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p11</span>(<span style="color:#66d9ef">in</span> uage <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> uname <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> upro <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> u_cursor <span style="color:#66d9ef">cursor</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">select</span> name,profession <span style="color:#66d9ef">from</span> tb_user <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&lt;=</span> uage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">exit</span> handler <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">SQLSTATE</span> <span style="color:#e6db74">&#39;02000&#39;</span> close u_cursor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">exists</span> tb_user_pro;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">exists</span> <span style="color:#a6e22e">tb_user_pro</span>(
</span></span><span style="display:flex;"><span>		id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
</span></span><span style="display:flex;"><span>		name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>		profession <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	open u_cursor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">true</span> do
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">fetch</span> u_cursor <span style="color:#66d9ef">into</span> uname,upro;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_user_pro <span style="color:#66d9ef">values</span> (<span style="color:#66d9ef">null</span>, uname, upro);
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">while</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	close u_cursor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p11</span>(<span style="color:#ae81ff">30</span>);
</span></span></code></pre></div></li>
<li>
<p>通过SQLSTATE的代码简写方式 NOT FOUND。02 开头的状态码，代码简写为 NOT FOUND</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">procedure</span> <span style="color:#a6e22e">p12</span>(<span style="color:#66d9ef">in</span> uage <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> uname <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> upro <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> u_cursor <span style="color:#66d9ef">cursor</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">select</span> name,profession <span style="color:#66d9ef">from</span> tb_user <span style="color:#66d9ef">where</span> age <span style="color:#f92672">&lt;=</span> uage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">declare</span> <span style="color:#66d9ef">exit</span> handler <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">not</span> found close u_cursor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">exists</span> tb_user_pro;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">exists</span> <span style="color:#a6e22e">tb_user_pro</span>(
</span></span><span style="display:flex;"><span>		id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
</span></span><span style="display:flex;"><span>		name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>		profession <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	open u_cursor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">true</span> do
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">fetch</span> u_cursor <span style="color:#66d9ef">into</span> uname,upro;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> tb_user_pro <span style="color:#66d9ef">values</span> (<span style="color:#66d9ef">null</span>, uname, upro);
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">while</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	close u_cursor;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">call</span> <span style="color:#a6e22e">p12</span>(<span style="color:#ae81ff">30</span>);
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3存储函数">3.存储函数<a hidden class="anchor" aria-hidden="true" href="#3存储函数">#</a></h3>
<ul>
<li>
<p>存储函数是<strong>有返回值的存储过程</strong>，存储函数的参数只能是IN类型的。具体语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> FUNCTION <span style="color:#960050;background-color:#1e0010">存储函数名称</span> ([ <span style="color:#960050;background-color:#1e0010">参数列表</span> ])
</span></span><span style="display:flex;"><span>RETURNS type [characteristic ...]
</span></span><span style="display:flex;"><span>BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">-- SQL语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">RETURN</span> ...;
</span></span><span style="display:flex;"><span>END ;
</span></span></code></pre></div></li>
<li>
<p>characteristic说明：</p>
<ul>
<li>
<p>DETERMINISTIC：相同的输入参数总是产生相同的结果</p>
</li>
<li>
<p>NO SQL ：不包含 SQL 语句</p>
</li>
<li>
<p>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</p>
</li>
</ul>
</li>
<li>
<p>案例：计算从1累加到n的值，n为传入的参数值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> function <span style="color:#a6e22e">fun1</span>(n <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>returns <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">deterministic</span>
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">declare</span> total <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> do
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> total :<span style="color:#f92672">=</span> total <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">set</span> n :<span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	end <span style="color:#66d9ef">while</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> total;
</span></span><span style="display:flex;"><span>end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">fun1</span>(<span style="color:#ae81ff">50</span>);
</span></span></code></pre></div></li>
</ul>
<h3 id="4触发器">4.触发器<a hidden class="anchor" aria-hidden="true" href="#4触发器">#</a></h3>
<ol>
<li>
<p>介绍：触发器是与表有关的数据库对象，指在 insert/update/delete 之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<table>
  <thead>
      <tr>
          <th>触发器类型</th>
          <th>NEW 和 OLD</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>INSERT 型触发器</td>
          <td>NEW 表示将要或者已经新增的数据</td>
      </tr>
      <tr>
          <td>UPDATE 型触发器</td>
          <td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
      </tr>
      <tr>
          <td>DELETE 型触发器</td>
          <td>OLD 表示将要或者已经删除的数据</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>语法</p>
<ul>
<li>
<p>创建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TRIGGER</span> trigger_name
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">BEFORE</span><span style="color:#f92672">/</span>AFTER <span style="color:#66d9ef">INSERT</span><span style="color:#f92672">/</span><span style="color:#66d9ef">UPDATE</span><span style="color:#f92672">/</span><span style="color:#66d9ef">DELETE</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> tbl_name <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">EACH</span> ROW <span style="color:#75715e">-- 行级触发器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BEGIN
</span></span><span style="display:flex;"><span>	trigger_stmt ;
</span></span><span style="display:flex;"><span>END;
</span></span></code></pre></div></li>
<li>
<p>查看</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> TRIGGERS ;
</span></span></code></pre></div></li>
<li>
<p>删除</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TRIGGER</span> [schema_name.]trigger_name ; <span style="color:#75715e">-- 如果没有指定 schema_name，默认为当前数据库。
</span></span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>案例：通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加,修改 , 删除 ;</p>
<ul>
<li>
<p>表结构准备</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 准备工作 : 日志表 user_logs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">user_logs</span>(
</span></span><span style="display:flex;"><span>	id <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">auto_increment</span>,
</span></span><span style="display:flex;"><span>	operation <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;操作类型, insert/update/delete&#39;</span>,
</span></span><span style="display:flex;"><span>	operate_time <span style="color:#66d9ef">datetime</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;操作时间&#39;</span>,
</span></span><span style="display:flex;"><span>	operate_id <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;操作的ID&#39;</span>,
</span></span><span style="display:flex;"><span>	operate_params <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">500</span>) comment <span style="color:#e6db74">&#39;操作参数&#39;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>(<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>)
</span></span><span style="display:flex;"><span>)<span style="color:#66d9ef">engine</span><span style="color:#f92672">=</span>innodb <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">charset</span><span style="color:#f92672">=</span>utf8;
</span></span></code></pre></div></li>
<li>
<p>插入数据触发器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">trigger</span> tb_user_insert_trigger
</span></span><span style="display:flex;"><span>	after <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">on</span> tb_user <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">each</span> row
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">user_logs</span>(id, operation, operate_time, operate_id, operate_params)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;insert&#39;</span>, <span style="color:#a6e22e">now</span>(), new.id, <span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#39;插入的数据内容为:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	id=&#39;</span>,new.id,<span style="color:#e6db74">&#39;,name=&#39;</span>,new.name, <span style="color:#e6db74">&#39;, phone=&#39;</span>, NEW.phone, <span style="color:#e6db74">&#39;, email=&#39;</span>, NEW.email, <span style="color:#e6db74">&#39;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	profession=&#39;</span>, NEW.profession));
</span></span><span style="display:flex;"><span>end;
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 查看
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> triggers ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 插入数据到tb_user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">tb_user</span>(id, name, phone, email, profession, age, gender, status,createtime) 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">26</span>,<span style="color:#e6db74">&#39;三皇子&#39;</span>,<span style="color:#e6db74">&#39;18809091212&#39;</span>,<span style="color:#e6db74">&#39;erhuangzi@163.com&#39;</span>,<span style="color:#e6db74">&#39;软件工程&#39;</span>,<span style="color:#ae81ff">23</span>,<span style="color:#e6db74">&#39;1&#39;</span>,<span style="color:#e6db74">&#39;1&#39;</span>,<span style="color:#a6e22e">now</span>());
</span></span></code></pre></div></li>
<li>
<p>修改数据触发器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">trigger</span> tb_user_update_trigger
</span></span><span style="display:flex;"><span>	after <span style="color:#66d9ef">update</span> <span style="color:#66d9ef">on</span> tb_user <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">each</span> row
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">user_logs</span>(id, operation, operate_time, operate_id, operate_params)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;update&#39;</span>, <span style="color:#a6e22e">now</span>(), new.id,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#39;更新之前的数据: id=&#39;</span>,old.id,<span style="color:#e6db74">&#39;,name=&#39;</span>,old.name, <span style="color:#e6db74">&#39;, phone=&#39;</span>,old.phone, <span style="color:#e6db74">&#39;, email=&#39;</span>, old.email, <span style="color:#e6db74">&#39;, profession=&#39;</span>, old.profession,
</span></span><span style="display:flex;"><span>               <span style="color:#e6db74">&#39; | 更新之后的数据: id=&#39;</span>,new.id,<span style="color:#e6db74">&#39;,name=&#39;</span>,new.name, <span style="color:#e6db74">&#39;, phone=&#39;</span>,
</span></span><span style="display:flex;"><span>NEW.phone, <span style="color:#e6db74">&#39;, email=&#39;</span>, NEW.email, <span style="color:#e6db74">&#39;, profession=&#39;</span>, NEW.profession));
</span></span><span style="display:flex;"><span>end;
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 查看
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> triggers ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> tb_user <span style="color:#66d9ef">set</span> profession <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;会计&#39;</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">update</span> tb_user <span style="color:#66d9ef">set</span> profession <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;会计&#39;</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>;
</span></span></code></pre></div></li>
<li>
<p>删除数据触发器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">trigger</span> tb_user_delete_trigger
</span></span><span style="display:flex;"><span>after <span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">on</span> tb_user <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">each</span> row
</span></span><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">user_logs</span>(id, operation, operate_time, operate_id, operate_params)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;delete&#39;</span>, <span style="color:#a6e22e">now</span>(), old.id,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#39;删除之前的数据: id=&#39;</span>,old.id,<span style="color:#e6db74">&#39;,name=&#39;</span>,old.name, <span style="color:#e6db74">&#39;, phone=&#39;</span>,old.phone, <span style="color:#e6db74">&#39;, email=&#39;</span>, 					old.email, <span style="color:#e6db74">&#39;, profession=&#39;</span>, old.profession));
</span></span><span style="display:flex;"><span>end;
</span></span></code></pre></div><p>测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">-- 查看
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> triggers ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 删除数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> tb_user <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">26</span>;
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h2 id="五锁">五、锁<a hidden class="anchor" aria-hidden="true" href="#五锁">#</a></h2>
<h3 id="1概述">1.概述<a hidden class="anchor" aria-hidden="true" href="#1概述">#</a></h3>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ul>
<h3 id="2全局锁">2.全局锁<a hidden class="anchor" aria-hidden="true" href="#2全局锁">#</a></h3>
<p><strong>介绍</strong></p>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong>，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做<strong>全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p><strong>为什么全库逻辑备份，就需要加全局锁呢？</strong></p>
<ol>
<li>
<p>我们一起先来分析一下不加全局锁，可能存在的问题。</p>
<p>假设在数据库中存在这样三张表: <strong>tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/qDmScoBC37dKHt1.png"></p>
<ul>
<li>在进行数据备份时，<strong>先备份了tb_stock库存表</strong>。</li>
<li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li>
<li>然后再执行备份 tb_order表的逻辑。</li>
<li>业务中执行插入订单日志操作。</li>
<li>最后，又备份了tb_orderlog表。</li>
</ul>
<p>此时备份出来的数据是存在问题的。因为备份出来的数据中tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,<strong>但是库存数没减</strong>)。那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p>
</li>
<li>
<p>再来分析一下加了全局锁后的情况</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/d7i4XyvU2pIeuOz.png"></p>
<p>对数据库进行进行逻辑备份之前，<strong>先对整个数据库加上全局锁</strong>，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，<strong>也就是处于只读状态</strong>，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p>
</li>
</ol>
<p><strong>语法</strong></p>
<ol>
<li>
<p>加全局锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">flush</span> <span style="color:#66d9ef">tables</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">read</span> <span style="color:#66d9ef">lock</span> ;
</span></span></code></pre></div></li>
<li>
<p>数据备份</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysqldump <span style="color:#f92672">-</span>uroot <span style="color:#960050;background-color:#1e0010">–</span>p1234 itcast <span style="color:#f92672">&gt;</span> itcast.<span style="color:#66d9ef">sql</span>
</span></span></code></pre></div></li>
<li>
<p>释放锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">unlock</span> <span style="color:#66d9ef">tables</span> ;
</span></span></code></pre></div></li>
</ol>
<p><strong>特点</strong></p>
<p>数据库中加全局锁是一个比较重的操作，存在以下问题：</p>
<ul>
<li>如果在主库上备份，那<strong>么在备份期间都不能执行更新</strong>，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），<strong>会导致主从延迟</strong>。</li>
</ul>
<p>在InnoDB引擎中，我们可以在备份时加上参数 &ndash;single-transaction 参数来完成不加锁的一致性数据备份（其实是应用了事务的ACID特性，所有读取操作在一个事务内完成，<strong>不需要加全局锁，保证了数据库的并发性能</strong>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysqldump <span style="color:#f92672">--</span>single<span style="color:#f92672">-</span>transaction <span style="color:#f92672">-</span>uroot <span style="color:#960050;background-color:#1e0010">–</span>p123456 itcast <span style="color:#f92672">&gt;</span> itcast.<span style="color:#66d9ef">sql</span>
</span></span></code></pre></div><h3 id="3表级锁">3.表级锁<a hidden class="anchor" aria-hidden="true" href="#3表级锁">#</a></h3>
<p><strong>介绍</strong></p>
<p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<h4 id="31表锁">3.1表锁<a hidden class="anchor" aria-hidden="true" href="#31表锁">#</a></h4>
<p>对于表锁，分为两类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li>
<p>加锁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">lock</span> <span style="color:#66d9ef">tables</span> <span style="color:#960050;background-color:#1e0010">表名</span>... <span style="color:#66d9ef">read</span><span style="color:#f92672">/</span><span style="color:#66d9ef">write</span>
</span></span></code></pre></div></li>
<li>
<p>释放锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">unlock</span> <span style="color:#66d9ef">tables</span> <span style="color:#f92672">/</span> <span style="color:#960050;background-color:#1e0010">客户端断开连接</span>
</span></span></code></pre></div></li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li>
<p>读锁：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/tQMXosYIwHETriL.png"></p>
<p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p>
<p>测试：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/Eza7WkdhCKtFL58.png"></p>
</li>
<li>
<p>写锁：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/BEzfYAQ9gNlRnyT.png"></p>
<p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的<strong>读和写</strong>。</p>
<p>测试：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/HTqGV3fFiQylJm6.png"></p>
</li>
</ol>
<h4 id="32元数据锁">3.2元数据锁<a hidden class="anchor" aria-hidden="true" href="#32元数据锁">#</a></h4>
<p>meta data lock , 元数据锁，简写MDL。</p>
<p><strong>MDL加锁过程是系统自动控制，无需显式使用</strong>，在访问一张表的时候会自动加上。<strong>MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性</strong>。</p>
<p>这里的<strong>元数据</strong>，可以简单理解为就是一张表的表结构。 <strong>也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的</strong>。</p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<p>常见的SQL操作，所添加的元数据锁：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/FNC69WifkBSHmaZ.png"></p>
<p><strong>演示</strong></p>
<p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ /SHARED_WRITE），之间是兼容的。<img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/8szbNKuQlMoJBHE.png"></p>
<p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/9kSo2DUd8KLN753.png"></p>
<p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> object_type,object_schema,object_name,lock_type,lock_duration 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">from</span> performance_schema.metadata_locks ;
</span></span></code></pre></div><p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/pKCDS5Mt8cL7vVi.png"></p>
<h4 id="33意向锁">3.3意向锁<a hidden class="anchor" aria-hidden="true" href="#33意向锁">#</a></h4>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁</strong>，使用意向锁来减少表锁的检查。</p>
<p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p>
<ol>
<li>
<p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/RjzumZ5cCvwHXsM.png"></p>
</li>
<li>
<p>当客户端二，想对这张表加表锁时，<strong>会检查当前表是否有对应的行锁</strong>，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/nf8iCQVaLUuI7bJ.png"></p>
</li>
</ol>
<p>有了意向锁之后 :</p>
<ol>
<li>
<p>客户端一，在执行DML操作时，会对<strong>涉及的行</strong>加<strong>行锁</strong>，同时也会对<strong>该表</strong>加上<strong>意向锁</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/FpIjucP3GQlgEX1.png"></p>
</li>
<li>
<p>而其他客户端，在对这张表加表锁的时候，<strong>会根据该表上所加的意向锁来判定是否可以成功加表锁</strong>，而不用逐行判断行锁情况了。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/IAivYuo86C9DnfM.png"></p>
</li>
</ol>
<p>意向锁的分类：</p>
<ul>
<li>意向共享锁(IS): 由语句 <code>select ... lock in share mode</code> 添加 。 与表锁共享锁(read)兼容，与表锁排他锁(write)互斥</li>
<li>意向排他锁(IX): 由 <code>insert、update、delete、select...for update</code> 添加 。与表锁共享锁(read)及排他锁(write)都互斥，<strong>意向锁之间不会互斥</strong></li>
</ul>
<p><strong>注意：一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</strong></p>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">from</span> performance_schema.data_locks;
</span></span></code></pre></div><p><strong>演示</strong></p>
<ol>
<li>
<p>意向共享锁与表读锁是兼容的</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/2k43gr7JBtUsT8d.png"></p>
</li>
<li>
<p>意向排他锁与表读锁、写锁都是互斥的</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/C5rTMNLfjWaRXoz.png"></p>
</li>
</ol>
<h3 id="4行级锁">4.行级锁<a hidden class="anchor" aria-hidden="true" href="#4行级锁">#</a></h3>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，<strong>行锁是通过对索引上的索引项加锁来实现的</strong>，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li>
<p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/XAPorcwf4GQU3y5.png"></p>
</li>
<li>
<p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/HGd9pSuI8hRKZcF.png"></p>
</li>
<li>
<p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/RCDPfm7hgAsLeY9.png"></p>
</li>
</ul>
<h4 id="41行锁">4.1行锁<a hidden class="anchor" aria-hidden="true" href="#41行锁">#</a></h4>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。（简单来说，共享锁和共享锁兼容，共享锁和排他锁互斥）</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<p>两种行锁的兼容情况如下:</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/nUMAO3YsWiPLmIj.png"></p>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/3EgmV2P8rCld6b7.png"></p>
<p><strong>演示</strong></p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li><strong>InnoDB的行锁是针对于索引加的锁</strong>，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ul>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">from</span> performance_schema.data_locks;
</span></span></code></pre></div><p><strong>示例演示</strong></p>
<ul>
<li>
<p>数据准备</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">255</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">`</span>age<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span> <span style="color:#f92672">=</span> InnoDB <span style="color:#66d9ef">CHARACTER</span> <span style="color:#66d9ef">SET</span> <span style="color:#f92672">=</span> utf8mb4;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;tom&#39;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;cat&#39;</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#39;rose&#39;</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">11</span>, <span style="color:#e6db74">&#39;jetty&#39;</span>, <span style="color:#ae81ff">11</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">19</span>, <span style="color:#e6db74">&#39;lily&#39;</span>, <span style="color:#ae81ff">19</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">`</span>stu<span style="color:#f92672">`</span> <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">25</span>, <span style="color:#e6db74">&#39;luci&#39;</span>, <span style="color:#ae81ff">25</span>);
</span></span></code></pre></div><ul>
<li>
<p>普通的select语句，执行时，不会加锁。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/twi4r9m2NzoDvBC.png"></p>
</li>
<li>
<p><code>select...lock in share mode</code>，加共享锁，共享锁与共享锁之间兼容。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/VAR6vFUyBQEWPgG.png"></p>
<p>共享锁与排他锁之间互斥。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/nDTJkF7e8KyUlvj.png"></p>
<p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，因为共享锁与排他锁之间互斥。</p>
</li>
<li>
<p>排它锁与排他锁之间互斥</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/WiTHkZV42UaQvIf.png"></p>
<p>当客户端一执行update语句，会为id为1的记录加排他锁； 客户端二如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。 直到客户端一把事务提交了，才会把这一行的行锁释放，此时客户端二解除阻塞。</p>
</li>
<li>
<p><strong>无索引行锁升级为表锁</strong></p>
<p>stu表中数据如下：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/w8bMznWOkvoql7x.png"></p>
<p>我们在两个客户端中执行如下操作:</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/TnN91ZWsg3PRcKb.png"></p>
<p>在客户端一中开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。然后在客户端二中更新id为3的记录却不能直接执行，会处于阻塞状态，为什么呢？</p>
<p>因为此时客户端一根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁(<strong>因为行锁是对索引项加的锁，而name没有索引</strong>)。</p>
<p>接下来，我们再针对name字段建立索引，索引建立之后，再次做一个测试：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/3Ejl8V9RScBHFbi.png"></p>
<p>此时我们可以看到，客户端一开启事务，然后依然是根据name进行更新。而客户端二在更新id为3的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况。</p>
</li>
</ul>
</li>
</ul>
<h4 id="42间隙锁临键锁">4.2间隙锁&amp;临键锁<a hidden class="anchor" aria-hidden="true" href="#42间隙锁临键锁">#</a></h4>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，<strong>给不存在的记录加锁时</strong>, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key-lock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)&ndash;会访问到不满足条件的第一个值为止。</li>
</ul>
<p>注意：间隙锁唯一目的是<strong>防止其他事务插入间隙</strong>。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</p>
<p><strong>示例演示</strong></p>
<ul>
<li>
<p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/ufNzmHPZ2nqCGlw.png"></p>
</li>
<li>
<p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key-lock 退化为间隙锁。</p>
<ul>
<li>介绍分析一下：我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/nNcgUkHMs8SYpim.png"></p>
</li>
<li>
<p>索引上的范围查询(唯一索引)&ndash;会访问到不满足条件的第一个值为止。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/02/rOikAxE7TMBXasP.png"></p>
</li>
</ul>
<h2 id="六innodb引擎">六、InnoDB引擎<a hidden class="anchor" aria-hidden="true" href="#六innodb引擎">#</a></h2>
<h3 id="1逻辑存储结构">1.逻辑存储结构<a hidden class="anchor" aria-hidden="true" href="#1逻辑存储结构">#</a></h3>
<p>InnoDB的逻辑存储结构如下图所示:</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/UJXAuvjzNQqo13L.png"></p>
<ol>
<li>表空间：表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</li>
<li>段：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，<strong>数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点</strong>。段用来管理多个Extent（区）。</li>
<li>区：表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li>
<li>页：页是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li>行：InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段：
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的<strong>事务id</strong>赋值给trx_id隐藏列。</li>
<li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</li>
</ol>
<h3 id="2架构">2.架构<a hidden class="anchor" aria-hidden="true" href="#2架构">#</a></h3>
<p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/MJkPlUWy83hdzrQ.png"></p>
<ol>
<li>
<p>内存结构：在左侧的内存结构中，主要分为四大块： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p>
<ul>
<li>
<p><strong>Buffer Pool</strong>：InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就<strong>需要把经常使用的数据加载到缓冲池中</strong>，避免每次访问都进行磁盘I/O。</p>
<ul>
<li>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</li>
<li>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</li>
<li><strong>缓冲池以Page页为单位</strong>，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：
<ul>
<li>free page：空闲page，未被使用。</li>
<li>clean page：被使用page，数据没有被修改过。</li>
<li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Change Buffer</strong>：Change Buffer，更改缓冲区（针对于非唯一二级索引页），<strong>在执行DML语句时</strong>，如果这些数据Page没有在Buffer Pool中，<strong>不会直接操作磁盘</strong>，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<ul>
<li>
<p>**那么Change Buffer的意义是什么呢?**先来看一幅图，这个是二级索引的结构图：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/cqiG63uHQYDXLJr.png"></p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。<strong>有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>Adaptive Hash Index</strong>：自适应hash索引，<strong>用于优化对Buffer Pool数据的查询</strong>。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行<strong>等值匹配</strong>时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。InnoDB存储引擎会监控对表上各索引页的查询，**如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。**因此，<strong>自适应哈希索引无需人工干预，是系统根据情况自动完成。</strong></p>
</li>
<li>
<p><strong>Log Buffer</strong>：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p>
</li>
</ul>
</li>
<li>
<p>磁盘结构</p>
<ul>
<li>
<p><strong>System Tablespace</strong>：系统表空间是<strong>更改缓冲区的存储区域</strong>。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p>
</li>
<li>
<p><strong>File-Per-Table Tablespaces</strong>：如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。<strong>也就是说我们每创建一个表，都会产生一个表空间文件</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/4du7r96XZoB3zPj.png"></p>
</li>
<li>
<p><strong>General Tablespaces</strong>：通用表空间，需要通过 <code>CREATE TABLESPACE</code> 语法创建通用表空间，在创建表时，可以指定该表空间</p>
<ul>
<li>
<p>创建表空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> TABLESPACE ts_name <span style="color:#66d9ef">ADD</span> DATAFILE <span style="color:#e6db74">&#39;file_name&#39;</span> <span style="color:#66d9ef">ENGINE</span> <span style="color:#f92672">=</span> engine_name;
</span></span></code></pre></div><p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/oVbT5kcBFJjnIhD.png"></p>
</li>
<li>
<p>创建表时指定表空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> xxx ... TABLESPACE ts_name;
</span></span></code></pre></div><p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/DPX6Ub7thYgH2Sk.png"></p>
</li>
</ul>
</li>
<li>
<p><strong>Undo Tablespaces</strong>：撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p>
</li>
<li>
<p><strong>Temporary Tablespaces</strong>：InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
</li>
<li>
<p><strong>Doublewrite Buffer Files</strong>：双写缓冲区，<strong>innoDB引擎将数据页从Buffer Pool刷新到磁盘前</strong>，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p>
</li>
<li>
<p><strong>Redo Log</strong>：重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p>
</li>
</ul>
</li>
<li>
<p>后台线程：InnoDB的后台线程分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/OaWIEQ5xCcny1lU.png"></p>
<ul>
<li>
<p><strong>Master Thread</strong>：核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收</p>
</li>
<li>
<p><strong>IO Thread</strong>：在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而<strong>IOThread主要负责这些IO请求的回调</strong></p>
<table>
  <thead>
      <tr>
          <th>线程类型</th>
          <th>默认个数</th>
          <th>职责</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Read thread</td>
          <td>4</td>
          <td>负责读操作</td>
      </tr>
      <tr>
          <td>Write thread</td>
          <td>4</td>
          <td>负责写操作</td>
      </tr>
      <tr>
          <td>Log thread</td>
          <td>1</td>
          <td>负责将日志缓冲区刷新到磁盘</td>
      </tr>
      <tr>
          <td>Insert buffer thread</td>
          <td>1</td>
          <td>负责将写缓冲区内容刷新到磁盘</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>Purge Thread</strong>：主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p>
</li>
<li>
<p><strong>Page Cleaner Thread</strong>：协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3事务原理">3.事务原理<a hidden class="anchor" aria-hidden="true" href="#3事务原理">#</a></h3>
<ol>
<li>
<p>事务基础</p>
<ul>
<li>
<p>事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
</li>
<li>
<p>特性：<strong>ACID特性</strong></p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性（Consistency）</strong>：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li><strong>持久性（Durability）</strong>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>这四大特性分为两个部分。 <strong>其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的</strong>，一份是redo log日志，一份是undo log日志。 <strong>而隔离性是通过数据库的锁，加上MVCC来保证的</strong>。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/n7T9JLDAgvZyaWe.png"></p>
</li>
</ul>
</li>
<li>
<p><strong>redo log</strong></p>
<ul>
<li>
<p><strong>重做日志</strong>，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。该日志文件由两部分组成：<strong>重做日志缓冲（redo log buffer）<strong>以及</strong>重做日志文件（redo logfile）</strong>,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于<strong>在刷新脏页到磁盘发生错误时, 进行数据恢复使用</strong>。</p>
</li>
<li>
<p>如果没有redolog，可能会存在什么问题？</p>
<ul>
<li>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，<strong>InnoDB引擎会先操作缓冲池中的数据</strong>，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，<strong>修改后的数据页我们称为脏页</strong>。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，<strong>假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性</strong>。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/MpxSWNdFLZm9tzB.png"></p>
<ul>
<li>那么如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/IKtnogkLGUbqsN1.png"></p>
<ul>
<li>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，<strong>记录在redolog buffer中</strong>。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时发生错误，<strong>此时就可以借助于redo log进行数据恢复</strong>，这样就保证了事务的持久性。 而<strong>如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就没有作用了</strong>，就可以删除了，所以存在的两个redolog文件是循环写的。</li>
<li>那为什么每一次提交事务，要刷新 redo log 到磁盘中呢，而不是直接将 buffer pool 中的脏页刷新到磁盘呢 ?
<ul>
<li>因为在业务操作中，<strong>我们操作数据一般都是随机读写磁盘的</strong>，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是<strong>顺序写</strong>的。<strong>顺序写的效率，要远大于随机写</strong>。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>undo log</strong></p>
<ul>
<li><strong>回滚日志</strong>，用于记录数据被修改前的信息 , 作用包含两个 : <strong>提供回滚(保证事务的原子性) 和MVCC(多版本并发控制)</strong> 。</li>
<li>undo log和redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li>
<li><strong>Undo log销毁</strong>：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
<li><strong>Undo log存储</strong>：<strong>undo log采用段的方式进行管理和记录</strong>，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</li>
</ul>
</li>
</ol>
<h3 id="4mvcc">4.MVCC<a hidden class="anchor" aria-hidden="true" href="#4mvcc">#</a></h3>
<ol>
<li>
<p>基本概念</p>
<ul>
<li>
<p>当前读：<strong>读取的是记录的最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select &hellip; lock in share mode(共享锁)，select &hellip;for update、update、insert、delete(排他锁)都是一种当前读。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/QaYKgL8miWptROr.png"></p>
<p>在测试中我们可以看到，即使是在默认的RR隔离级别下，<strong>事务A中依然可以读取到事务B最新提交的内容</strong>，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p>
</li>
<li>
<p>快照读：<strong>简单的select（不加锁）就是快照读</strong>，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<ul>
<li><strong>Read Committed</strong>：每次select，都生成一个快照读。</li>
<li><strong>Repeatable Read</strong>：开启事务后第一个select语句才是快照读的地方。</li>
<li><strong>Serializable</strong>：快照读会退化为当前读。</li>
</ul>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/mLGoAZyK7zYkIfX.png"></p>
<p>在测试中,我们看到<strong>即使事务B提交了数据,事务A中也查询不到</strong>。 原因就是因为普通的select是<strong>快照读</strong>，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，<strong>后面执行相同的select语句都是从快照中获取数据</strong>，可能不是当前的最新数据，这样也就<strong>保证了可重复读</strong></p>
</li>
<li>
<p><strong>MVCC</strong>：全称 <strong>Multi-Version Concurrency Control，多版本并发控制</strong>。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。<strong>MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</strong></p>
</li>
</ul>
</li>
<li>
<p>隐藏字段</p>
<ul>
<li>
<p>介绍</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/5saISVvOZtApuFN.png"></p>
<p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p>
<table>
  <thead>
      <tr>
          <th>隐藏字段</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DB_TRX_ID</td>
          <td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
      </tr>
      <tr>
          <td>DB_ROLL_PTR</td>
          <td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td>
      </tr>
      <tr>
          <td>DB_ROW_ID</td>
          <td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
      </tr>
  </tbody>
</table>
<p><strong>上述的前两个字段是肯定会添加的</strong>， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p>
</li>
</ul>
</li>
<li>
<p><strong>undolog</strong></p>
<ul>
<li>
<p>介绍：回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<ul>
<li><strong>当insert的时候</strong>，产生的undo log日志只在回滚时需要，<strong>在事务提交后，可被立即删除</strong>。</li>
<li><strong>而update、delete的时候</strong>，产生的undo log日志不仅在回滚时需要，在快照读时也需要，<strong>不会立即被删除</strong>。</li>
</ul>
</li>
<li>
<p>版本链：</p>
<ul>
<li>
<p>有一张表原始数据为：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/5XCWfl6I9xTce2U.png"></p>
<ul>
<li>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</li>
<li>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</li>
</ul>
<p><strong>然后，有四个并发事务同时在访问这张表</strong></p>
<ol>
<li>
<p>第一步</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/VLjwyfAOHZ2UWJg.png"></p>
<p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/EAW8iZNcDnSRUKJ.png"></p>
</li>
<li>
<p>第二步</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/TPVetN7CIEzOMfL.png"></p>
<p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/CgwrQmzpDuYn6hy.png"></p>
</li>
<li>
<p>第三步</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/y2591h6tBak4JVp.png"></p>
<p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/zqZkgpVWdJrjlMt.png"></p>
<p>最终我们发现，不同事务或相同事务对同一条记录进行修改，<strong>会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</strong>。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>readview</strong>：ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<ul>
<li>
<p>ReadView中包含了四个核心字段：</p>
<table>
  <thead>
      <tr>
          <th>字段</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>m_ids</td>
          <td>当前活跃的事务ID集合</td>
      </tr>
      <tr>
          <td>min_trx_id</td>
          <td>最小活跃事务ID</td>
      </tr>
      <tr>
          <td>max_trx_id</td>
          <td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>
      </tr>
      <tr>
          <td>creator_trx_id</td>
          <td>ReadView创建者的事务ID</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>而在readview中就规定了版本链数据的访问规则（<strong>trx_id 代表当前undolog版本链对应事务ID</strong>）：</p>
<table>
  <thead>
      <tr>
          <th>条件</th>
          <th>是否可以访问</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>trx_id == creator_trx_id</td>
          <td>可以访问该版本</td>
          <td>成立，说明数据是当前这个事务更改的</td>
      </tr>
      <tr>
          <td>trx_id &lt; min_trx_id</td>
          <td>可以访问该版本</td>
          <td>成立，说明数据已经提交了</td>
      </tr>
      <tr>
          <td>trx_id &gt; max_trx_id</td>
          <td>不可以访问该版本</td>
          <td>成立，说明该事务是在ReadView生成后才开启</td>
      </tr>
      <tr>
          <td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td>
          <td>如果trx_id不在m_ids中，是可以访问该版本的</td>
          <td>成立，说明数据已经提交</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<ul>
<li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>原理分析</p>
<ol>
<li>
<p><strong>RC隔离级别</strong>：RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p>
<ul>
<li>
<p>下面分析事务5中，两次快照读读取数据，是如何获取数据的</p>
<p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/TOKIYz5Ulbnu2sR.png"></p>
<p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p>
</li>
<li>
<p>先来看第一次快照读具体的读取过程：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/uqJRWnysTMlYb1K.png"></p>
</li>
<li>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/VJu7rYH3OWNyPjS.png"></p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/qo7aZ5IGuYWxO4b.png"></p>
</li>
<li>
<p>再来看第二次快照读具体的读取过程:</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/Kd5HjLhFvoxIyR1.png"></p>
</li>
<li>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/qw74LioGB3mI9A2.png"></p>
</li>
</ul>
</li>
<li>
<p><strong>RR隔离级别</strong>：RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，<strong>后续复用该ReadView</strong>。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>
<ul>
<li>
<p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/11/04/ge2bdvGzlf4xELQ.png"></p>
</li>
<li>
<p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>所以，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
