<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>分布式锁 | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="记录">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/notes/2024-11-9-distributed-lock/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/notes/2024-11-9-distributed-lock/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      分布式锁
    </h1>
    <div class="post-description">
      记录
    </div>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h2 id="基本原理和实现方式">基本原理和实现方式<a hidden class="anchor" aria-hidden="true" href="#基本原理和实现方式">#</a></h2>
<ul>
<li>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，<strong>让程序串行执行</strong>。</li>
</ul>
<p><img alt="1.webp" loading="lazy" src="https://s2.loli.net/2024/11/09/gkcmltHMzDTF8oW.webp"></p>
<ul>
<li>那么分布式锁他应该满足的条件呢？
<ul>
<li><strong>可见性</strong>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li>
<li><strong>互斥</strong>：互斥是分布式锁的最基本的条件，使得程序串行执行</li>
<li><strong>高可用</strong>：程序不易崩溃，时时刻刻都保证较高的可用性</li>
<li><strong>高性能</strong>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li>
<li><strong>安全性</strong>：安全也是程序中必不可少的一环</li>
</ul>
</li>
<li>常见的分布式锁有三种：
<ul>
<li><strong>Mysql</strong>：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</li>
<li><strong>Redis</strong>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</li>
<li><strong>Zookeeper</strong>：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，zookeeper中实现分布式锁主要依赖于它的临时节点（ephemeral node）和顺序节点（sequential node）特性。</li>
</ul>
</li>
</ul>
<h2 id="redis-分布式锁的实现核心思路">Redis 分布式锁的实现核心思路<a hidden class="anchor" aria-hidden="true" href="#redis-分布式锁的实现核心思路">#</a></h2>
<p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li>获取锁：
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回 true，失败返回 false</li>
</ul>
</li>
<li>释放锁：
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<p><strong>实现核心思路</strong>：</p>
<p>我们利用 redis 的 <code>setnx</code> 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个 key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可。</p>
<p><img alt="1.webp" loading="lazy" src="https://s2.loli.net/2024/11/09/HC4dWSmnLX9sFER.webp"></p>
<h2 id="实现基于-redis-的分布式锁">实现基于 redis 的分布式锁<a hidden class="anchor" aria-hidden="true" href="#实现基于-redis-的分布式锁">#</a></h2>
<ul>
<li>
<p>分布式锁的基本接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 分布式锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ILock</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 尝试获取锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param timeoutSec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span>(<span style="color:#66d9ef">long</span> timeoutSec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>简单分布式锁的实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SimpleRedisLock</span> <span style="color:#66d9ef">implements</span> ILock {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name; <span style="color:#75715e">// 业务名</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> StringRedisTemplate stringRedisTemplate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SimpleRedisLock</span>(String name, StringRedisTemplate stringRedisTemplate) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">stringRedisTemplate</span> <span style="color:#f92672">=</span> stringRedisTemplate;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String KEY_PREFIX <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;lock:&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String ID_PREFIX <span style="color:#f92672">=</span> UUID.<span style="color:#a6e22e">randomUUID</span>().<span style="color:#a6e22e">toString</span>(<span style="color:#66d9ef">true</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 获取锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param timeoutSec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span>(<span style="color:#66d9ef">long</span> timeoutSec) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取线程标识</span>
</span></span><span style="display:flex;"><span>        String threadId <span style="color:#f92672">=</span> ID_PREFIX <span style="color:#f92672">+</span> Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取锁，redis 中以线程标识作为 value</span>
</span></span><span style="display:flex;"><span>        Boolean success <span style="color:#f92672">=</span> stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">setIfAbsent</span>(KEY_PREFIX <span style="color:#f92672">+</span> name, threadId, timeoutSec, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 封装类的自动拆箱可能造成空指针异常，这里用 equals 方法进行判断</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Boolean.<span style="color:#a6e22e">TRUE</span>.<span style="color:#a6e22e">equals</span>(success);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取当前线程标识和分布式锁里存放的线程标识</span>
</span></span><span style="display:flex;"><span>        String threadId <span style="color:#f92672">=</span> ID_PREFIX <span style="color:#f92672">+</span> Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        String id <span style="color:#f92672">=</span> stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">get</span>(KEY_PREFIX <span style="color:#f92672">+</span> name);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 两个 id 相同才能释放锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (threadId.<span style="color:#a6e22e">equals</span>(id)) {
</span></span><span style="display:flex;"><span>            stringRedisTemplate.<span style="color:#a6e22e">delete</span>(KEY_PREFIX <span style="color:#f92672">+</span> name);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="redis-分布式锁误删情况">redis 分布式锁误删情况：<a hidden class="anchor" aria-hidden="true" href="#redis-分布式锁误删情况">#</a></h3>
<ul>
<li>
<p><strong>具体情况</strong>：持有锁的线程在锁的内部出现了阻塞，<strong>导致他的锁自动释放</strong>，这时其他线程，线程 2 来尝试获得锁，就拿到了这把锁，然后线程 2 在持有锁执行过程中，线程 1 从阻塞状态恢复过来，继续执行，而线程 1 执行过程中，走到了删除锁逻辑，<strong>此时就会把本应该属于线程 2 的锁进行删除，这就是误删其他线程的锁的情况</strong>。</p>
</li>
<li>
<p><strong>解决方案</strong>：解决方案就是在每个线程释放锁的时候，<strong>去判断一下当前这把锁是否属于自己</strong>，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程 1 卡顿，锁自动释放，线程 2 进入到锁的内部执行逻辑，此时线程 1 从阻塞状态恢复过来，然后尝试删除锁，但是线程 1 发现当前这把锁不属于自己，于是不进行删除锁逻辑，当线程 2 走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
</li>
</ul>
<p><img alt="1.webp" loading="lazy" src="https://s2.loli.net/2024/11/09/hx4JoF1P9rUsnqg.webp"></p>
<p>根据上面的分析，我们可以修改之前的代码，在线程获取到锁的同时向 redis 中写入自己的线程标识，在释放锁之前检查当前 redis 中的线程标识是不是自己的，再选择是否删除当前锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SimpleRedisLock</span> <span style="color:#66d9ef">implements</span> ILock {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name; <span style="color:#75715e">// 业务名</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> StringRedisTemplate stringRedisTemplate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SimpleRedisLock</span>(String name, StringRedisTemplate stringRedisTemplate) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">stringRedisTemplate</span> <span style="color:#f92672">=</span> stringRedisTemplate;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String KEY_PREFIX <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;lock:&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String ID_PREFIX <span style="color:#f92672">=</span> UUID.<span style="color:#a6e22e">randomUUID</span>().<span style="color:#a6e22e">toString</span>(<span style="color:#66d9ef">true</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 获取锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param timeoutSec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryLock</span>(<span style="color:#66d9ef">long</span> timeoutSec) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取线程标识</span>
</span></span><span style="display:flex;"><span>        String threadId <span style="color:#f92672">=</span> ID_PREFIX <span style="color:#f92672">+</span> Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取锁，redis 中以线程标识作为 value</span>
</span></span><span style="display:flex;"><span>        Boolean success <span style="color:#f92672">=</span> stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">setIfAbsent</span>(KEY_PREFIX <span style="color:#f92672">+</span> name, threadId, timeoutSec, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 封装类的自动拆箱可能造成空指针异常，这里用 equals 方法进行判断</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Boolean.<span style="color:#a6e22e">TRUE</span>.<span style="color:#a6e22e">equals</span>(success);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取当前线程标识和分布式锁里存放的线程标识</span>
</span></span><span style="display:flex;"><span>        String threadId <span style="color:#f92672">=</span> ID_PREFIX <span style="color:#f92672">+</span> Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>        String id <span style="color:#f92672">=</span> stringRedisTemplate.<span style="color:#a6e22e">opsForValue</span>().<span style="color:#a6e22e">get</span>(KEY_PREFIX <span style="color:#f92672">+</span> name);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 两个 id 相同才能释放锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (threadId.<span style="color:#a6e22e">equals</span>(id)) {
</span></span><span style="display:flex;"><span>            stringRedisTemplate.<span style="color:#a6e22e">delete</span>(KEY_PREFIX <span style="color:#f92672">+</span> name);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="分布式锁的原子性问题">分布式锁的原子性问题<a hidden class="anchor" aria-hidden="true" href="#分布式锁的原子性问题">#</a></h3>
<p>线程 1 现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，<strong>而且已经走到了条件判断的过程中</strong>，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，此时线程 1 发生了阻塞，<strong>并且他的锁此时到期了</strong>，被迫释放。那么此时线程 2 进来，发现可以获取锁，于是线程 2 获取到分布式锁，但是线程 1 他会接着往后执行，当他阻塞结束后，他直接就会执行删除锁那行代码，<strong>相当于条件判断并没有起到作用，这就是删锁时的原子性问题</strong>，之所以有这个问题，是因为线程 1 的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生。</p>
<p><img alt="1.webp" loading="lazy" src="https://s2.loli.net/2024/11/09/B3zRnvGXVYa761Z.webp"></p>
<p>原子性问题可以使用 <strong>lua 脚本</strong>解决，在 java 中我们一般会用 redission 这个第三方库来实现分布式锁，这时候就不需要我们上面手写的分布式锁了。</p>
<h2 id="基于-redisson-的分布式锁实现">基于 redisson 的分布式锁实现<a hidden class="anchor" aria-hidden="true" href="#基于-redisson-的分布式锁实现">#</a></h2>
<h3 id="setnx-实现的分布式锁存在的问题">setnx 实现的分布式锁存在的问题<a hidden class="anchor" aria-hidden="true" href="#setnx-实现的分布式锁存在的问题">#</a></h3>
<p>基于 redis 的 setnx 方法实现的分布式锁存在以下问题：</p>
<ul>
<li><strong>重入问题</strong>：重入问题是指<strong>获得锁的线程可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于防止死锁，比如 HashTable 这样的代码中，他的方法都是使用 synchronized 修饰的，<strong>假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗</strong>？所以可重入锁他的主要意义是防止死锁，我们的 synchronized 和 Lock 锁都是可重入的。</li>
<li><strong>不可重试</strong>：是指目前的分布式锁只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li>
<li>**超时释放：**我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了 lua 表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患。</li>
<li><strong>主从一致性：</strong> 如果 redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</li>
</ul>
<h3 id="使用-redisson-实现分布式锁">使用 redisson 实现分布式锁<a hidden class="anchor" aria-hidden="true" href="#使用-redisson-实现分布式锁">#</a></h3>
<p>Redisson 是一个 Redis 的 Java 客户端，它不仅提供了对 Redis 基本命令的支持，还扩展了许多高级功能，如分布式对象、集合、锁、消息队列等。Redisson 的设计目标是让开发者能够更加方便地在 Java 应用程序中使用 Redis 的强大功能，而无需关心底层的通信细节。</p>
<p><strong>主要特性</strong></p>
<ol>
<li><strong>分布式对象</strong>：Redisson 提供了一系列分布式对象，如 Map、Set、List、Queue 等，这些对象可以在多个 JVM 之间共享，并且支持原子操作。</li>
<li><strong>分布式锁</strong>：包括可重入锁（Reentrant Lock）、公平锁（Fair Lock）、多锁（MultiLock）、红锁（Red Lock）、读写锁（ReadWrite Lock）等。</li>
<li><strong>分布式集合</strong>：提供了多种分布式的集合类型，如 Set、SortedSet、List、Map 等。</li>
<li><strong>分布式消息队列</strong>：支持发布/订阅模式（Pub/Sub）、主题（Topic）、队列（Queue）、延迟队列（Delayed Queue）等。</li>
<li><strong>分布式服务</strong>：提供了分布式远程服务调用（Remote Service）、分布式执行器服务（Executor Service）等。</li>
<li><strong>分布式集合缓存</strong>：支持本地缓存、近似缓存等多种缓存策略。</li>
<li><strong>分布式计数器</strong>：提供了一个高并发的分布式计数器。</li>
<li><strong>分布式ID生成器</strong>：支持 Snowflake 算法的分布式 ID 生成器。</li>
<li><strong>分布式任务调度</strong>：支持定时任务和周期任务的调度。</li>
</ol>
<p>我们先在工程中引入 redisson 的 maven 依赖：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>org.redisson<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>redisson<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;version&gt;</span>3.28.0<span style="color:#f92672">&lt;/version&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后新建一个配置类，用于配置 redisson 客户端，这个配置类里的方法返回的 RedissonClient 对象将被 spring 容器管理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedissonConfig</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Bean</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> RedissonClient <span style="color:#a6e22e">redissonClient</span>() {
</span></span><span style="display:flex;"><span>        Config config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>        config.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setAddress</span>(<span style="color:#e6db74">&#34;redis://localhost:6379&#34;</span>).<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;123456&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Redisson.<span style="color:#a6e22e">create</span>(config);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>于是我们原来的业务方法中就可以使用 RedissonClient 来实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 优惠券秒杀下单
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param voucherId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Result <span style="color:#a6e22e">seckillVoucher</span>(Long voucherId) {
</span></span><span style="display:flex;"><span>    SeckillVoucher voucher <span style="color:#f92672">=</span> seckillVoucherService.<span style="color:#a6e22e">getById</span>(voucherId);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (voucher.<span style="color:#a6e22e">getBeginTime</span>().<span style="color:#a6e22e">isAfter</span>(LocalDateTime.<span style="color:#a6e22e">now</span>()) <span style="color:#f92672">||</span> voucher.<span style="color:#a6e22e">getEndTime</span>().<span style="color:#a6e22e">isBefore</span>(LocalDateTime.<span style="color:#a6e22e">now</span>())) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;不在秒杀的时间范围内！&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (voucher.<span style="color:#a6e22e">getStock</span>() <span style="color:#f92672">&lt;</span> 1) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;库存不足！&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Long userId <span style="color:#f92672">=</span> UserHolder.<span style="color:#a6e22e">getUser</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 悲观锁 synchronized 只能在单机系统里解决线程安全问题，不能解决分布式系统的线程安全问题</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        synchronized (userId.toString().intern()) {</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//            return proxy.createVoucherOrder(voucherId);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        }</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 分布式锁实现</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// SimpleRedisLock 是自己实现的简单分布式锁</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        SimpleRedisLock lock = new SimpleRedisLock(&#34;order&#34; + userId, stringRedisTemplate);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Rlock 是 redisson 框架提供的分布式锁</span>
</span></span><span style="display:flex;"><span>    RLock lock <span style="color:#f92672">=</span> redissonClient.<span style="color:#a6e22e">getLock</span>(<span style="color:#e6db74">&#34;lock:order:&#34;</span> <span style="color:#f92672">+</span> userId);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> isLock <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">tryLock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;不允许重复下单！&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取 spring 事务的代理对象，如果直接调用 createVoucherOrder 方法可能会造成 spring 事务失效</span>
</span></span><span style="display:flex;"><span>        IVoucherOrderService proxy <span style="color:#f92672">=</span> (IVoucherOrderService) AopContext.<span style="color:#a6e22e">currentProxy</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// spring 的事务实现是通过动态代理技术实现的，拿到代理对象来调用方法能保证事务的有效性</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> proxy.<span style="color:#a6e22e">createVoucherOrder</span>(voucherId);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Result <span style="color:#a6e22e">createVoucherOrder</span>(Long voucherId) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通过拦截器获取登录用户名</span>
</span></span><span style="display:flex;"><span>    Long userId <span style="color:#f92672">=</span> UserHolder.<span style="color:#a6e22e">getUser</span>().<span style="color:#a6e22e">getId</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 优惠券一个用户最多购买一次</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> query().<span style="color:#a6e22e">eq</span>(<span style="color:#e6db74">&#34;user_id&#34;</span>, userId).<span style="color:#a6e22e">eq</span>(<span style="color:#e6db74">&#34;voucher_id&#34;</span>, voucherId).<span style="color:#a6e22e">count</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;用户已经购买过一次！&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 扣减库存</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> success <span style="color:#f92672">=</span> seckillVoucherService.<span style="color:#a6e22e">update</span>()
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">setSql</span>(<span style="color:#e6db74">&#34;stock = stock - 1&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 第二个 gt 是加了一个乐观锁，判断现在查询到的库存和之前的库存是否一样，从而来判断数据库是否被修改过</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 能解决高并发下的线程安全问题</span>
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">eq</span>(<span style="color:#e6db74">&#34;voucher_id&#34;</span>, voucherId).<span style="color:#a6e22e">gt</span>(<span style="color:#e6db74">&#34;stock&#34;</span>, 0)
</span></span><span style="display:flex;"><span>            .<span style="color:#a6e22e">update</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>success) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 扣减库存失败</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">fail</span>(<span style="color:#e6db74">&#34;库存不足！&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 接下来创建订单</span>
</span></span><span style="display:flex;"><span>    VoucherOrder voucherOrder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> VoucherOrder();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 生成全局唯一订单 id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> orderId <span style="color:#f92672">=</span> redisIdWorker.<span style="color:#a6e22e">nextId</span>(<span style="color:#e6db74">&#34;order&#34;</span>);
</span></span><span style="display:flex;"><span>    voucherOrder.<span style="color:#a6e22e">setId</span>(orderId);
</span></span><span style="display:flex;"><span>    voucherOrder.<span style="color:#a6e22e">setUserId</span>(userId);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置优惠券 id</span>
</span></span><span style="display:flex;"><span>    voucherOrder.<span style="color:#a6e22e">setVoucherId</span>(voucherId);
</span></span><span style="display:flex;"><span>    save(voucherOrder);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回订单 id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Result.<span style="color:#a6e22e">ok</span>(orderId);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>redisson 中的 <code>tryLock</code> 方法：
<ul>
<li><code>tryLock()</code>：它会使用默认的超时时间和等待机制。具体的超时时间是由 Redisson 配置文件或者自定义配置决定的。</li>
<li><code>tryLock(long time, TimeUnit unit)</code>：它会在指定的时间内尝试获取锁（等待time后重试），如果获取成功则返回 true，表示获取到了锁；如果在指定时间内（Redisson内部默认指定的）未能获取到锁，则返回 false。</li>
<li><code>tryLock(long waitTime, long leaseTime, TimeUnit unit)</code>：指定等待时间为watiTime，如果超过 leaseTime 后还没有获取锁就直接返回失败;</li>
</ul>
</li>
</ul>
<h4 id="分布式锁-redisson-可重入锁原理">分布式锁-redisson 可重入锁原理：<a hidden class="anchor" aria-hidden="true" href="#分布式锁-redisson-可重入锁原理">#</a></h4>
<p><img alt="1.webp" loading="lazy" src="https://s2.loli.net/2024/11/09/TCnNgASlvHLf4XM.png"></p>
<p>redisson 可重入机制测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@SpringBootTest</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Slf4j</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedissonTest</span> {
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Resource</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> RedissonClient redissonClient;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> RLock lock;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 方法1获取一次锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method1</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> isLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 创建锁对象</span>
</span></span><span style="display:flex;"><span>            lock <span style="color:#f92672">=</span> redissonClient.<span style="color:#a6e22e">getLock</span>(<span style="color:#e6db74">&#34;lock&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                isLock <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">tryLock</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isLock) {
</span></span><span style="display:flex;"><span>                    log.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;获取锁失败，1&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                log.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;获取锁成功，1&#34;</span>);
</span></span><span style="display:flex;"><span>                method2();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (isLock) {
</span></span><span style="display:flex;"><span>                    log.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;释放锁，1&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 方法二再获取一次锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method2</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> isLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                isLock <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">tryLock</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isLock) {
</span></span><span style="display:flex;"><span>                    log.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;获取锁失败, 2&#34;</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                log.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;获取锁成功，2&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (isLock) {
</span></span><span style="display:flex;"><span>                    log.<span style="color:#a6e22e">info</span>(<span style="color:#e6db74">&#34;释放锁，2&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>核心就是用一个哈希结构来存线程和获取锁的次数 。</strong></p>
<h4 id="分布式锁-redisson-锁重试和-watchdog-机制">分布式锁-redisson 锁重试和 WatchDog 机制<a hidden class="anchor" aria-hidden="true" href="#分布式锁-redisson-锁重试和-watchdog-机制">#</a></h4>
<p><strong>不可重试问题 : 获取锁一次就返回false , 没有重试机制</strong> 。</p>
<p>上面有提到 tryLock 方法的一种参数组合：</p>
<p><code>tryLock(long waitTime, long leaseTime, TimeUnit unit)</code>：指定等待时间为 waitTime，在等待时间内进行获取锁的多次尝试 ，直到等待时间结束（超过 leaseTime）还没有获取锁成功 ，才会返回 false,加了这个参数就变成了一个可重试的锁了；</p>
<p><strong>WatchDog 机制</strong>：</p>
<p>WatchDog 机制是 Redisson 的一个重要特性，用于自动延长锁的有效时间，防止因客户端崩溃或网络问题导致的锁提前释放。当客户端成功获取锁后，Redisson 会在后台启动一个 WatchDog，定期检查锁的状态并自动续期。</p>
<p><strong>如何使用 WatchDog 机制？</strong></p>
<ol>
<li><strong>自动续期</strong>：当客户端成功获取锁后，Redisson 会自动启动一个 WatchDog，定期发送续期请求，确保锁不会因为超时而被自动释放。</li>
<li><strong>续期间隔</strong>：默认情况下，WatchDog 的续期间隔是锁的持有时间的一半。例如，如果锁的持有时间是 10 秒，那么 WatchDog 每 5 秒会自动发送一次续期请求。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>RLock lock <span style="color:#f92672">=</span> redissonClient.<span style="color:#a6e22e">getLock</span>(<span style="color:#e6db74">&#34;myLock&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试获取锁，最多等待10秒，上锁以后30秒自动解锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> isLocked <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">tryLock</span>(10, 30, TimeUnit.<span style="color:#a6e22e">SECONDS</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (isLocked) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Lock acquired!&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 执行业务逻辑</span>
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(5000); <span style="color:#75715e">// 模拟耗时操作</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Failed to acquire lock.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放锁</span>
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Lock released.&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
