<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Notes | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Notes - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/notes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/notes/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/notes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Notes
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Springboot框架学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>SpringBoot概念与功能 概念
SpringBoot提供一种快速使用Spring的方式 基于约定优于配置的思想 不必在配置与逻辑业务之间进行思维切换，全身心投入到逻辑业务的代码编写 功能
自动配置：SpringBoot的自动配置是一个运行时（准确来说是程序启动时）的过程，这些过程均由SpringBoot自动完成
起步依赖：将具备某种功能的坐标打包到一起，并提供一些默认的功能
辅助功能：提供一些大型项目中的非功能性特性，如嵌入式服务器、安全、指标等
SpringBoot配置 配置文件分类 SpringBoot是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置的话，可以使用**application.properties或者application.yml(application.yaml)**进行配置
properties server.port=8080 yml server port: 8080 SpringBoot提供了2种配置文件类型：properties和yml/yaml 默认配置文件名称：application 在同一级目录下优先级为：properties &gt; yml &gt; yaml yaml文件 yaml全称是YAML Ain’t Markup Language。yaml是一种直观的能被电脑识别的数据序列化格式，并容易理解阅读。
yaml基本语法
大小写敏感 数据值前必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（不同操作系统Tab对应的空格数可能不同，导致层级混乱） 所进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 server port: 8080 address: 127.0.0.1 name: abc yaml数据格式
对象(map)：键值对的集合 person: name: zhangsan # 行内写法 person: {name: zhangsan} 数组：一组按次序排列的值 address: - beijing - shanghai # 行内写法 address: [beijing,shanghai] 纯量：单个的、不可再分的值（可理解为常量） msg1: &#39;hello \n world&#39; # 单引号忽略转义字符 msg2: &#34;hello \n world&#34; # 双引号识别转义字符 参数引用 name: lisi person: name: ${name} # 引用上面定义的name的值 读取配置文件内容 @Value @Value(&#34;${name}&#34;) private String name; @Value(&#34;${person.name}&#34;) private String name2; Environment @Autowired private Environment env; System.out.println(env.getProperty(&#34;person.name&#34;)); System.out.println(env.getProperty(&#34;address[0]&#34;)); @ConfigurationProperties 创建对象与yml配置文件的内容进行绑定
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Springboot框架学习笔记" href="http://localhost:1313/notes/2024-5-13-springboot/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Spring框架学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>IoC(Inversion of Control) 控制反转与DI(Dependency Injection)依赖注入 IoC(Inversion of Control) 控制反转
使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转（降低程序的耦合度） Spring技术对IoC思想进行了实现
Spring提供了一个容器，称为IoC容器，用来充当思想中的“外部”
IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中被称为Bean
DI(Dependency Injection) 依赖注入
在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 以上操作的目标：充分解耦
bean相关 bean配置 bean基础配置
id：bean的id，使用容器可以通过id值获取对应的bean，在一个容器中id值唯一
class：bean的类型，即配置的bean的全路径类名
例子
&lt;bean id=&#34;bookDao&#34; class=&#34;com.itheima.dao.impl.BookDaoImpl&#34;/&gt; &lt;bean id=&#34;bookService&#34; class=&#34;com.itheima.service.impl.BookServiceImpl&#34;&gt; bean的别名 name：为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔 例子 &lt;bean id=&#34;bookService&#34; name=&#34;service service4 bookEbi&#34; class=&#34;com.itheima.service.impl.BookServiceImpl&#34;&gt; &lt;property name=&#34;bookDao&#34; ref=&#34;bookDao&#34;/&gt; &lt;/bean&gt; bean的作用范围 scope：为bean设置作用范围，可选值为单例singleton，非单例prototype，若不写scope，则默认是单例对象 例子 &lt;bean id=&#34;bookDao&#34; name=&#34;dao&#34; class=&#34;com.itheima.dao.impl.BookDaoImpl&#34; scope=&#34;prototype&#34;/&gt; bean实例化 使用FactoryBean的方式实例化bean对象
实现FactoryBean接口，指定创建的泛型对象 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class&lt;?&gt; getObjectType() { return UserDao.class; } // 控制创建的bean是单例的还是非单例的，通常都是单例的 public boolean isSingleton() { return true; } } 配置 &lt;!--方式四：使用FactoryBean实例化bean--&gt; &lt;!--注意，这种构造方法创建的不是FactoryBean对象，而是FactoryBean对象中的getObject对象--&gt; &lt;bean id=&#34;userDao&#34; class=&#34;com.itheima.factory.UserDaoFactoryBean&#34;/&gt; bean的生命周期 初始化容器
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Spring框架学习笔记" href="http://localhost:1313/notes/2024-5-5-spring/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">TCP超时重传机制的底层原理
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是 TCP 的超时重传？ 我们先回顾一下 TCP 的三个特点：面向连接、可靠、基于字节流，那么 TCP 的可靠传输是如何实现的呢？超时重传机制就是保证 TCP 可靠传输的一种手段。
超时重传能确保数据在传输过程中，即使因为丢包、网络延迟或其他原因导致数据包没有成功到达接收方，依然能够重新发送，从而实现可靠的数据传输。通俗来讲，超时重传就是发送方在发送数据后，会等待接收方的确认（回传的 ACK 报文）。如果没有在规定的时间内收到确认，就会重新发送数据包。
注意：ACK 报文是不会重传的。
超时重传的基本原理 每次发送一个数据包时，发送方都会设置一个定时器，该定时器会在一定的时间内等待接收方的 ACK 确认。如果定时器超时之前收到了 ACK ，则说明数据包成功到达接收方，TCP 连接继续进行。如果定时器到期了仍然没有收到 ACK ，则认为数据包丢失或者未达到接收方，发送方就会重新发送该数据包，这就是超时重传机制的基本原理。
如果发送方一直没有收到 ACK 确认，就会继续重发报文。但是一直重发也不行，因此在 Linux 中有一个 TCP 参数控制重传次数：tcp_orphan_retries 。当发送方重传报文的次数超过 tcp_orphan_retries 后，就不再重传报文。
我们以 TCP 的四次挥手中第一次挥手为例，当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。
正常情况下，如果能及时收到服务端（被动关闭方）的 ACK ，则会很快变为 FIN_WAIT_2 状态。
如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。
当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还没能收到第二次挥手，那么直接进入到 close 状态。
定时器的工作原理 定时器是超时重传机制的核心，定时器的作用是等待接收方的确认，如果超时没有收到确认，就进行重传。
初始定时器设置：当发送方发送一个数据包时，它会设置一个定时器，并假设接收方在规定时间内收到并确认数据。这个规定时间通常是根据网络环境和 RTT（Round Trip Time，往返时间）来设定的。 往返时间 RTT：每次发送数据包时，TCP会估计网络的 RTT ，并根据 RTT 来动态调整定时器的超时时间。这个值越小，重传的等待时间越短，反之越长。 动态调整超时：TCP 使用 RTT的估算值 来设置定时器。当连接进行数据传输时，它会记录每次的往返时间 RTT ，并动态调整定时器的超时值。这个值叫做 RTO（Retransmission Timeout），即重传超时时间。RTO 会根据网络的实际延迟自动调节，以避免因过短或过长的超时时间导致过多不必要的重传或超时。 参考：https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to TCP超时重传机制的底层原理" href="http://localhost:1313/notes/2025-2-27-tcp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">一致性哈希
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 什么是一致性哈希？ 一致性哈希是一种特殊的哈希算法，主要用于分布式系统中，用于将数据分配到多个节点上，保证数据在节点变动时能够尽可能少地重新分配，提高系统的稳定性和扩展性。
它的核心思想是通过将数据和节点映射到一个虚拟的环形空间（哈希环）中，根据数据的位置决定存储在哪个节点上。当节点发生增删时，尽量减少数据的迁移量。
2. 背景与问题 在分布式系统中，数据存储在多个服务器（节点）上，为了实现负载均衡，我们通常需要通过哈希算法将数据映射到不同的节点。例如：
传统的哈希分布：
假设有 4 个服务器节点（A, B, C, D），我们用简单的哈希算法将数据分配到这些节点上：
hash(data) % N N 是节点数，hash(data) 是数据的哈希值。 比如：hash(&#34;data1&#34;) % 4 = 2，data1 被分配到节点 C。 问题：当节点变动时
如果增加一个新节点（如 E，节点数变为 5），所有的数据都需要重新分配：
hash(data) % 5 这会导致几乎所有数据重新分布，迁移代价非常高。
3. 一致性哈希的核心思想 一致性哈希通过一个环形空间解决了传统哈希算法的上述问题。
3.1 哈希环 一致性哈希将整个哈希值范围（如 0 ~ 2^32-1）组织成一个环形结构。 节点（服务器）和数据都通过哈希算法映射到这个环上。 节点的哈希：hash(node) 数据的哈希：hash(data) 3.2 数据存储规则 一个数据被存储到环上顺时针方向第一个节点（或称“后继节点”）上。
比如，节点 A、B、C、D 在环上，数据 data1 映射到节点之间的位置，则：
hash(data1) → 找到顺时针方向最近的节点 如果 hash(data1) 位于节点 A 和节点 B 之间，则数据 data1 存储到节点 B。
3.3 动态增减节点 当有新节点加入或离开时，只需要迁移受影响范围内的少量数据。 例如： 如果节点 E 加入环，它负责环上从前继节点（如 D）到自身之间的数据。 其他节点的数据分布不会受到影响。 4. 虚拟节点 在实际应用中，由于节点的分布可能不均匀，容易导致数据倾斜问题（部分节点存储的数据量过大）。为了解决这个问题，引入了虚拟节点的概念。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 一致性哈希" href="http://localhost:1313/notes/2024-12-19-hash/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">云原生
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是云原生？ 云原生是一种构建和运行应用程序的方法，它利用云计算的优势，使应用程序能够更好地适应云环境的动态性、弹性和分布式特性。云原生技术体系包含容器、容器编排、微服务、服务网格、不可变基础设施等一系列技术和理念。
弹性伸缩：能够根据业务负载的变化自动调整资源，实现快速的扩缩容，以确保应用程序始终能够以最佳性能运行 高可用性：通过多副本、故障转移等机制，保证应用程序在部分组件出现故障时仍能正常运行，提供持续的服务 敏捷开发与部署：支持快速迭代和频繁部署，开发团队可以更高效地进行应用程序的开发、测试和上线 资源高效利用：容器化技术使得多个应用程序可以共享底层基础设施资源，提高资源的利用率，降低成本 云原生代表技术 容器 一般我们说的“容器”（LinuxContainer，LXC），都是 “Linux容器” 。开源解决方案供应商红帽官网给出的容器定义：Linux® 容器是与系统其他部分隔离开的一系列进程。运行这些进程所需的所有文件都由另一个镜像提供，这意味着从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。
容器提供进程级的隔离，可以将操作系统管理的资源划分到相互隔离的组中，在相互隔离的组之间解决资源使用存在冲突的问题。比如 APP1 只能在 centOS 上运行，APP2 只能在 Ubuntu 上运行，而同一个操作系统同时运行 APP1 和 APP2 就产生冲突，容器技术则恰恰可以解决这类问题。
Docker Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，即：整个操作系统的文件系统也打包了进去。Docker 项目大大降低了容器技术的使用门槛，轻量级，可移植，虚拟化，语言无关，写了程序扔上去做成镜像可以随处部署和运行，开发、测试和生产环境彻底统一了，还能进行资源管控和虚拟化。
典型的 Docker 平台包括 Kubernetes、Openshift V3 等。一句话解释 Docker？
没有集装箱就没有全球化，Docker 就是 IT 世界里的集装箱。
Kubernetes 有了容器，就需要编排管理容器的生命周期，K8s 就是一个通用容器编排调度器，用于编排管理容器的生命周期。
一个 K8s 集群，主要包括两个部分：一个 Master 节点和一群 Node 节点。
Master（主节点）：控制 K8s 节点的机器，也是创建作业任务的地方 Node（节点）：这些机器在 K8s 主节点的控制下执行被分配的任务，一个 Node 可能会运行多个 Pod，Pod 中的容器共同协作来提供某种服务 Pod：K8s 中最小的可部署和可管理的计算单元，由一个或多个容器构成的集合，作为一个整体被部署到一个单一节点。同一个 Pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷 Replicationcontroller：控制一个 Pod 在集群上运行的实例数量，用于确保 Pod 的副本数量始终保持在指定的数量 Service：用来暴露 Pod 的一种抽象机制，可以把它想象成一个 “网关” 或者 “地址簿”。因为 Pod 可能会在不同的 Node 上被创建、销毁或者重新调度，它们的 IP 地址是动态变化的。而 Service 为 Pod 提供了一个固定的 IP 地址和 DNS 名称，其他应用程序可以通过这个固定的地址来访问 Pod 提供的服务，而不需要关心 Pod 具体在哪个节点上以及其 IP 地址的变化 Kubelet：这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行 K8s 的出现与其说是从最初的容器编排解决方案开始，倒不如说是为了解决应用上云（即云原生应用）这个难题。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 云原生" href="http://localhost:1313/notes/2025-4-25-cloud_native/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">什么是强引用、软引用、弱引用和虚引用？
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 强引用（Strong Reference） 强引用是最普通的引用，比如 Object obj = new Object();。只要强引用存在，对象就不会被垃圾回收。
强引用特点：
绝不回收：只要强引用存在，即使内存不足（OOM），JVM 宁可抛出内存错误，也不回收对象。 常见场景：日常代码中的普通对象都是强引用。 2. 软引用（Soft References） 软引用通过 SoftReference 类实现，比如 SoftReference&lt;Object&gt; softRef = new SoftReference&lt;&gt;(obj); 。
软引用特点：
内存不足时回收：当 JVM 发现内存不足时，会回收软引用指向的对象。 适合做缓存：比如缓存图片，内存不足时自动清理，避免 OOM 。 // 创建一个软引用 SoftReference&lt;byte[]&gt; softRef = new SoftReference&lt;&gt;(new byte[1024 * 1024]); // 使用对象 byte[] data = softRef.get(); // 如果对象未被回收，可以拿到 3. 弱引用（Weak Reference） 弱引用通过 WeakReference 类实现，比如 WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj); 。
弱引用特点：
立即回收：和软引用类似，但软引用在发生垃圾回收时不一定会被回收（内存不足时软引用才被回收），而弱引用无论内存是否充足，只要发生垃圾回收，弱引用指向的对象都会被回收。 适合临时缓存：比如维护一种可有可无的缓存（如 ThreadLocal 中的 Entry 就是弱引用）。 WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object()); System.gc(); // 触发垃圾回收（非强制） System.out.println(weakRef.get()); // 可能输出 null 4. 虚引用（Phantom Reference） 虚引用通过 PhantomReference 类实现，必须配合引用队列使用。举个例子，虚引用就像在物品（对象）上安装了一个“销毁报警器”。当物品被销毁时（对象被垃圾回收），你会收到一个通知，但是你永远拿不到这个物品本身。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 什么是强引用、软引用、弱引用和虚引用？" href="http://localhost:1313/notes/2025-1-29-references/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式相关：CAP和BASE
    </h2>
  </header>
  <div class="entry-content">
    <p>1.CAP 理论 CAP 原则又称为 CAP 定理，指的是在一个分布式系统中，Consistency（一致性） 、Availability（可用性） 、Partition tolerance（分区容错性） 这三个基本需求，最多只能同时满足其中的两个。
那么 CAP 分别是什么？
一致性（C）：数据在多个副本之间能够保持一致的特性 可用性（A）：系统提供的服务一直处于可用的状态，每次请求都能获得正确的响应 分区容错性（P）：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务 什么是分区？ 在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。
为什么 CAP 三者不可兼得？ 首先，在分布式系统中，分区是不可避免的，因此分区容错性（P）是一定要满足的。接下来再看看，在满足分区容错的基础上，能不能同时满足一致性（C）和可用性（A）。
假如现在有两个分区 N1 和 N2 ，N1 和 N2 分别有不同的分区存储 D1 和 D2 ，以及不同的服务 S1 和 S2 。
在满足**一致性（C）**时，N1 和 N2 的数据要求值一样，D1 = D2 在满足**可用性（A）**时，无论访问 N1 还是 N2 ，都能获取及时的响应 现在有这样的场景：
用户访问了 N1 ，修改了 D1 的数据 用户再次访问，但此时请求落在了 N2 ，此时 D1 和 D2 的数据不一致 接下来：
保证一致性（C）：此时 D1 和 D2 数据不一致，要保证一致性就不能返回不一致的数据，此时**可用性（A）**就无法保证 保证可用性（A）：立即响应，可用性得到了保证，但是此时相应的数据和 D1 不一致，此时**一致性（C）**就无法保证 可以看出，在满足**分区容错性（P）**的前提下，**一致性（C）和可用性（A）**是矛盾的
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分布式相关：CAP和BASE" href="http://localhost:1313/notes/2025-3-11-capvsbase/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式锁
    </h2>
  </header>
  <div class="entry-content">
    <p>基本原理和实现方式 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。 那么分布式锁他应该满足的条件呢？ 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行 高可用：程序不易崩溃，时时刻刻都保证较高的可用性 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能 安全性：安全也是程序中必不可少的一环 常见的分布式锁有三种： Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见 Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，zookeeper中实现分布式锁主要依赖于它的临时节点（ephemeral node）和顺序节点（sequential node）特性。 Redis 分布式锁的实现核心思路 实现分布式锁时需要实现的两个基本方法：
获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回 true，失败返回 false 释放锁： 手动释放 超时释放：获取锁时添加一个超时时间 实现核心思路：
我们利用 redis 的 setnx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个 key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可。
实现基于 redis 的分布式锁 分布式锁的基本接口
/** * 分布式锁 */ public interface ILock { /** * 尝试获取锁 * @param timeoutSec * @return */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unlock(); } 简单分布式锁的实现
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分布式锁" href="http://localhost:1313/notes/2024-11-9-distributed_lock/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">在MySQL集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？
    </h2>
  </header>
  <div class="entry-content">
    <p>参考：https://golangguide.top/
对于 MySQL 数据库，为了得到更高的性能，一般会搭建 MySQL 集群实现读写分离，主库用于写操作，从库用于读操作。虽然主库一般用于写，但也是能读的。那么就有这样一个问题：在 MySQL 集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？
正常的主从更新流程 假设在主库和从库中都有一张 user 表，此时有以下数据：
id name age 1 小王 72 2 小李 60 我们往主库执行写操作时，一般都能理解成单条语句的事务，比如下面两段 SQL 效果相同：
update user set age = 50 where id = 1; begin; update user set age = 50 where id = 1; commit; 如果事务执行成功了，数据会先写入到主库的 binlog 文件中，然后再刷入磁盘。
binlog 文件是 MySQL 的 server 层日志，记录了用户对数据库有哪些变更操作，比如建数据库表、加字段，以及对某些行的增删改等。
如果两个 MySQL 节点配置好了主从关系，那么它们之间会建立一个 TCP 长连接，主要用于传输同步数据。
除此之外，主库还会再创建一个 binlog dump 线程，将 binlog 文件的变更发送给从库。以上，主库的工作就结束了。
当从库通过之前创建的 TCP 长连接收到 binlog 后，会有一个 IO 线程负责把收到的数据写入到 **relay log（中继日志）**中，然后再有一个 SQL 线程来读取 relay log 的内容，接下来对从库执行 SQL 语句操作，完成数据的主从同步。
为什么要先写一遍 relay log 然后再写从库？ relay log 的作用就类似一个中间层，主库是多线程并发写的，从库的 SQL 线程是单线程串行执行的，所以两边的生产和消费速度肯定不同。当主库的 binlog 消息过多时，从库的 relay log 可以起到暂存主库数据的作用，接着从库的 SQL 线程再慢慢消费这些 relay log 数据，这样既不会限制主库发消息的速度，也不会给从库造成过大的压力。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 在MySQL集群中，在从库已经读到了最新值的情况下，主库还有可能读到旧值吗？" href="http://localhost:1313/notes/2025-1-18-mysql_cluster/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">微服务体系结构、Nacos和熔断器
    </h2>
  </header>
  <div class="entry-content">
    <p>微服务四大设计原则 独立部署 每个微服务都应该能够独立部署、升级和扩展，而不影响其他微服务的正常运行。独立部署使得微服务架构能够灵活应对变化，无论是业务需求变化、性能优化，还是技术更新，都能以最小的代价进行。
减少系统间的依赖：一个微服务的更新或部署不会影响到其他服务，避免了传统单体应用中常见的“大规模部署”问题。 更高的开发和运维效率：可以根据需求，独立迭代、测试和发布某个微服务。 弹性扩展：某些高负载的微服务可以独立扩展，其他微服务不受影响。 比如，在一个电商系统中，订单服务和支付服务是两个微服务。当订单服务的某个功能需要更新时，可以单独更新订单服务而不影响支付服务的正常运行。
集中配置 微服务架构中，所有微服务的配置应该集中管理。配置管理工具（如 nacos 或 eureka）可以帮助我们集中管理和动态更新多个微服务的配置，而无需分别修改每个微服务的配置文件。如果不进行集中配置，当我们修改某个微服务的配置文件时，就需要对该微服务进行重新打包部署，非常繁琐。
统一管理：避免每个微服务有独立配置文件，造成分散管理的复杂性。 快速更新：可以集中更新所有服务的配置，而无需重新部署每个服务。 灵活性和一致性：不同环境（开发、测试、生产）可以共享配置管理，确保配置的一致性。 客户透明 客户（客户端）与微服务之间的交互应该尽量透明，客户端不应关注微服务的内部实现和部署细节。对于微服务来说，不同微服务之间会存在相互调用，而调用的方式并不会通过微服务所在的服务器 ip 去发送请求，而是通过一个查名服务器来集中管理所有服务器 ip 。这样就能使得不同微服务之间直接通过服务名称进行调用。
简化客户端开发：客户端只需要调用暴露的 API，不关心服务的具体实现或是否有多个服务在背后处理请求。 提升用户体验：即使微服务背后发生了变更，客户端与服务的通信方式保持一致，用户感知不到系统的变动。 更好的扩展性和灵活性：服务可以随着需求变化进行重构或扩展，客户端无需做任何更改。 服务容错 微服务架构应该能够容忍部分服务的故障，避免单个微服务的故障引发整个系统崩溃。通过采取容错策略（如熔断器、重试机制、回退策略等），即使某个服务出现问题，系统的其余部分也能继续正常工作。
增强系统可靠性：服务容错使得系统能够在部分服务失败的情况下继续正常运行，避免级联故障。 提高用户体验：即使某个微服务出现故障，系统仍能返回合适的错误信息或提供降级服务，不至于让用户体验到大规模的中断。 容忍服务的不可预测性：在分布式系统中，网络延迟、服务崩溃等都是常见问题，容错机制有助于减轻这些问题带来的影响。 Nacos Nacos（全称：Dynamic Naming and Configuration Service）是一个开源的 动态服务发现、配置管理 和 服务管理 平台，主要用于分布式系统中微服务架构的服务治理。简单来说，Nacos 解决了微服务架构中服务注册、发现、配置管理等问题。
在一个微服务架构中，服务通常是分布式的，服务的实例可能会动态变化（比如启动、关闭或重启），而每个服务也可能会有不同的配置（如数据库连接、API 配置等）。如何管理这些动态变化的服务和配置，就成了一个挑战。Nacos 就是为了解决这些问题而出现的。
主要功能：
服务注册与发现 微服务架构中，多个微服务需要相互通信。Nacos 提供了服务注册与发现功能，每个微服务启动时会把自己的信息（如 IP、端口等）注册到 Nacos 上，其他微服务可以通过 Nacos 来查找并调用它。 这样，如果某个微服务的实例发生变化（如重新启动或增加新的实例），Nacos 会自动更新，避免了硬编码和手动维护服务地址。 动态配置管理 Nacos 允许集中管理微服务的配置信息（如数据库连接、日志级别等）。你可以将配置文件统一保存在 Nacos 上，微服务启动时从 Nacos 获取配置信息（如果 Nacos 服务器上没有对应的配置信息，则使用本地的配置文件）。 更重要的是，当配置发生变化时（例如修改数据库连接），Nacos 可以实现 热更新，服务无需重启就可以自动加载新的配置，确保服务配置的动态调整。 服务健康检查 Nacos 会定期检查注册到它的服务的健康状态，如果某个微服务宕机或无法访问，Nacos 会自动剔除掉这个服务的注册信息，避免客户端访问失效的服务。 分布式锁 Nacos 支持分布式锁机制，帮助解决微服务间的并发控制问题。 多种数据源支持 Nacos 支持多种配置数据源，包括 数据库、文件、KV 存储等，方便集成和扩展。 Nacos 的数据存储在哪里？ Nacos 默认使用 嵌入式数据库 来存储数据，但在实际生产环境中，存在大规模的并发请求，Nacos 默认的嵌入式数据库没有高可用性保障，因此往往选择将数据存储到 外部数据库（如 MySQL）中。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 微服务体系结构、Nacos和熔断器" href="http://localhost:1313/notes/2025-2-11-nacos_and_fuses/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/notes/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/notes/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
