<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Notes | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Notes - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/notes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/notes/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/notes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Notes
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">微服务体系结构、Nacos和熔断器
    </h2>
  </header>
  <div class="entry-content">
    <p>微服务四大设计原则 独立部署 每个微服务都应该能够独立部署、升级和扩展，而不影响其他微服务的正常运行。独立部署使得微服务架构能够灵活应对变化，无论是业务需求变化、性能优化，还是技术更新，都能以最小的代价进行。
减少系统间的依赖：一个微服务的更新或部署不会影响到其他服务，避免了传统单体应用中常见的“大规模部署”问题。 更高的开发和运维效率：可以根据需求，独立迭代、测试和发布某个微服务。 弹性扩展：某些高负载的微服务可以独立扩展，其他微服务不受影响。 比如，在一个电商系统中，订单服务和支付服务是两个微服务。当订单服务的某个功能需要更新时，可以单独更新订单服务而不影响支付服务的正常运行。
集中配置 微服务架构中，所有微服务的配置应该集中管理。配置管理工具（如 nacos 或 eureka）可以帮助我们集中管理和动态更新多个微服务的配置，而无需分别修改每个微服务的配置文件。如果不进行集中配置，当我们修改某个微服务的配置文件时，就需要对该微服务进行重新打包部署，非常繁琐。
统一管理：避免每个微服务有独立配置文件，造成分散管理的复杂性。 快速更新：可以集中更新所有服务的配置，而无需重新部署每个服务。 灵活性和一致性：不同环境（开发、测试、生产）可以共享配置管理，确保配置的一致性。 客户透明 客户（客户端）与微服务之间的交互应该尽量透明，客户端不应关注微服务的内部实现和部署细节。对于微服务来说，不同微服务之间会存在相互调用，而调用的方式并不会通过微服务所在的服务器 ip 去发送请求，而是通过一个查名服务器来集中管理所有服务器 ip 。这样就能使得不同微服务之间直接通过服务名称进行调用。
简化客户端开发：客户端只需要调用暴露的 API，不关心服务的具体实现或是否有多个服务在背后处理请求。 提升用户体验：即使微服务背后发生了变更，客户端与服务的通信方式保持一致，用户感知不到系统的变动。 更好的扩展性和灵活性：服务可以随着需求变化进行重构或扩展，客户端无需做任何更改。 服务容错 微服务架构应该能够容忍部分服务的故障，避免单个微服务的故障引发整个系统崩溃。通过采取容错策略（如熔断器、重试机制、回退策略等），即使某个服务出现问题，系统的其余部分也能继续正常工作。
增强系统可靠性：服务容错使得系统能够在部分服务失败的情况下继续正常运行，避免级联故障。 提高用户体验：即使某个微服务出现故障，系统仍能返回合适的错误信息或提供降级服务，不至于让用户体验到大规模的中断。 容忍服务的不可预测性：在分布式系统中，网络延迟、服务崩溃等都是常见问题，容错机制有助于减轻这些问题带来的影响。 Nacos Nacos（全称：Dynamic Naming and Configuration Service）是一个开源的 动态服务发现、配置管理 和 服务管理 平台，主要用于分布式系统中微服务架构的服务治理。简单来说，Nacos 解决了微服务架构中服务注册、发现、配置管理等问题。
在一个微服务架构中，服务通常是分布式的，服务的实例可能会动态变化（比如启动、关闭或重启），而每个服务也可能会有不同的配置（如数据库连接、API 配置等）。如何管理这些动态变化的服务和配置，就成了一个挑战。Nacos 就是为了解决这些问题而出现的。
主要功能：
服务注册与发现 微服务架构中，多个微服务需要相互通信。Nacos 提供了服务注册与发现功能，每个微服务启动时会把自己的信息（如 IP、端口等）注册到 Nacos 上，其他微服务可以通过 Nacos 来查找并调用它。 这样，如果某个微服务的实例发生变化（如重新启动或增加新的实例），Nacos 会自动更新，避免了硬编码和手动维护服务地址。 动态配置管理 Nacos 允许集中管理微服务的配置信息（如数据库连接、日志级别等）。你可以将配置文件统一保存在 Nacos 上，微服务启动时从 Nacos 获取配置信息（如果 Nacos 服务器上没有对应的配置信息，则使用本地的配置文件）。 更重要的是，当配置发生变化时（例如修改数据库连接），Nacos 可以实现 热更新，服务无需重启就可以自动加载新的配置，确保服务配置的动态调整。 服务健康检查 Nacos 会定期检查注册到它的服务的健康状态，如果某个微服务宕机或无法访问，Nacos 会自动剔除掉这个服务的注册信息，避免客户端访问失效的服务。 分布式锁 Nacos 支持分布式锁机制，帮助解决微服务间的并发控制问题。 多种数据源支持 Nacos 支持多种配置数据源，包括 数据库、文件、KV 存储等，方便集成和扩展。 Nacos 的数据存储在哪里？ Nacos 默认使用 嵌入式数据库 来存储数据，但在实际生产环境中，存在大规模的并发请求，Nacos 默认的嵌入式数据库没有高可用性保障，因此往往选择将数据存储到 外部数据库（如 MySQL）中。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 微服务体系结构、Nacos和熔断器" href="http://localhost:1313/notes/2025-2-11-microservices-architecture-nacos-and-fuses/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">死锁产生的条件？如何诊断死锁？
    </h2>
  </header>
  <div class="entry-content">
    <p>死锁产生的条件 在操作系统中，死锁只有同时满足以下四个条件才会发生：
互斥条件 持有并等待条件 不可剥夺条件 环路等待条件 在 java 程序中，由于 java 自带线程，因此自己编写的两条线程也可能出现死锁的情况。
具体而言，java 程序里死锁产生的条件是两条线程分别持有两个锁，并且都在尝试获取对方所持有的锁，这样就造成了死锁。
以下面的程序为例：
public class Main { public static void main(String[] args) { Object A = new Object(); Object B = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (A) { System.out.println(&#34;lock A&#34;); try { sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized (B) { System.out.println(&#34;lock B&#34;); System.out.println(&#34;操作...&#34;); } } }, &#34;t1&#34;); Thread t2 = new Thread(() -&gt; { synchronized (B) { System.out.println(&#34;lock B&#34;); try { sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized (A) { System.out.println(&#34;lock A&#34;); System.out.println(&#34;操作...&#34;); } } }, &#34;t2&#34;); t1.start(); t2.start(); } } 线程 t1 和线程 t2 分别获取了锁 A 和锁 B ，并且都在尝试获取对方的锁，因此就出现了死锁：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 死锁产生的条件？如何诊断死锁？" href="http://localhost:1313/notes/2025-1-21-what-are-the-conditions-for-deadlocks-to-occur-how-do-i-diagnose-a-deadlock/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">线程崩溃后为什么不会导致 JVM 崩溃？
    </h2>
  </header>
  <div class="entry-content">
    <p>要弄明白这个问题，我们从以下几点进行分析：
线程崩溃后，进程一定会崩溃吗？ 进程是如何崩溃的？——信号机制简介 为什么在 JVM 中线程崩溃不会导致 JVM 进程崩溃？ 线程崩溃后，进程一定会崩溃吗？ 一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃。这主要是因为在进程中，各个线程的地址空间是共享的，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而会影响到其他线程，可能导致一系列严重的后果，于是操作系统干脆让整个进程崩溃。
在一个进程中，所有的线程共享代码段、数据段、地址空间，文件非法访问内存有以下几种情况：
针对只读内存写入数据 #include&lt;stdio.h&gt; #includ&lt;stdlib.h&gt; int main() { char *s = &#34;hello world&#34;; // 向只读内存写入数据，导致崩溃 s[1] = &#39;H&#39;; } 访问了进程没有权限访问的地址空间（比如内核空间） #include&lt;stdio.h&gt; #includ&lt;stdlib.h&gt; int main() { int *p = (int *)0xC0000fff; // 针对进程的内核空间写入数据，导致崩溃 *p = 10; } 在 32 位虚拟地址空间中，p 指向的是内核空间
访问了不存在的内存 #include&lt;stdio.h&gt; #includ&lt;stdlib.h&gt; int main() { int *a = NULL; *a = 1; } 以上错误都是访问内存时的错误，会统一报 Segment Fault 错误，这些都会导致进程崩溃
进程是如何崩溃的？——信号机制简介 既然线程崩溃后，进程也会崩溃，那进程到底是如何崩溃的呢？其背后的机制是信号。
如果我们想要杀掉一个正在运行的进程，常常会用到 kill -9 pid 这样的命令，这里的 kill 其实就是给指定 pid 发送终止信号的意思，其中 9 就是信号。
在 Linux 中可以通过 kill -l 查看所有可用的信号：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 线程崩溃后为什么不会导致 JVM 崩溃？" href="http://localhost:1313/notes/2025-1-15-why-doesnt-a-thread-crash-cause-the-jvm-to-crash-after-it-crashes/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">缓存穿透、缓存雪崩、缓存击穿与缓存污染
    </h2>
  </header>
  <div class="entry-content">
    <p>1.缓存穿透 什么是缓存穿透？
我们使用 redis 大部分情况都是通过 key 查询对应的值，假如发送的请求传进来的 key 是不存在redis 中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。
分析：
关键在于在 redis 查不到 key 值，这和缓存击穿有根本的区别，区别在于缓存穿透的情况是传进来的 key 在 redis 中是不存在的。假如有黑客传进大量的不存在的 key ，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。
解决方案：
把无效的 key 存进 redis 中。如果 redis 查不到数据，数据库也查不到，我们把这个 key 值保存进 redis ，设置 value=“null” ，当下次再通过这个 key 查询时就不需要再查询数据库。但这种处理方式肯定是有问题的，假如传进来的这个不存在的 key 值每次都是随机的，那存进 redis 也没有意义，会造成无意义的内存消耗，并且如果某个之前访问过的 key 此时设置了对应的值，那么就会造成 redis 和数据库的短暂不一致。 使用布隆过滤器。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。 布隆过滤器的一种实现：
初始化一个较大的数组，用来存放二进制 0 或 1。一开始数组中数据都为 0，当一个 key 来了之后经过 3 次 hash 计算，得到三个下标 index，将数组中这三个下标对应的数据从 0 改为 1，这样的话数组中三个位置就能标明一个 key 的存在。 当然这种实现也是有误判率的，应该说布隆过滤器的误判率不可能为 0。如果我们想要减少误判率，就得增加数组的长度，但这样会造成更多的内存消耗。 ...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 缓存穿透、缓存雪崩、缓存击穿与缓存污染" href="http://localhost:1313/notes/2024-11-6-cache-penetration-cache-avalanche-and-cache-breakdown/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/notes/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
