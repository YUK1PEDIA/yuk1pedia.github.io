<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Notes | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Notes - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/notes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/notes/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/notes/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Notes
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">mysql 常用指令
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2024-05-23 00:00:00 +0000 UTC'>May 23, 2024</span></footer>
  <a class="entry-link" aria-label="post link to mysql 常用指令" href="http://localhost:1313/notes/2024-5-23-mysql/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">JDBC 学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2024-04-06 00:00:00 +0000 UTC'>April 6, 2024</span></footer>
  <a class="entry-link" aria-label="post link to JDBC 学习笔记" href="http://localhost:1313/notes/2024-4-6-jdbc/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">《Python-craftsman》Reading notes
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 2025/5/11 结束了暑期实习的面试后，非常幸运的，我加入了一个充满活力、技术氛围浓厚的技术团队。在入职 landing 四天里，我体会到了组里对实习生的热情关怀，同时也结交了一位非常优秀，兴趣相投的 mentor。
在这四天里，通过组里的大小会议和上班时的学习过渡，我慢慢了解了组里具体负责的业务和如何用 python 进行后端开发。
这本书的作者是我实习组里的 leader，在入职前就了解到他有出版过 python 相关的书籍，也借此机会来拜读一下。这篇 blog 应该是记录读这本书的过程和一些想法和收获吧，可能也会写一些实习期间的感触 ~
</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 《Python-craftsman》Reading notes" href="http://localhost:1313/notes/2025-5-11-python-craftsman/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Docker
    </h2>
  </header>
  <div class="entry-content">
    <p>1.镜像和容器 利用 Docker 安装应用时，Docker 会自动搜索并下载应用镜像（image）。镜像不仅包含应用本身，还包含应用所需要的环境、配置、系统函数库（此处的环境是最轻量的，只包含容器内运行需要的环境，其他编辑操作可能包含）。Docker 会在运行镜像时创建一个隔离环境，称为容器（container）。
镜像仓库：存储和管理镜像的平台，Docker 官方维护了一个公共仓库：https://hub.docker.com/
2.命令解读 docker run -d \ --name mysql \ -p 3306:3306 \ -e TZ=Asia/Shanghai \ -e MYSQL_ROOT_PASSWORD=123 \ mysql docker run ：创建并运行一个容器，-d 是让容器在后台运行。 --name mysql ：给容器起个名字，必须唯一。 -p 3306:3306 ：设置端口映射，docker 创建的容器拥有独立的文件系统、内存、网络空间等，从外部直接对 docker 容器进行 ping 操作是 ping 不通的，需要设置服务器或虚拟机的端口映射，才能通过服务器或虚拟机访问到上面的 docker 容器。冒号前面的端口是宿主机端口，冒号后面是容器内端口。 -e KEY=VALUE ：设置环境变量。上面的命令中，TZ=Asia/Shanghai 是配置时区 mysql ：指定运行的镜像的名字 补充：镜像命名规范
镜像名称一般分两部分组成：[repository]:[tag] 其中 repository 就是镜像名 tag 是镜像的版本 在没有指定 tag 时，默认是 latest ，代表最新版本的镜像 3.常见命令 docker rmi 是删除镜像，docker rm 是删除容器 docker run 是创建并运行容器，这条命令会创建一个新的容器，如果要启动已经有的容器，需要执行 docker start 命令 docker exec 是进入到容器内部 4.数据卷挂载 数据卷挂载 数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Docker" href="http://localhost:1313/notes/2024-10-8-docker/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Docker 和虚拟机的区别？Docker 是如何实现隔离的？
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 两者的区别是什么？ 首先，Docker 和虚拟机（Virtual Machine, VM）都是用来实现隔离和资源管理的技术，主要目的是让不同的应用程序能够运行在相互独立的环境中，互不干扰。但它们的实现方式、性能和使用场景有很大的区别。
我们用独立的房子和公寓大楼来类比着理解 Docker 和虚拟机的区别：
虚拟机： 可以把虚拟机比作一套完整的“独立房子”：
每个虚拟机都像一栋完整的房子，带有自己的地基（操作系统内核）、墙（硬件模拟）和房间（运行的应用程序）。 每次需要新的虚拟机，就需要重新盖一套完整的房子（安装新的操作系统和硬件模拟），耗时耗力，且占用资源大。 Docker： Docker 更像是住在一栋“公寓大楼”里的租户：
公寓楼（宿主机的操作系统和硬件）已经盖好了，Docker 容器只需要一个隔间（容器）就可以住人，不需要重新建地基（操作系统）。 所有租户（容器）共用这栋公寓楼的公共设施（宿主机内核和资源），但互相独立，各自的生活（程序运行）互不干扰。 根据以上场景，Docker 和虚拟机的区别就比较明显了。下面是他们的核心区别：
特点 虚拟机 Docker（容器） 运行环境 每个虚拟机都有自己的操作系统 容器共用宿主机的操作系统内核 启动速度 启动一个完整的虚拟机需要数十秒到几分钟 启动一个容器通常只需几秒 资源消耗 资源占用高，需要模拟完整硬件和操作系统 资源占用低，直接运行在宿主机上 隔离性 隔离较强，虚拟机之间完全独立 隔离性强，但共用内核（通过内核隔离实现） 性能 性能损耗较大，因为需要硬件虚拟化 性能接近宿主机（因为是直接运行在宿主机上） 镜像大小 镜像较大（包含完整操作系统） 镜像较小（只包含应用程序及其依赖） 技术复杂度 配置复杂，需要安装虚拟机管理程序（如 VMware、VirtualBox） 配置简单，直接运行 Docker 容器 2. Docker 是如何实现隔离的？ Docker 的隔离主要通过以下两种技术实现：
内核级隔离： 利用 Linux 的 Namespace（命名空间）技术。 资源控制： 利用 Linux 的 Cgroups（控制组）技术。 这两种技术结合起来，让容器之间看起来像是“独立的操作系统”，但实际上它们共用同一个宿主机内核。
2.1 Namespace：命名空间（实现环境隔离） Namespace 是什么？ Namespace 是 Linux 内核的一种技术，用于隔离容器的系统资源。通过 Namespace，Docker 可以让每个容器看到的系统资源（如进程、网络、文件系统等）看起来像是独立的。 Namespace 的主要作用： 隔离资源： 不同容器只能看到自己的资源，互相看不到。 独立运行： 每个容器都有自己的文件系统、网络、进程列表等，像是运行在独立的系统中。 Namespace 的具体分类： Docker 利用了以下几种 Namespace 技术： PID Namespace（进程隔离）： 每个容器都有自己的进程空间。 容器内的进程看不到宿主机和其他容器的进程。 Network Namespace（网络隔离）： 每个容器都有自己的网络接口、IP 地址和路由表。 容器之间的网络隔离由 Network Namespace 实现。 Mount Namespace（文件系统隔离）： 每个容器可以拥有自己的文件系统挂载点。 容器内看不到宿主机的文件，除非显式挂载共享目录。 UTS Namespace（主机名隔离）： 每个容器可以有自己的主机名和域名。 IPC Namespace（进程间通信隔离）： 容器之间的共享内存和信号量是隔离的。 User Namespace（用户隔离）： 容器内的用户和宿主机的用户可以映射，从而提供更好的安全性。 2.2 Cgroups：控制组（实现资源限制） Cgroups 是什么？ Cgroups（Control Groups）是 Linux 的一种机制，用于限制和管理容器的资源使用，包括 CPU、内存、磁盘 IO 和网络带宽。 Cgroups 的作用： 限制资源： 限制每个容器最多可以使用的 CPU、内存等资源，防止某个容器消耗过多资源而影响其他容器或宿主机。 优先级分配： 为容器设置资源的优先级。 资源统计： 监控容器的资源使用情况。 隔离资源： 每个容器只能使用分配给它的资源。 Cgroups 就像“用电闸”控制每个家庭的电量。每个家庭（容器）分配了一定的用电量（资源），如果超出配额，就会断电（资源耗尽）。 2.3 UnionFS：文件系统隔离 Docker 使用了 UnionFS（联合文件系统） 来管理容器的文件。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Docker 和虚拟机的区别？Docker 是如何实现隔离的？" href="http://localhost:1313/notes/2024-12-17-docker_vs_vm/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go基础学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>[TOC]
主要特征 语法简单，自带 gc 静态编译，编译好后在服务器直接运行 简单的思想，没有继承、多态、类等 语法层支持并发，拥有同步并发的 channel 类型，使并发开发变得非常方便 内置类型丰富，函数多返回值 反射 Golang 内置类型和函数 内置类型 值类型
bool int(32 or 64), int8, int16, int32, int64 uint(32 or 64), uint8(byte), uint16, uint32, uint64 float32, float64 string complex64, complex128 array -- 固定长度的数组 引用类型（指针类型）
slice -- 序列数组(最常用) map -- 映射 chan -- 管道 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。
append -- 用来追加元素到数组、slice中,返回修改后的数组、slice close -- 主要用来关闭channel delete -- 从map中删除key对应的value panic -- 停止常规的goroutine （panic和recover：用来做错误处理） recover -- 允许程序定义goroutine的panic动作 imag -- 返回complex的实部 （complex、real imag：用于创建和操作复数） real -- 返回complex的虚部 make -- 用来分配内存，返回Type本身(只能应用于slice, map, channel) new -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 cap -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） copy -- 用于复制和连接slice，返回复制的数目 len -- 来求长度，比如string、array、slice、map、channel ，返回长度 print、println -- 底层打印函数，在部署环境中建议使用 fmt 包 内置接口
type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口 Error() String } init 函数和 main 函数 init 函数 go 语言中 init 函数用于包（package）的初始化，该函数是 go 语言的一个重要特性。
init 函数有如下特征：
init 函数是用于程序执行前做包初始化的函数，比如初始化包里的变量等 每个包可以拥有多个 init 函数 包的每个源文件也可以拥有多个 init 函数 同一个包中多个 init 函数的执行顺序 go 语言没有明确的说明 不同包的 init 函数按照包导入的依赖关系决定该初始化函数的执行顺序 init 函数不能被其他函数调用，而是在 main 函数执行之前自动被调用 main 函数 Go语言程序的默认入口函数(主函数)：func main()
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Go基础学习笔记" href="http://localhost:1313/notes/2025-2-5-golang/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java Stream
    </h2>
  </header>
  <div class="entry-content">
    <p>简介 Java 的 Stream API 是 Java 8 引入的一项功能，它主要用于处理集合类（如 List、Set、Map 等）中的元素，提供了一种声明性的方法来进行数据处理。Stream API 提供了许多可以连缀使用的操作，支持高效的顺序和并行流处理。
Stream 并不是存储数据的结构，而是对集合、数组或其他数据源进行操作的一种方式。Stream 对象可以从集合、数组、文件等多种数据源获取。
Stream 的基本特征 惰性求值（Lazy Evaluation）：Stream 的操作是懒惰求值的，只有在最终操作被触发时，Stream 才会进行计算。 可以组合操作：Stream 允许将多个操作链式组合，从而形成一条清晰的流水线。 支持并行处理：Stream 支持通过并行流（parallelStream()）来并发处理数据，能够充分利用多核 CPU，提高处理效率。 无副作用：Stream 的操作通常是无副作用的，即不会改变原始数据源。 Stream 的操作分类 Stream 的操作分为两种类型：
中间操作：如 map()、filter()、sorted()、distinct() 等。中间操作是惰性求值的，只有在终结操作（如 collect()、forEach()）触发时，才会开始执行。 终结操作：如 collect()、forEach()、reduce()、count() 等。终结操作触发整个流水线的执行，并且一次执行后，Stream 就会被消费掉，不能再重新使用。 常用的中间操作 filter()
功能：通过给定的条件过滤流中的元素，返回符合条件的元素
示例：
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List&lt;Integer&gt; evenNumbers = numbers.stream() .filter(n -&gt; n % 2 == 0) .collect(Collectors.toList()); System.out.println(evenNumbers); // [2, 4, 6] map()
功能：对流中的每个元素执行一个函数，返回一个新的流（元素类型可以改变）
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Java Stream" href="http://localhost:1313/notes/2024-11-21-java_stream/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">JavaWeb学习笔记
    </h2>
  </header>
  <div class="entry-content">
    <p>web前端 1.Web标准 Web标准也称为网页标准，由一系列的标准组成 三个组成部分： HTML：负责网页的结构（页面元素和内容） CSS：负责网页的表现（页面元素的外观、位置等页面样式，如颜色、大小等） JavaScript：负责网页的行为（交互效果） 2.HTML、CSS 什么是HTML、CSS？
HTML（HyperText Markup Language）：超文本标记语言 超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容 标记语言：由标签构成的语言 HTML标签都是预定义好的。例如：使用展示超链接，使用展示图片，展示视频 HTML代码直接在浏览器中运行，HTML标签由浏览器解析 CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式 案例：HTML快速入门
新建文本文件，后缀名改为.html 编写HTML结构标签 在中填写内容 小结
HTML结构标签 &lt;html&gt; &lt;head&gt; &lt;title&gt;HTML&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 特点 HTML标签不区分大小写 HTML标签属性值单双引号都可以 HTML语法松散 基础标签&amp;样式
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to JavaWeb学习笔记" href="http://localhost:1313/notes/2024-8-16-javaweb/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Java的反射机制
    </h2>
  </header>
  <div class="entry-content">
    <p>1.什么是反射机制？ 反射（Reflection）是Java中的一个强大功能，允许程序在运行时动态地访问和操作类的元数据（如类名、字段、方法等）。通过反射，Java程序可以在运行时动态地获取类的信息，甚至动态地创建对象和调用方法。
举个简单的例子，在编写程序时，通常是明确地知道类的名字和结构，然后直接使用它们。反射则允许你在运行时才知道类的信息，并通过这些信息去操作类。所以说，反射的作用就是获取类的信息（成员变量、方法、构造方法等）
2.反射机制的工作原理 反射的核心就是通过类的字节码来动态获取类的元数据，并在运行时操作这些信息。反射依赖于Java类加载机制，类的字节码通过类加载器加载到内存中后，反射机制就能操作它们。
2.1 反射的基本流程 类加载：
在Java程序中，类并不是在编译时就加载到内存的，而是当JVM第一次需要使用该类时，它才会加载这个类（如创建实例、调用方法时）。
反射通过Class.forName()等方法动态加载类，并获得该类的Class对象。
获取类的元数据：
通过反射，你可以获取类的构造方法、字段、方法等元数据。这个过程是通过Class对象来实现的。 比如，使用clazz.getDeclaredMethods()可以获取类的所有方法，clazz.getDeclaredFields()可以获取类的所有字段。 动态创建对象和调用方法：
使用反射，你不仅能获取类的信息，还能动态地创建对象、调用方法、修改字段等。通过Method.invoke()可以动态调用类的方法，通过Constructor.newInstance()可以创建类的实例。 2.2 核心类和方法 Class：Class类是反射的核心，它代表了一个类的字节码。通过Class对象，你可以动态获取该类的构造方法、字段、方法等信息。
示例：
Class&lt;?&gt; clazz = Class.forName(&#34;java.lang.String&#34;); Field、Method、Constructor：这些类提供了反射操作字段、方法、构造函数的接口。通过这些接口，你可以动态地获取类的成员变量、方法信息，甚至修改它们的值。
3.反射的应用场景 3.1 框架和库开发 许多Java框架（如Spring、Hibernate）都依赖反射机制来实现动态注入、配置和对象创建。反射让框架能够在运行时发现并操作类，而不需要提前在源代码中硬编码。 依赖注入（Dependency Injection）：Spring框架通过反射来扫描类和字段，自动将依赖的对象注入到目标类中。 AOP（面向切面编程）：Spring AOP使用反射来动态地创建代理对象，并在方法调用前后插入切面逻辑。 3.2 动态代理 反射常用于实现动态代理。动态代理允许你在运行时动态生成一个实现了指定接口的类，并在调用方法时插入自定义逻辑。
例如，Java的Proxy类配合反射可以创建一个代理对象，代理对象会将方法调用转发给一个处理器。
MyInterface proxy = (MyInterface) Proxy.newProxyInstance( MyInterface.class.getClassLoader(), new Class[]{MyInterface.class}, new MyInvocationHandler()); 3.3 插件系统和模块化应用 在一些需要插件化或者模块化的系统中，反射非常有用。通过反射，程序可以在运行时动态加载并使用外部插件或模块，而无需提前知道它们的具体实现。
比如，一个插件系统可能在启动时扫描特定的插件目录，通过反射加载插件类并执行它们。
3.4 JDBC数据库操作 **JDBC（Java数据库连接）**使用反射来动态加载数据库驱动类。例如，Class.forName(&#34;com.mysql.cj.jdbc.Driver&#34;)通过反射加载数据库驱动类，并注册它，使得数据库操作可以在运行时进行。 3.5 单元测试和框架调试 在单元测试中，反射用于访问和测试私有方法或字段，这对于测试框架尤其重要。比如，JUnit在进行测试时，可能需要通过反射来调用私有方法或检查私有字段的值。 4.反射的优缺点 4.1 优点 灵活性：反射可以让程序在运行时决定要执行哪些操作，这使得程序具有高度的灵活性。 解耦：通过反射，框架可以在运行时动态地发现和调用类的方法，而不需要在编译时明确指定，从而提高了系统的解耦性。 动态性：反射支持在运行时加载类、创建对象、调用方法，这使得程序能够更适应变化的需求。 4.2 缺点 性能开销：反射是基于动态查找和解析的，因此它比直接调用方法或访问字段要慢一些。过度使用反射可能会导致性能问题。 类型安全问题：反射是动态操作的，编译时无法检查代码的正确性，容易引发类型转换等错误。使用反射时需要特别小心。 代码可读性差：反射使得代码的执行过程变得不透明，难以理解和调试。反射的代码通常不如直接调用的代码直观。 5.反射的常见操作 加载类 Class&lt;?&gt; clazz = Class.forName(&#34;com.example.MyClass&#34;); 获取类的构造方法 Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class); Object obj = constructor.newInstance(&#34;John&#34;, 30); 获取类的方法 Method method = clazz.getDeclaredMethod(&#34;sayHello&#34;); method.setAccessible(true); // 如果方法是私有的 method.invoke(obj); 获取类的字段 Field field = clazz.getDeclaredField(&#34;name&#34;); field.setAccessible(true); // 如果字段是私有的 String name = (String) field.get(obj); </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Java的反射机制" href="http://localhost:1313/notes/2024-11-27-java_reflection/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux常用命令
    </h2>
  </header>
  <div class="entry-content">
    <p>1.文件与目录操作 命令 作用 使用场景 ls -lh 显示目录文件列表 查看文件大小、权限、修改时间等 cd 切换目录 进入代码目录、日志目录等 pwd 显示当前路径 确认当前工作目录 mkdir -p dir 创建目录 创建不存在的目录（含父级） rm -rf file 删除文件/目录 清理临时文件，删除无用日志 cp -r src dest 复制文件/目录 备份代码、配置文件等 mv src dest 移动/重命名文件 重命名日志、移动文件到目标目录 find /path -name &#34;*.log&#34; 查找文件 定位日志文件、查找大文件 du -sh file 查看文件大小 确定哪些文件占用空间过大 df -h 查看磁盘使用情况 确保服务器磁盘空间足够 2.进程管理 命令 作用 使用场景 ps aux 查看所有进程 查找某个进程的 PID top / htop 实时查看 CPU/内存使用 排查服务器性能问题 kill -9 PID 强制结束进程 终止卡死的程序 pkill -f process_name 根据名称杀进程 结束 Web 服务器进程 nohup command &amp; 后台运行进程 运行服务后保持终端关闭 jobs / fg / bg 管理后台进程 让任务在后台执行 3.网络调试 命令 作用 使用场景 ifconfig / ip a 查看 IP 地址 确认服务器 IP ping google.com 测试网络连通性 检查网络是否可用 curl -I http://example.com 发送 HTTP 请求 检测 API 是否正常 wget url 下载文件 获取远程资源 netstat -tulnp / ss -tulnp 查看监听端口 确保服务正确运行 telnet IP PORT 测试端口连通性 确认服务是否开放端口 scp file user@remote:/path 远程传输文件 部署代码到远程服务器 rsync -avz src dest 高效同步文件 备份数据，服务器同步代码 4.日志管理 命令 作用 使用场景 cat file.log 显示完整日志 查看小型日志文件 less file.log 分页查看 适用于大日志文件 tail -f file.log 实时查看日志 监控应用运行状态 grep &#34;error&#34; file.log 过滤关键字 查找日志错误信息 awk &#39;{print $1}&#39; file.log 处理文本 提取指定字段 sed -i &#39;s/old/new/g&#39; file.log 替换文本 修改日志或配置文件 </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to Linux常用命令" href="http://localhost:1313/notes/2025-3-10-common_linux_commands/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/notes/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
