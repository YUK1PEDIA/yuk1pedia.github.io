<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Algorithms | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Algorithms - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/algorithm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/algorithm/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/algorithm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Algorithms
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分治——归并排序与二分查找
    </h2>
  </header>
  <div class="entry-content">
    <p>交易逆序对的总数 在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。
示例 1:
输入：record = [9, 7, 5, 4, 6]输出：8解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。 限制：
0 &lt;= record.length &lt;= 50000 Code
class Solution { public: int mergeSort(vector&lt;int&gt;&amp; record, vector&lt;int&gt;&amp; tmp, int l, int r) { if (l &gt;= r) return 0; int mid = (l &#43; r) / 2; int inv_cnt = mergeSort(record, tmp, l, mid) &#43; mergeSort(record, tmp, mid &#43; 1, r); int i = l, j = mid &#43; 1, pos = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (record[i] &lt;= record[j]) { tmp[pos] = record[i]; &#43;&#43;i; inv_cnt &#43;= (j - (mid &#43; 1)); } else { tmp[pos] = record[j]; &#43;&#43;j; } &#43;&#43;pos; } for (int k = i; k &lt;= mid; &#43;&#43;k) { // 右边已经没有比左边当前数更大的了，直接加上 (j - (mid &#43; 1)) tmp[pos&#43;&#43;] = record[k]; inv_cnt &#43;= (j - (mid &#43; 1)); } for (int k = j; k &lt;= r; &#43;&#43;k) { tmp[pos&#43;&#43;] = record[k]; } copy(tmp.begin() &#43; l, tmp.begin() &#43; r &#43; 1, record.begin() &#43; l); return inv_cnt; } int reversePairs(vector&lt;int&gt;&amp; record) { int n = record.size(); vector&lt;int&gt; tmp(n); return mergeSort(record, tmp, 0, n - 1); } }; 二分查找（闭区间写法） int lower_bound(vector&lt;int&gt; &amp;nums, int target) { int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right] while (left &lt;= right) { // 区间不为空 // 循环不变量： // nums[left-1] &lt; target // nums[right&#43;1] &gt;= target // mid 也可以写成：int mid = ((right - left) &gt;&gt; 1) &#43; left; int mid = left &#43; (right - left) / 2; if (nums[mid] &lt; target) { left = mid &#43; 1; // 范围缩小到 [mid&#43;1, right] } else { right = mid - 1; // 范围缩小到 [left, mid-1] } } return left; } 如果要查找的数字不在数组中，上述写法会返回该数组中第一个大于 target 的数的下标。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分治——归并排序与二分查找" href="http://localhost:1313/algorithm/2024-9-20-divide_and_conquermerge_sorting_and_binary_search/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">前缀和与差分数组
    </h2>
  </header>
  <div class="entry-content">
    <p>前缀和 区域和检索 - 数组不可变
给定一个整数数组 nums，处理以下类型的多个查询:
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right 实现 NumArray 类：
NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] &#43; nums[left &#43; 1] &#43; ... &#43; nums[right] ) 示例 1：
输入：[&#34;NumArray&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) &#43; 0 &#43; 3)numArray.sumRange(2, 5); // return -1 (3 &#43; (-5) &#43; 2 &#43; (-1)) numArray.sumRange(0, 5); // return -3 ((-2) &#43; 0 &#43; 3 &#43; (-5) &#43; 2 &#43; (-1)) 提示：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 前缀和与差分数组" href="http://localhost:1313/algorithm/2024-9-13-prefix_sum/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">动态规划-买卖股票问题
    </h2>
  </header>
  <div class="entry-content">
    <p>买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^4 思路 两个思路，可以用 dp 也可以用贪心。
dp 做法 定义状态： dp[i][0] 表示第 i 天持有股票的最大利润，dp[i][1] 表示第 i 天不持有股票的最大利润（注意此处持有表示拥有股票，并不一定指当天买入股票） 状态转移 如果当天持有股票，就有两种情况： 前一天就持有了股票，直接由前一天转移过来：dp[i][0] = dp[i-1][0] 前一天并不持有股票，我们需要在当天购买股票：dp[i][0] = -prices[i] （因为只能买卖一次股票，买入股票就一定是 -prices[i] 的利润） 在以上两种情况取最大值即可： dp[i][0] = max(dp[i-1][0], -prices[i]); 如果当天不持有股票，也有两种情况： 前一天就不持有股票：dp[i][1] = dp[i-1][1] 前一天持有股票，这一天卖出：dp[i][1] = dp[i-1][0] &#43; prices[i] 两种情况取最大：dp[i][1] = max(dp[i-1][1], dp[i-1][0]&#43;prices[i]); 边界定义 初始化第 0 天即可 代码如下：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 动态规划-买卖股票问题" href="http://localhost:1313/algorithm/2024-8-9-stock_trading_problem/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">单调栈
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是单调栈？ 单调栈是一种特殊的栈，在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。
单调栈的 push 和 pop 比如我们现在有一组数：[10, 3, 7, 4, 12] ，如何将这组数放到一个单调递增栈中？
我们从左到右遍历数组，根据以下条件判断进行何种操作：
如果栈空或当前遍历到的元素 cur 小于栈顶元素，则入栈； 如果栈非空并且当前遍历到的元素 cur 大于栈顶元素，则将栈中所有比 cur 小的元素出栈，再将 cur 入栈。 对于上述数组，通过单调栈有如下操作：
对于 10 ，当前栈空，直接入栈，此时栈顶到栈底：[10]； 对于 3 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[3, 10]； 对于 7 ，当前栈非空，且当前元素大于栈顶元素，先将栈顶元素 3 出栈，再将 7 入栈，此时栈顶到栈底：[7, 10]； 对于 4 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[4, 7, 10]； 对于 12 ，当前栈非空，且当前元素大于栈顶元素，先将 4、7、10 出栈，再将 12 入栈，此时栈顶到栈底：[12]； 单调栈能解决什么问题？ 当我们遇到：需要在 O(n) 的时间复杂度内求出数组中各个元素右侧或左侧第一个更大或更小的元素及其下标，然后一并得到其他信息时，均可以尝试单调栈的做法
例题 87.每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 单调栈" href="http://localhost:1313/algorithm/2024-8-9-monotonic_stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图论
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 整理自：https://algo.itcharge.cn/和代码随想录：https://www.programmercarl.com/qita/tulunfabu.html
1.图的基础知识 (1).图的定义 图（Graph）：由顶点的非空有限集合 V （由 n&gt;0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)。
顶点（Vertex）：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。 边（Edge）：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=&lt;u,v&gt;，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。 子图（Sub Graph）：对于图 G*=(V,E) 与 G*′=(V′,E′)，如果存在 V*′⊆V，E′⊆E，则称图 ′G′ 是图 G* 的一个子图。在下面的示意图中我们给出了一个图 G 及其一个子图 G。特别的，根据定义，G 也是其自身的子图。 (2).图的分类 2.1无向图和有向图 按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。
无向图（Undirected Graph）：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。 有向图（Directed Graph）：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。 如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2 条边。而具有 n×(n−1)/2 条边的无向图称为 「完全无向图（Completed Undirected Graph）」。
如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 「完全有向图（Completed Directed Graph）」。
2.2环形图和无环图 路径：简单来说，如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。 环（Circle）：如果一条路径的起始点和终止点相同（即 vi0*==vi*m ），则称这条路径为「回路」或者「环」。 简单路径：顶点序列中顶点不重复出现的路径称为「简单路径」。 而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 图论" href="http://localhost:1313/algorithm/2024-10-28-graph_theory/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">完全背包与多重背包
    </h2>
  </header>
  <div class="entry-content">
    <p>1.什么是完全背包？ 有 N 件物品和一个最多能背重量为 W 的背包，第 i 件物品的重量是 weight[i] ，得到的价值是 value[i] 。每件物品都有无限个（可以放入背包多次），求解将哪些物品装入背包里价值总和最大，最大价值是多少。
2.和01背包的区别在哪里 01背包和完全背包唯一的不同就是在遍历顺序上，我们先看01背包的核心代码：
for (int i = 0; i &lt; weight.size(); &#43;&#43;i) { // 遍历物品 for (int j = bagWeight; j &gt;= weight[i]; --j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] &#43; value[i]); } } 可以看出，01背包内嵌的循环是从大到小遍历的，这样能保证每件物品仅被添加一次
而完全背包的物品是可以添加多次的，所以需要从小到大去遍历：
for (int i = 0; i &lt; weight.size(); &#43;&#43;i) { // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; &#43;&#43;j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] &#43; value[i]); } } 3.完全背包中的组合数和排列数 对于完全背包问题，有一个很重要的问题：**为什么遍历物品在外层，遍历背包容量在内层？**在01背包问题中，二维数组先遍历物品还是先遍历背包容量是无所谓的（一维数组必须先遍历物品，再遍历容量），可以颠倒。
在纯完全背包问题中，对于一维 dp 数组而言，两个 for 循环的嵌套顺序其实也是无所谓的，因为 dp[j] 是根据下标 j 之前所对应的 dp[j] 计算出来的，只要保证下标 j 之前的 dp[j] 都是经过计算的即可。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 完全背包与多重背包" href="http://localhost:1313/algorithm/2024-7-27-complete_knapsack_problem_and_multiple_knapsack_problem/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">快速幂
    </h2>
  </header>
  <div class="entry-content">
    <p>
算法流程如下
代码实现时，注意 n=−2^31 的情况，取反后 n=2^31 超出 int 最大值。可以转成 64 位 int 解决。
class Solution { public: double myPow(double x, int N) { double ans = 1; long long n = N; if (n &lt; 0) { // x^-n = (1/x)^n n = -n; x = 1 / x; } while (n) { // 从低到高枚举 n 的每个比特位 if (n &amp; 1) { // 当前比特位是 1 ans *= x; // 把 x 乘到 ans 中 } x *= x; // x 自身平方 n &gt;&gt;= 1; // n 右移，继续枚举下一个比特位 } return ans; } }; </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 快速幂" href="http://localhost:1313/algorithm/2024-8-19-fast_exponentiation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">数位dp通用模板
    </h2>
  </header>
  <div class="entry-content">
    <p>数位动态规划（数位dp）主要用于解决“在区间 [l, r] 这个范围内，满足某种约束的数字的数量、总和、平方”这一类问题
前置知识：位运算与集合论 集合可以用二进制表示，二进制从低到高，第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0, 2, 3} 对应的二进制数为 1101 。
设集合对应的二进制数为 x ：
判断元素 d 是否在集合中：x &gt;&gt; d &amp; 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 &lt;&lt; d) 。 下面用一道题来介绍数位 dp 的通用模板
统计特殊整数 如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。
给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。
示例 1：
输入：n = 20输出：19解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。 示例 2：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 数位dp通用模板" href="http://localhost:1313/algorithm/2024-9-20-shuwei_dp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">最大子数组和
    </h2>
  </header>
  <div class="entry-content">
    <p>对于最大子数组和的动态规划问题，一般这样思考：
定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i] = a[i] ，和 i 左边拼起来就是 f[i] = f[i-1] &#43; a[i] ，取最大值就得到了状态转移方程 f[i] = max(f[i-1], 0) &#43; a[i] ，答案为 max(f) 。这种做法也称为 Kadane 算法。
1.最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组
是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1]输出：1 示例 3：
输入：nums = [5,4,-1,7,8]输出：23 提示：
1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 思路 按照前面说的进行状态转移即可
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 最大子数组和" href="http://localhost:1313/algorithm/2024-8-22-maximum_subarray_sum/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/algorithm/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
