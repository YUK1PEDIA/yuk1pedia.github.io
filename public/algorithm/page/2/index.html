<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Algorithms | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Algorithms - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/algorithm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/algorithm/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/algorithm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Algorithms
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">STL容器——string成员函数
    </h2>
  </header>
  <div class="entry-content">
    <p>转载，原文链接：https://www.cnblogs.com/lynx-peng/p/16552710.html
1.构造与析构 构造
string()//构造空字符串 string(const char* s);//拷贝s所指向的字符串序列 string(const char* s, size_t n);//拷贝s所指向的字符串序列的第n个到结尾的字符 string(size_t n, char c);//将字符c复制n次 string(const string&amp; str);//拷贝构造函数 string(const string&amp; str, size_t pos, size_t len = npos);//拷贝s中从pos位置起的len个字符，若npos&gt;字符串长度，就拷贝到字符串结尾结束 析构
~string();//删除字符串 2.迭代器 /*迭代器*/ iterator begin(); //返回指向字符串第一个字符的迭代器 iterator end(); //返回指向字符串最后一个字符的下一个位置的迭代器 reverse_iterator rbegin(); //返回字符串最后一个字符的反向迭代器 reverse_iterator rend(); //返回指向字符串第一个字符之前的反向迭代器 /*常量迭代器*/ iterator cbegin(); //返回指向字符串第一个字符的迭代器 iterator cend(); //返回指向字符串最后一个字符的下一个位置的迭代器 reverse_iterator rcbegin(); //返回字符串最后一个字符的反向迭代器 reverse_iterator rcend(); //返回指向字符串第一个字符之前的反向迭代器 注：迭代器（非常量迭代器）和常量迭代器的区别如下：
非常量迭代器允许修改迭代器所指向的元素，这类迭代器通常用于需要修改容器中元素的情况 常量迭代器不允许修改迭代器所指向的元素，这类迭代器通常用于只需要读取容器中元素的情况 3.访问 reference at(size_type pos);//同char&amp; operator[]，返回pos位置字符的引用，字符串可读可写 char&amp; back();//返回最后字符的引用 char&amp; front();//返回第一个字符的引用 4.长度及容量 size_t size();//返回字符串字符个数 size_t length();//返回字符串字符个数 size_t max_size();//返回string对象中可存放的最大字符串的长度 size_t capacity();//返回string分配的存储容量。 void resize (size_t n);//调整源字符串的长度为n。 void resize (size_t n, char c);//调整字符串长度为n，并用字符c填充不足的部分 void reserve (size_t n = 0);//重新给源字符串分配存储最小为n的容量 void shrink_to_fit()//清理内存，使字符串的容量变得等于字符串的大小 void clear();//将字符串的内容清空，让源字符串成为一个空字符串（长度为0个字符） bool empty();//判断字符串是否为空 5.修饰 5.1.append() 在结尾添加字符串 string &amp; append(const string &amp; str)//在结尾添加一个string字符串 string &amp; append(const string &amp; str, size_type subpos, size_type sublen)//追加str中从subpos开始的sublen个字符(子串) string &amp; append(const charT * s)//C语言字符串 string &amp; append(const charT * s, size_type n)//C语言字符串(长度为n的子串) string &amp; append(size_type n, charT c)//n个字符c string &amp; append(InputIterator first, InputIterator last)//使用迭代器append 5.2.push_back() 将字符串添加到串尾 void push_back (charT c);//将字符C添加到结尾 5.3.assign() 赋值 string &amp;assign(const char *s);///char*类型的字符串赋给当前字符串 string &amp;assign(const char *s,int n);//从给定的 C 风格字符串 s 的前 n 个字符创建一个新的字符串，并将当前字符串设置为这个新字符串的内容 string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串 string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串 string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串 string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串 5.4.insert() 在串中间插入 string &amp; insert(size_type pos, const string &amp; str)//在pos位置插入字符串str string &amp; insert(size_type pos, const string &amp; str,size_type subpos, size_type sublen)//从subpos开始的sublen的子串 string &amp; insert(size_type pos, const charT * s)//C语言字符串 string &amp; insert(size_type pos, const charT * s, size_type n)//C语言字符串(长度为n的子串) string &amp; insert(size_type pos, size_type n, charT c)//n个字符c iterator insert(const_iterator p, size_type n, charT c)//使用迭代器索引插入n和字符 iterator insert(const_iterator p, charT c)//单一字符 iterator insert(iterator p, InputIterator first, InputIterator last)//使用迭代器insert 5.5.erase() 删除字符串中的特定字符 string &amp; erase(size_type pos=0, size_type len=npos)//从pos处删除len长度的字符 iterator erase(const_iterator p)//删除迭代器所指的单一字符 iterator erase(const_iterator first, const_iterator last)//删除2迭代器中间的字符 5.6.replace() 替换字符串的一部分 string &amp; replace(size_type pos,size_type len,const string &amp; str)//从pos位置开始，长度为len的字符替换为str string &amp; replace(const_iterator i1, const_iterator i2, const string &amp; str)//替换两迭代器之间的字符 string &amp; replace(size_type pos, size_type len, const string &amp; str,size_type subpos, size_type sublen)//使用子串替换 string &amp; replace(size_type pos, size_type len, const charT * s)//使用C语言字符串 string &amp; replace(const_iterator i1, const_iterator i2, const charT * s)//迭代器方法 string &amp; replace(size_type pos, size_type len, const charT * s, size_type n)//使用子串 string &amp; replace(const_iterator i1, const_iterator i2, const charT * s, size_type n)//迭代器方法 string &amp; replace(size_type pos, size_type len, size_type n, charT c)//用n个字符c替换 string &amp; replace(const_iterator i1, const_iterator i2, size_type n, charT c)//迭代器方法 string &amp; replace(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last)//迭代器方法 5.7.swap() 交换两字符串 void swap (&amp; str);//交换self和str 5.8.pop_back() 删除最后一个字符 void pop_back();//删除串中最后一个字符 6.操作 6.1.find() 查找 size_type find(const string &amp; str, size_type pos=0) const;//从母字符串的pos位置查找字串str.存在返回字串第一个字符的位置，不存在返回npos size_type find(const charT * s, size_type pos=0) const;//C语言字符串作为子串 size_type find(const charT * s, size_type pos, size_type n) const;//C语言字符串的子串(长度为n)作为被查找子串 size_type find(charT c, size_type pos=0) const;//查找单个字符 //倒着找 size_type rfind(const string &amp; str, size_type pos=npos) const; size_type rfind(const charT * s, size_type pos=npos); size_type rfind(const charT * s, size_type pos, size_type n); size_type rfind(charT c, size_type pos=npos) const; //查找字符串中与目标字符(串中任一个字符)相同的第一个字符 size_type find_first_of(const string &amp; str, size_type pos=0) const; size_type find_first_of(const charT * s, size_type pos=0) const; size_type find_first_of(const charT * s, size_type pos, size_type n); size_type find_first_of(charT c, size_type pos=0) const; //倒着找 or 找最后一个 size_type find_last_of(const string &amp; str, size_type pos=npos) const size_type find_last_of(const charT * s, size_type pos=npos) const size_type find_last_of(const charT * s, size_type pos, size_type n) const size_type find_last_of(charT c, size_type pos=npos) const //查找字符串中与目标字符(串中任一个字符)不相同的第一个字符 size_type find_first_not_of(const string &amp; str, size_type pos=0) const; size_type find_first_not_of(const charT * s, size_type pos=0) const; size_type find_first_not_of(const charT * s, size_type pos, size_type n) const; size_type find_first_not_of(charT c, size_type pos=0) const; //倒着找 or 找最后一个 size_type find_last_not_of(const string &amp; str, size_type pos=npos) const ; size_type find_last_not_of(const charT * s, size_type pos=npos) const; size_type find_last_not_of(const charT * s, size_type pos, size_type n) const; size_type find_last_not_of(charT c, size_type pos=npos) const ; 6.2.substr() 子串 string substr (size_type pos = 0, size_type len = npos) const;//返回一个从pos开始，len长度的string类型的子串 6.3.compare() 比较 int compare (const string&amp; str) const ;//比较字符串大小，源串大于str返回值&gt;0，相同=0,小于&lt;0 int compare (size_type pos, size_type len, const string&amp; str) const;//用自身的子串比较 int compare (size_type pos, size_type len, const string&amp; str, size_type subpos, size_type sublen) const;//两字符串均为子串 int compare (const charT* s) const;//C语言字符串 int compare (size_type pos, size_type len, const charT* s) const;//C语言字符串子串 int compare (size_type pos, size_type len, const charT* s, size_type n) const;//双子串 6.4.copy() 复制到字符数组 size_type copy (charT* s, size_type len, size_type pos = 0) const;//从string类型对象中至多复制n个字符到字符指针p指向的空间中。不添加&#39;\0&#39; 7.符号重载 7.1.= 赋值 string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串 string &amp;operator=(const char* s);//char*类型的字符串赋给当前字符串 string &amp;operator=(char c);//单个字符赋给当前字符串 7.2.[] 访问 char&amp; operator[] (size_t pos);//返回pos处字符的引用 越界导致未定义行为 7.3.&#43;= 追加 string&amp; operator&#43;= (const string&amp; str);//在结尾加如str字符串，等效于append string&amp; operator&#43;= (const char* s);//C语言字符串 string&amp; operator&#43;= (char c);//单个字符 8.补充：cctype 字符处理库 C&#43;&#43;从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型在头文件cctype中定义，使用 #include &lt;cctype&gt; 引入
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to STL容器——string成员函数" href="http://localhost:1313/algorithm/2024-9-5-stl-container----string-member-function/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分治——归并排序与二分查找
    </h2>
  </header>
  <div class="entry-content">
    <p>交易逆序对的总数 在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。
示例 1:
输入：record = [9, 7, 5, 4, 6]输出：8解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。 限制：
0 &lt;= record.length &lt;= 50000 Code
class Solution { public: int mergeSort(vector&lt;int&gt;&amp; record, vector&lt;int&gt;&amp; tmp, int l, int r) { if (l &gt;= r) return 0; int mid = (l &#43; r) / 2; int inv_cnt = mergeSort(record, tmp, l, mid) &#43; mergeSort(record, tmp, mid &#43; 1, r); int i = l, j = mid &#43; 1, pos = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (record[i] &lt;= record[j]) { tmp[pos] = record[i]; &#43;&#43;i; inv_cnt &#43;= (j - (mid &#43; 1)); } else { tmp[pos] = record[j]; &#43;&#43;j; } &#43;&#43;pos; } for (int k = i; k &lt;= mid; &#43;&#43;k) { // 右边已经没有比左边当前数更大的了，直接加上 (j - (mid &#43; 1)) tmp[pos&#43;&#43;] = record[k]; inv_cnt &#43;= (j - (mid &#43; 1)); } for (int k = j; k &lt;= r; &#43;&#43;k) { tmp[pos&#43;&#43;] = record[k]; } copy(tmp.begin() &#43; l, tmp.begin() &#43; r &#43; 1, record.begin() &#43; l); return inv_cnt; } int reversePairs(vector&lt;int&gt;&amp; record) { int n = record.size(); vector&lt;int&gt; tmp(n); return mergeSort(record, tmp, 0, n - 1); } }; 二分查找（闭区间写法） int lower_bound(vector&lt;int&gt; &amp;nums, int target) { int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right] while (left &lt;= right) { // 区间不为空 // 循环不变量： // nums[left-1] &lt; target // nums[right&#43;1] &gt;= target // mid 也可以写成：int mid = ((right - left) &gt;&gt; 1) &#43; left; int mid = left &#43; (right - left) / 2; if (nums[mid] &lt; target) { left = mid &#43; 1; // 范围缩小到 [mid&#43;1, right] } else { right = mid - 1; // 范围缩小到 [left, mid-1] } } return left; } 如果要查找的数字不在数组中，上述写法会返回该数组中第一个大于 target 的数的下标。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 分治——归并排序与二分查找" href="http://localhost:1313/algorithm/2024-9-20-divide_and_conquermerge_sorting_and_binary_search/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">前缀和与差分数组
    </h2>
  </header>
  <div class="entry-content">
    <p>前缀和 区域和检索 - 数组不可变
给定一个整数数组 nums，处理以下类型的多个查询:
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right 实现 NumArray 类：
NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] &#43; nums[left &#43; 1] &#43; ... &#43; nums[right] ) 示例 1：
输入：[&#34;NumArray&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;, &#34;sumRange&#34;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) &#43; 0 &#43; 3)numArray.sumRange(2, 5); // return -1 (3 &#43; (-5) &#43; 2 &#43; (-1)) numArray.sumRange(0, 5); // return -3 ((-2) &#43; 0 &#43; 3 &#43; (-5) &#43; 2 &#43; (-1)) 提示：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 前缀和与差分数组" href="http://localhost:1313/algorithm/2024-9-13-prefix_sum/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">动态规划-买卖股票问题
    </h2>
  </header>
  <div class="entry-content">
    <p>买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
示例 1：
输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：
输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：
1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^4 思路 两个思路，可以用 dp 也可以用贪心。
dp 做法 定义状态： dp[i][0] 表示第 i 天持有股票的最大利润，dp[i][1] 表示第 i 天不持有股票的最大利润（注意此处持有表示拥有股票，并不一定指当天买入股票） 状态转移 如果当天持有股票，就有两种情况： 前一天就持有了股票，直接由前一天转移过来：dp[i][0] = dp[i-1][0] 前一天并不持有股票，我们需要在当天购买股票：dp[i][0] = -prices[i] （因为只能买卖一次股票，买入股票就一定是 -prices[i] 的利润） 在以上两种情况取最大值即可： dp[i][0] = max(dp[i-1][0], -prices[i]); 如果当天不持有股票，也有两种情况： 前一天就不持有股票：dp[i][1] = dp[i-1][1] 前一天持有股票，这一天卖出：dp[i][1] = dp[i-1][0] &#43; prices[i] 两种情况取最大：dp[i][1] = max(dp[i-1][1], dp[i-1][0]&#43;prices[i]); 边界定义 初始化第 0 天即可 代码如下：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 动态规划-买卖股票问题" href="http://localhost:1313/algorithm/2024-8-9-stock_trading_problem/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">单调栈
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是单调栈？ 单调栈是一种特殊的栈，在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。
单调栈的 push 和 pop 比如我们现在有一组数：[10, 3, 7, 4, 12] ，如何将这组数放到一个单调递增栈中？
我们从左到右遍历数组，根据以下条件判断进行何种操作：
如果栈空或当前遍历到的元素 cur 小于栈顶元素，则入栈； 如果栈非空并且当前遍历到的元素 cur 大于栈顶元素，则将栈中所有比 cur 小的元素出栈，再将 cur 入栈。 对于上述数组，通过单调栈有如下操作：
对于 10 ，当前栈空，直接入栈，此时栈顶到栈底：[10]； 对于 3 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[3, 10]； 对于 7 ，当前栈非空，且当前元素大于栈顶元素，先将栈顶元素 3 出栈，再将 7 入栈，此时栈顶到栈底：[7, 10]； 对于 4 ，当前栈非空，且当前元素小于栈顶元素，直接入栈，此时栈顶到栈底：[4, 7, 10]； 对于 12 ，当前栈非空，且当前元素大于栈顶元素，先将 4、7、10 出栈，再将 12 入栈，此时栈顶到栈底：[12]； 单调栈能解决什么问题？ 当我们遇到：需要在 O(n) 的时间复杂度内求出数组中各个元素右侧或左侧第一个更大或更小的元素及其下标，然后一并得到其他信息时，均可以尝试单调栈的做法
例题 87.每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 单调栈" href="http://localhost:1313/algorithm/2024-8-9-monotonic_stack/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图论
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 整理自：https://algo.itcharge.cn/和代码随想录：https://www.programmercarl.com/qita/tulunfabu.html
1.图的基础知识 (1).图的定义 图（Graph）：由顶点的非空有限集合 V （由 n&gt;0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)。
顶点（Vertex）：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。 边（Edge）：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=&lt;u,v&gt;，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。 子图（Sub Graph）：对于图 G*=(V,E) 与 G*′=(V′,E′)，如果存在 V*′⊆V，E′⊆E，则称图 ′G′ 是图 G* 的一个子图。在下面的示意图中我们给出了一个图 G 及其一个子图 G。特别的，根据定义，G 也是其自身的子图。 (2).图的分类 2.1无向图和有向图 按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。
无向图（Undirected Graph）：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。 有向图（Directed Graph）：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。 如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2 条边。而具有 n×(n−1)/2 条边的无向图称为 「完全无向图（Completed Undirected Graph）」。
如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 「完全有向图（Completed Directed Graph）」。
2.2环形图和无环图 路径：简单来说，如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。 环（Circle）：如果一条路径的起始点和终止点相同（即 vi0*==vi*m ），则称这条路径为「回路」或者「环」。 简单路径：顶点序列中顶点不重复出现的路径称为「简单路径」。 而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 图论" href="http://localhost:1313/algorithm/2024-10-28-graph_theory/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">完全背包与多重背包
    </h2>
  </header>
  <div class="entry-content">
    <p>1.什么是完全背包？ 有 N 件物品和一个最多能背重量为 W 的背包，第 i 件物品的重量是 weight[i] ，得到的价值是 value[i] 。每件物品都有无限个（可以放入背包多次），求解将哪些物品装入背包里价值总和最大，最大价值是多少。
2.和01背包的区别在哪里 01背包和完全背包唯一的不同就是在遍历顺序上，我们先看01背包的核心代码：
for (int i = 0; i &lt; weight.size(); &#43;&#43;i) { // 遍历物品 for (int j = bagWeight; j &gt;= weight[i]; --j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] &#43; value[i]); } } 可以看出，01背包内嵌的循环是从大到小遍历的，这样能保证每件物品仅被添加一次
而完全背包的物品是可以添加多次的，所以需要从小到大去遍历：
for (int i = 0; i &lt; weight.size(); &#43;&#43;i) { // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; &#43;&#43;j) { // 遍历背包容量 dp[j] = max(dp[j], dp[j-weight[i]] &#43; value[i]); } } 3.完全背包中的组合数和排列数 对于完全背包问题，有一个很重要的问题：**为什么遍历物品在外层，遍历背包容量在内层？**在01背包问题中，二维数组先遍历物品还是先遍历背包容量是无所谓的（一维数组必须先遍历物品，再遍历容量），可以颠倒。
在纯完全背包问题中，对于一维 dp 数组而言，两个 for 循环的嵌套顺序其实也是无所谓的，因为 dp[j] 是根据下标 j 之前所对应的 dp[j] 计算出来的，只要保证下标 j 之前的 dp[j] 都是经过计算的即可。
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 完全背包与多重背包" href="http://localhost:1313/algorithm/2024-7-27-complete_knapsack_problem_and_multiple_knapsack_problem/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">快速幂
    </h2>
  </header>
  <div class="entry-content">
    <p>
算法流程如下
代码实现时，注意 n=−2^31 的情况，取反后 n=2^31 超出 int 最大值。可以转成 64 位 int 解决。
class Solution { public: double myPow(double x, int N) { double ans = 1; long long n = N; if (n &lt; 0) { // x^-n = (1/x)^n n = -n; x = 1 / x; } while (n) { // 从低到高枚举 n 的每个比特位 if (n &amp; 1) { // 当前比特位是 1 ans *= x; // 把 x 乘到 ans 中 } x *= x; // x 自身平方 n &gt;&gt;= 1; // n 右移，继续枚举下一个比特位 } return ans; } }; </p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 快速幂" href="http://localhost:1313/algorithm/2024-8-19-fast_exponentiation/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">数位dp通用模板
    </h2>
  </header>
  <div class="entry-content">
    <p>数位动态规划（数位dp）主要用于解决“在区间 [l, r] 这个范围内，满足某种约束的数字的数量、总和、平方”这一类问题
前置知识：位运算与集合论 集合可以用二进制表示，二进制从低到高，第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0, 2, 3} 对应的二进制数为 1101 。
设集合对应的二进制数为 x ：
判断元素 d 是否在集合中：x &gt;&gt; d &amp; 1 可以取出 x 的第 d 个比特位，如果是 1 就说明 d 在集合中。 把元素 d 添加到集合中：将 x 更新为 x | (1 &lt;&lt; d) 。 下面用一道题来介绍数位 dp 的通用模板
统计特殊整数 如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。
给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。
示例 1：
输入：n = 20输出：19解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。 示例 2：
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 数位dp通用模板" href="http://localhost:1313/algorithm/2024-9-20-shuwei_dp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">最大子数组和
    </h2>
  </header>
  <div class="entry-content">
    <p>对于最大子数组和的动态规划问题，一般这样思考：
定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是 f[i] = a[i] ，和 i 左边拼起来就是 f[i] = f[i-1] &#43; a[i] ，取最大值就得到了状态转移方程 f[i] = max(f[i-1], 0) &#43; a[i] ，答案为 max(f) 。这种做法也称为 Kadane 算法。
1.最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组
是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1]输出：1 示例 3：
输入：nums = [5,4,-1,7,8]输出：23 提示：
1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 思路 按照前面说的进行状态转移即可
...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to 最大子数组和" href="http://localhost:1313/algorithm/2024-8-22-maximum_subarray_sum/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/algorithm/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
