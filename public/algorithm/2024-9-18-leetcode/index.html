<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>leetcode | YUKIPEDIA&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="leetcode - YUKIPEDIA&#39;s blog">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/algorithm/2024-9-18-leetcode/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/algorithm/2024-9-18-leetcode/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="YUKIPEDIA&#39;s blog (Alt + H)">YUKIPEDIA&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About me?">
                    <span>About me?</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      leetcode
    </h1>
    <div class="post-meta"><span title='2024-09-18 00:00:00 +0000 UTC'>September 18, 2024</span>

</div>
  </header> 
  <div class="post-content"><h1 id="1找出最具竞争力的子序列单调栈贪心">1.找出最具竞争力的子序列（单调栈+贪心）<a hidden class="anchor" aria-hidden="true" href="#1找出最具竞争力的子序列单调栈贪心">#</a></h1>
<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的 <code>nums</code> 子序列。</p>
<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>
<p>在子序列 <code>a</code> 和子序列 <code>b</code> 第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code> 中对应的数字，那么我们称子序列 <code>a</code> 比子序列 <code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。 例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code> 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code> 小于 <code>5</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h2 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h2>
<p>根据题意，最具竞争力的子序列<strong>一定是较小的元素尽可能地放到序列的前面</strong>。所以我们可以遍历一遍数组，维持一个单调栈结构，将较小的元素尽可能地往前放。</p>
<p>那么我们应该如何操作？因为我们可以使用单调栈，所以说我们每次将当前元素和栈顶元素比较，如果<strong>当前元素更小</strong>，并且能够保证<strong>栈内元素数目 + 数组中剩余元素 &gt; k且栈非空</strong>，那么我们就弹出栈顶元素，将当前元素压入栈，一直重复，最后返回栈内自下而上的前k各元素为结果即可。</p>
<p>记nums的大小为n，遍历数组nums，假设当前访问的下标为 i ，对数组nums[i]执行以下操作：</p>
<ol>
<li>记栈中元素数目为 m，我们不断地进行操作直到不满足以下条件：如果 m &gt; 0且 m + n - i &gt; k且单调栈的栈顶元素大于nums[i]，说明栈顶元素可以被当前数字nums[i]替换，我们就弹出栈顶元素</li>
<li>将nums[i]压入栈中</li>
<li>最后返回栈自下而上的前 k 个元素作为结果</li>
</ol>
<p>代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mostCompetitive(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size(); <span style="color:#75715e">// 原数组的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>res.empty() <span style="color:#f92672">&amp;&amp;</span> res.size() <span style="color:#f92672">+</span> n <span style="color:#f92672">-</span> i <span style="color:#f92672">&gt;</span> k <span style="color:#f92672">&amp;&amp;</span> res.back() <span style="color:#f92672">&gt;</span> nums[i]) {
</span></span><span style="display:flex;"><span>                res.pop_back();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            res.push_back(nums[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res.resize(k);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="2搜索插入位置二分搜索">2.搜索插入位置（二分搜索）<a hidden class="anchor" aria-hidden="true" href="#2搜索插入位置二分搜索">#</a></h1>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<pre tabindex="0"><code>输入: nums = [1,3,5,6], target = 5
输出: 2
</code></pre><p><strong>示例 2:</strong></p>
<pre tabindex="0"><code>输入: nums = [1,3,5,6], target = 2
输出: 1
</code></pre><p><strong>示例 3:</strong></p>
<pre tabindex="0"><code>输入: nums = [1,3,5,6], target = 7
输出: 4
</code></pre><p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
<h2 id="思路-1">思路<a hidden class="anchor" aria-hidden="true" href="#思路-1">#</a></h2>
<p>不断用二分法逼近查找第一个大于等于target的下标，ans初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是target大于数组中的所有数，此时需要插入到数组长度的位置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> searchInsert(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 防止加法溢出，位运算比除法更快
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> ((right <span style="color:#f92672">-</span> left) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">+</span> left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">&gt;</span> nums[middle]) {
</span></span><span style="display:flex;"><span>                left <span style="color:#f92672">=</span> middle <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (target <span style="color:#f92672">&lt;=</span> nums[middle]) {
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> middle; <span style="color:#75715e">// 将目标数字插到middle的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                right <span style="color:#f92672">=</span> middle <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="3删除并获得点数打家劫舍">3.删除并获得点数（打家劫舍）<a hidden class="anchor" aria-hidden="true" href="#3删除并获得点数打家劫舍">#</a></h1>
<p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>
<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h2 id="思路-2">思路<a hidden class="anchor" aria-hidden="true" href="#思路-2">#</a></h2>
<p>题目中的条件：“<strong>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 所有 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素</strong>”，可以理解为打家劫舍。</p>
<p>记元素<code>x</code>在数组中出现的次数为<code>cx</code>，我们可以用一个数组<code>sum</code>记录数组<code>nums</code>中<strong>所有相同元素之和</strong>，即<code>sum[x] = x * cx</code>。若选择了<code>x</code>，则可以获取<code>sum[x]</code>的点数，且无法再选择<code>x-1</code>和<code>x+1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rob(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>sum) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> sum.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dp[size];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> sum[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(sum[<span style="color:#ae81ff">0</span>], sum[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> size; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> sum[i]);
</span></span><span style="display:flex;"><span>        }    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">deleteAndEarn</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> maxVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> val : nums) maxVal <span style="color:#f92672">=</span> max(maxVal, val);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sum(maxVal <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> val : nums) sum[val] <span style="color:#f92672">+=</span> val;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> rob(sum);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>由于在打家劫舍中，每个变量的状态只与前两个变量的状态有关，所以可以不使用数组，只用两个变量来实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rob(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> first <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>], second <span style="color:#f92672">=</span> max(nums[<span style="color:#ae81ff">0</span>], nums[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> second;
</span></span><span style="display:flex;"><span>            second <span style="color:#f92672">=</span> max(first <span style="color:#f92672">+</span> nums[i], second);
</span></span><span style="display:flex;"><span>            first <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">deleteAndEarn</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> maxVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> val : nums) maxVal <span style="color:#f92672">=</span> max(maxVal, val);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sum(maxVal <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> val : nums) sum[val] <span style="color:#f92672">+=</span> val;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> rob(sum);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="4k-秒后第-n-个元素的值前缀和">4.K 秒后第 N 个元素的值（前缀和）<a hidden class="anchor" aria-hidden="true" href="#4k-秒后第-n-个元素的值前缀和">#</a></h1>
<p>给你两个整数 <code>n</code> 和 <code>k</code>。</p>
<p>最初，你有一个长度为 <code>n</code> 的整数数组 <code>a</code>，对所有 <code>0 &lt;= i &lt;= n - 1</code>，都有 <code>a[i] = 1</code> 。每过一秒，你会同时更新每个元素为其前面所有元素的和加上该元素本身。例如，一秒后，<code>a[0]</code> 保持不变，<code>a[1]</code> 变为 <code>a[0] + a[1]</code>，<code>a[2]</code> 变为 <code>a[0] + a[1] + a[2]</code>，以此类推。</p>
<p>返回 <code>k</code> 秒后 <code>a[n - 1]</code> 的<strong>值</strong>。</p>
<p>由于答案可能非常大，返回其对 <code>109 + 7</code> <strong>取余</strong> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**n = 4, k = 5</p>
<p>**输出：**56</p>
<p><strong>解释：</strong></p>
<table>
  <thead>
      <tr>
          <th>时间（秒）</th>
          <th>数组状态</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>[1,1,1,1]</td>
      </tr>
      <tr>
          <td>1</td>
          <td>[1,2,3,4]</td>
      </tr>
      <tr>
          <td>2</td>
          <td>[1,3,6,10]</td>
      </tr>
      <tr>
          <td>3</td>
          <td>[1,4,10,20]</td>
      </tr>
      <tr>
          <td>4</td>
          <td>[1,5,15,35]</td>
      </tr>
      <tr>
          <td>5</td>
          <td>[1,6,21,56]</td>
      </tr>
  </tbody>
</table>
<p><strong>示例 2：</strong></p>
<p>**输入：**n = 5, k = 3</p>
<p>**输出：**35</p>
<p><strong>解释：</strong></p>
<table>
  <thead>
      <tr>
          <th>时间（秒）</th>
          <th>数组状态</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>[1,1,1,1,1]</td>
      </tr>
      <tr>
          <td>1</td>
          <td>[1,2,3,4,5]</td>
      </tr>
      <tr>
          <td>2</td>
          <td>[1,3,6,10,15]</td>
      </tr>
      <tr>
          <td>3</td>
          <td>[1,4,10,20,35]</td>
      </tr>
  </tbody>
</table>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, k &lt;= 1000</code></li>
</ul>
<h2 id="思路-3">思路<a hidden class="anchor" aria-hidden="true" href="#思路-3">#</a></h2>
<p>注意每次计算前缀和后取余，不要最后返回结果的时候取余，不然会爆longlong。还有一点就是不能暴力遍历，会超时，所以需要用dp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> valueAfterKSeconds(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mod <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a[n];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) a[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (k<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> sum[<span style="color:#ae81ff">1005</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                sum[i] <span style="color:#f92672">=</span> sum[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> a[i];
</span></span><span style="display:flex;"><span>                sum[i] <span style="color:#f92672">%=</span> mod;   
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                a[i] <span style="color:#f92672">=</span> sum[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="5救生艇双指针贪心">5.救生艇（双指针+贪心）<a hidden class="anchor" aria-hidden="true" href="#5救生艇双指针贪心">#</a></h1>
<p>给定数组 <code>people</code> 。<code>people[i]</code>表示第 <code>i</code> 个人的体重 ，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为 <code>limit</code>。</p>
<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p>
<p>返回 <em>承载所有人所需的最小船数</em> 。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= people.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10^4</code></li>
</ul>
<h2 id="思路-4">思路<a hidden class="anchor" aria-hidden="true" href="#思路-4">#</a></h2>
<p>本题是较明显的贪心问题。要承载所有人所需的船数尽可能的小，就需要每艘船装的人尽量多。怎么装才能使人尽量多呢？自然而然是<strong>把体重大的和体重小的安排在同一艘船上</strong>。所以贪心选择策略是：<strong>每艘船装当前最大体重和最小体重的人，如果总体重超过<code>limit</code>，则大体重的自己上一艘船，小体重和下一个大体重的匹配</strong>。实现这个策略可以使用<strong>双指针</strong>，在此之前我们需要<code>people</code>数组有序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numRescueBoats(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> people, <span style="color:#66d9ef">int</span> limit) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> people.size();
</span></span><span style="display:flex;"><span>        sort(people.begin(), people.end(), greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;=</span> right) {
</span></span><span style="display:flex;"><span>            ans<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> right) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (people[left] <span style="color:#f92672">+</span> people[right] <span style="color:#f92672">&lt;=</span> limit) {
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>, right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="6甲板上的战舰">6.甲板上的战舰<a hidden class="anchor" aria-hidden="true" href="#6甲板上的战舰">#</a></h1>
<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>board</code> 表示甲板，其中，每个单元格可以是一艘战舰 <code>'X'</code> 或者是一个空位 <code>'.'</code> ，返回在甲板 <code>board</code> 上放置的 <strong>战舰</strong> 的数量。</p>
<p><strong>战舰</strong> 只能水平或者垂直放置在 <code>board</code> 上。换句话说，战舰只能按 <code>1 x k</code>（<code>1</code> 行，<code>k</code> 列）或 <code>k x 1</code>（<code>k</code> 行，<code>1</code> 列）的形状建造，其中 <code>k</code> 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg"></p>
<pre tabindex="0"><code>输入：board = [[&#34;X&#34;,&#34;.&#34;,&#34;.&#34;,&#34;X&#34;],[&#34;.&#34;,&#34;.&#34;,&#34;.&#34;,&#34;X&#34;],[&#34;.&#34;,&#34;.&#34;,&#34;.&#34;,&#34;X&#34;]]
输出：2
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：board = [[&#34;.&#34;]]
输出：0
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>board[i][j]</code> 是 <code>'.'</code> 或 <code>'X'</code></li>
</ul>
<h2 id="思路-5">思路<a hidden class="anchor" aria-hidden="true" href="#思路-5">#</a></h2>
<p>遍历一次board，找到一个<code>X</code>就遍历行和列，将<code>X</code>改为<code>.</code>，统计答案即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> countBattleships(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> board) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> board.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> board[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> row; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> col; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span>) {
</span></span><span style="display:flex;"><span>                    board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 遍历列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span> col <span style="color:#f92672">&amp;&amp;</span> board[i][k] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span>; <span style="color:#f92672">++</span>k)
</span></span><span style="display:flex;"><span>                        board[i][k] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 遍历行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;</span> row <span style="color:#f92672">&amp;&amp;</span> board[k][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span>; <span style="color:#f92672">++</span>k)
</span></span><span style="display:flex;"><span>                        board[k][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>                    ans<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="7不同路径">7.不同路径Ⅱ<a hidden class="anchor" aria-hidden="true" href="#7不同路径">#</a></h1>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"></p>
<pre tabindex="0"><code>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre><p><strong>示例 2：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"></p>
<pre tabindex="0"><code>输入：obstacleGrid = [[0,1],[0,0]]
输出：1
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>m == obstacleGrid.length</code></li>
<li><code>n == obstacleGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h2 id="思路-6">思路<a hidden class="anchor" aria-hidden="true" href="#思路-6">#</a></h2>
<p>这是一个带障碍物的二维dp，我们可以将其降到一维，代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> uniquePathsWithObstacles(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> obstacleGrid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> obstacleGrid.size(), m <span style="color:#f92672">=</span> obstacleGrid.at(<span style="color:#ae81ff">0</span>).size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(m); <span style="color:#75715e">// 用一维数组遍历整个棋盘
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (obstacleGrid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (obstacleGrid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                    dp[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> obstacleGrid[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    dp[j] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// 这里的dp[j]是继承了上一行的dp[j]，所以只用加上前一个dp[j - 1]即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp.back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>二维做法如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> uniquePathsWithObstacles(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> obstacleGrid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> obstacleGrid.size(), n <span style="color:#f92672">=</span> obstacleGrid.at(<span style="color:#ae81ff">0</span>).size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">105</span>][<span style="color:#ae81ff">105</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (obstacleGrid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 特判一下起点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (obstacleGrid[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">+=</span> dp[<span style="color:#ae81ff">0</span>][i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (obstacleGrid[j][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) dp[j][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> dp[j][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (obstacleGrid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) dp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="8施咒的最大总伤害dp">8.施咒的最大总伤害（dp）<a hidden class="anchor" aria-hidden="true" href="#8施咒的最大总伤害dp">#</a></h1>
<p>一个魔法师有许多不同的咒语。</p>
<p>给你一个数组 <code>power</code> ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p>
<p>已知魔法师使用伤害值为 <code>power[i]</code> 的咒语时，他们就 <strong>不能</strong> 使用伤害为 <code>power[i] - 2</code> ，<code>power[i] - 1</code> ，<code>power[i] + 1</code> 或者 <code>power[i] + 2</code> 的咒语。</p>
<p>每个咒语最多只能被使用 <strong>一次</strong> 。</p>
<p>请你返回这个魔法师可以达到的伤害值之和的 <strong>最大值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**power = [1,1,3,4]</p>
<p>**输出：**6</p>
<p><strong>解释：</strong></p>
<p>可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**power = [7,1,6,6]</p>
<p>**输出：**13</p>
<p><strong>解释：</strong></p>
<p>可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>1 &lt;= power[i] &lt;= 10^9</code></li>
</ul>
<h2 id="思路-7">思路<a hidden class="anchor" aria-hidden="true" href="#思路-7">#</a></h2>
<p>本题为动态规划，每个咒语都有一个对应的伤害值，选了某个咒语后，该咒语的伤害值+-2范围内的咒语都不能选，给定一个咒语数组，要我们求最大能够造成多少伤害。注意若有多个相同伤害值的咒语，可以重复选择。所以对于每种伤害值的咒语，他能打出的伤害应该是<code>ai*bi</code>，<strong>其中<code>ai</code>表示咒语的伤害值，<code>bi</code>表示该伤害值咒语的数量。</strong></p>
<p><strong>我们用<code>f[i]</code>来记录最后使用第<code>i</code>个咒语能打出的最大总伤害</strong>，我们先根据咒语的本身基础伤害排序，那么对于<code>j&lt;i</code>，有下面的状态转移方程：<code>f[i] = f[j] + ai*bi</code>，其中要满足<code>aj &lt; ai - 2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> maximumTotalDamage(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> power) {
</span></span><span style="display:flex;"><span>        map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>mp; <span style="color:#75715e">// 统计每种伤害值咒语的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : power) mp[x]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pii;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// vec里按伤害从小到大保存每种咒语的伤害和数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> vec; 
</span></span><span style="display:flex;"><span>        vec.push_back(pii(<span style="color:#f92672">-</span><span style="color:#ae81ff">1e9</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>p : mp) vec.push_back(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> vec.size();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// f[i]表示最后释放了第i种咒语的最大总伤害
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> f[n];
</span></span><span style="display:flex;"><span>        f[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> mx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 计算释放第i个咒语能获得的最大伤害
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 求当前满足条件的最大伤害
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> i <span style="color:#f92672">&amp;&amp;</span> vec[j].first <span style="color:#f92672">&lt;</span> vec[i].first <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>                mx <span style="color:#f92672">=</span> max(mx, f[j]);
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">++</span>j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 释放第i个咒语的伤害+之前能达到的最大伤害 = 释放第i个咒语所能达到的最大伤害
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            f[i] <span style="color:#f92672">=</span> mx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1LL</span> <span style="color:#f92672">*</span> vec[i].first <span style="color:#f92672">*</span> vec[i].second;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 求最大值返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) ans <span style="color:#f92672">=</span> max(ans, f[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="9构成整天的下标对数目哈希表">9.构成整天的下标对数目（哈希表）<a hidden class="anchor" aria-hidden="true" href="#9构成整天的下标对数目哈希表">#</a></h1>
<p>给你一个整数数组 <code>hours</code>，表示以 <strong>小时</strong> 为单位的时间，返回一个整数，表示满足 <code>i &lt; j</code> 且 <code>hours[i] + hours[j]</code> 构成 <strong>整天</strong> 的下标对 <code>i</code>, <code>j</code> 的数目。</p>
<p><strong>整天</strong> 定义为时间持续时间是 24 小时的 <strong>整数倍</strong> 。</p>
<p>例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> hours = [12,12,30,24,24]</p>
<p><strong>输出：</strong> 2</p>
<p><strong>解释：</strong></p>
<p>构成整天的下标对分别是 <code>(0, 1)</code> 和 <code>(3, 4)</code>。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> hours = [72,48,24,3]</p>
<p><strong>输出：</strong> 3</p>
<p><strong>解释：</strong></p>
<p>构成整天的下标对分别是 <code>(0, 1)</code>、<code>(0, 2)</code> 和 <code>(1, 2)</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= hours.length &lt;= 5 * 10^5</code></li>
<li><code>1 &lt;= hours[i] &lt;= 10^9</code></li>
</ul>
<h2 id="思路-8">思路<a hidden class="anchor" aria-hidden="true" href="#思路-8">#</a></h2>
<p>看数据范围直接进行枚举会超时，这里采用哈希表查找，本题的思路和两数之和差不多。</p>
<p>我们遍历一遍数组，<strong>计算当前遍历到的元素对24的余数p，那么他所需要配对的数字的余数就应该是(24 - p) % 24</strong>，记录配对的次数即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> countCompleteDayPairs(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> hours) {
</span></span><span style="display:flex;"><span>        unordered_map <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> map_cnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> hour : hours) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> hour <span style="color:#f92672">%</span> <span style="color:#ae81ff">24</span>; <span style="color:#75715e">// 当前的余数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> (<span style="color:#ae81ff">24</span> <span style="color:#f92672">-</span> p) <span style="color:#f92672">%</span> <span style="color:#ae81ff">24</span>; <span style="color:#75715e">// 需要的余数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (map_cnt.find(q) <span style="color:#f92672">!=</span> map_cnt.end()) {
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">+=</span> map_cnt[q];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            map_cnt[p]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="10最大正方形">10.最大正方形<a hidden class="anchor" aria-hidden="true" href="#10最大正方形">#</a></h1>
<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg"></p>
<pre tabindex="0"><code>输入：matrix = [[&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;],[&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;],[&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;],[&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;]]
输出：4
</code></pre><p><strong>示例 2：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg"></p>
<pre tabindex="0"><code>输入：matrix = [[&#34;0&#34;,&#34;1&#34;],[&#34;1&#34;,&#34;0&#34;]]
输出：1
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：matrix = [[&#34;0&#34;]]
输出：0
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
<h2 id="思路-9">思路<a hidden class="anchor" aria-hidden="true" href="#思路-9">#</a></h2>
<p>我们定义<code>dp[i][j]</code>表示以<code>(i, j)</code>为右下角，且只包含1的正方形边长的最大值。</p>
<ul>
<li>
<p>如果该位置的值为0，则<code>dp[i][j] = 0</code>，因为当前位置不可能在由1组成的正方形中</p>
</li>
<li>
<p>如果该位置为1，则<code>dp[i][j]</code>的值由其<strong>上方、左方和左下方</strong>的三个相邻的<code>dp</code>值决定，<strong>具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加1</strong>，状态转移方程如下</p>
<ul>
<li><code>dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1</code></li>
</ul>
</li>
</ul>
<p><strong>下面给出证明</strong></p>
<p><img alt="1277-1.png" loading="lazy" src="https://pic.leetcode-cn.com/14aa58be2ea5c9b36a722db76d2e843c4c909e312223a8461a3d2d93bc734b42-1277-1.png"></p>
<p>如上图所示，若对于<code>(i, j)</code>有<code>dp[i][j] = 4</code>，我们将以<code>(i, j)</code>为右下角、边长为<code>4</code>的正方形涂上颜色，可以发现其左侧位置<code>(i, j-1)</code>，上方位置<code>(i-1, j)</code>，左上方位置<code>(i-1, j-1)</code>均可以作为一个边长为<code>4 - 1 = 3</code>的正方形的右下角。也就是说，<strong>这些位置的<code>dp</code>值至少为<code>3</code></strong>，即：</p>
<ul>
<li><code>dp[i][j-1] &gt;= dp[i][j] - 1</code></li>
<li><code>dp[i-1][j] &gt;= dp[i][j] - 1</code></li>
<li><code>dp[i-1][j-1] &gt;= dp[i][j] - 1</code></li>
</ul>
<p>联立以上三个不等式，得到：</p>
<ul>
<li><code>min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]}) &gt;= dp[i][j] - 1</code></li>
</ul>
<p><strong>以上推导过程是我们通过固定<code>dp[i][j]</code>的值，判断其相邻位置与之的关系得到的不等式。同理，我们也能固定<code>dp[i][j]</code>相邻位置的值，得到另外的限制条件。</strong></p>
<p><img alt="1277-2.png" loading="lazy" src="https://pic.leetcode-cn.com/dfcaa5390732f1b9d1d9c71f696957cbc91904c52e23705a061bae727228126d-1277-2.png"></p>
<p>如上图所示，假设<code>dp[i][j-1]</code>，<code>dp[i-1][j]</code>和<code>dp[i-1][j-1]</code>中最小值为<code>3</code>，</p>
<p>也就是说<code>(i, j-1)</code>、<code>(i-1, j)</code>和<code>(i-1, j-1)</code>均可以作为一个边长为<code>3</code>的正方形的右下角。</p>
<p>我们将这些边长为<code>3</code>的正方形依次涂上色，可以发现如果<code>(i, j)</code>的元素为<code>1</code>，那么它可以作为一个边长为<code>4</code>的正方形的右下角，<code>dp</code>值至少为<code>4</code>，即：</p>
<ul>
<li><code>dp[i][j] &gt;= min({{dp[i][j-1], dp[i-1][j], dp[i-1][j-1]}}) + 1</code></li>
</ul>
<p>联立两种情况得到的不等式，可以得到状态转移方程</p>
<ul>
<li><code>dp[i][j] = min({{dp[i][j-1], dp[i-1][j], dp[i-1][j-1]}}) + 1</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maximalSquare(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> matrix) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (matrix.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> matrix[<span style="color:#ae81ff">0</span>].size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> matrix.size(), col <span style="color:#f92672">=</span> matrix[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(row, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(col));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> row; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> col; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) dp[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> min({dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]}) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> ans <span style="color:#f92672">&gt;</span> dp[i][j] <span style="color:#f92672">?</span> ans : dp[i][j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans <span style="color:#f92672">*</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="11最长回文子序列">11.最长回文子序列<a hidden class="anchor" aria-hidden="true" href="#11最长回文子序列">#</a></h1>
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &#34;bbbab&#34;
输出：4
解释：一个可能的最长回文子序列为 &#34;bbbb&#34; 。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：s = &#34;cbbd&#34;
输出：2
解释：一个可能的最长回文子序列为 &#34;bb&#34; 。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="思路-10">思路<a hidden class="anchor" aria-hidden="true" href="#思路-10">#</a></h2>
<p>动态规划，我们定义<code>dp[i][j]</code>表示<code>s</code>串第<code>i</code>到第<code>j</code>位的最大回文子序列长度，对于每个较短的子序列<code>s[i+1...j-1]</code>，都可以通过向其首部和尾部添加遍历到的字符来进行状态转移。</p>
<ul>
<li>如果当前首部和尾部字符相同，则可以添加
<ul>
<li><code>dp[i][j] = dp[i+1][j-1] + 2</code></li>
</ul>
</li>
<li>如果首部和尾部字符不同，则不能添加
<ul>
<li><code>dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> longestPalindromeSubseq(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> s.length();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dp[i][j]表示s串下标从i到j的最长回文子序列长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(len, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(len));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
</span></span><span style="display:flex;"><span>            dp[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 长度为1是回文子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> c1 <span style="color:#f92672">=</span> s[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">char</span> c2 <span style="color:#f92672">=</span> s[j];
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 首尾相同，可以添加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (c1 <span style="color:#f92672">==</span> c2) dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 首尾不同，不能添加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> dp[i][j] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="12找出有效子序列的最大长度dp">12.找出有效子序列的最大长度（dp）<a hidden class="anchor" aria-hidden="true" href="#12找出有效子序列的最大长度dp">#</a></h1>
<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>
<p><code>nums</code> 的一个 子序列<code>sub</code> 的长度为 <code>x</code> ，如果其满足以下条件，则称其为 <strong>有效子序列</strong> ：</p>
<ul>
<li><code>(sub[0] + sub[1]) % k == (sub[1] + sub[2]) % k == ... == (sub[x - 2] + sub[x - 1]) % k</code></li>
</ul>
<p>返回 <code>nums</code> 的 <strong>最长有效子序列</strong> 的长度。</p>
<p>注：<strong>子序列</strong> 是可以通过从另一个数组删除或不删除某些元素，但不更改其余元素的顺序得到的数组。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**nums = [1,2,3,4,5], k = 2</p>
<p>**输出：**5</p>
<p><strong>解释：</strong></p>
<p>最长有效子序列是 <code>[1, 2, 3, 4, 5]</code> 。</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**nums = [1,4,2,3,1,4], k = 3</p>
<p>**输出：**4</p>
<p><strong>解释：</strong></p>
<p>最长有效子序列是 <code>[1, 4, 1, 4]</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10^3</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^7</code></li>
<li><code>1 &lt;= k &lt;= 10^3</code></li>
</ul>
<h2 id="思路-11">思路<a hidden class="anchor" aria-hidden="true" href="#思路-11">#</a></h2>
<p>我们先将<code>K</code>特殊化，假设<code>K = 10</code>，子序列中<code>sub[0] = 2, sub[1] = 3</code>，那么<code>(sub[0] + sub[1]) % 10 = 5</code>。根据模运算的分配律，我们可以推出<code>sub[2] % 10 = 2</code>，同时也有<code>sub[3] % 10 = 3</code>&hellip;</p>
<p><img alt="1.jpg" loading="lazy" src="https://s2.loli.net/2024/06/30/7VMa9lqJEpwIuSy.jpg"></p>
<p>所以我们可以得出这个结论：<strong>子序列的奇数项模<code>K</code>是一样的，子序列的偶数项模<code>K</code>是一样的</strong>。</p>
<p>根据上面的结论，我们又可以推出，这两个结论：</p>
<ul>
<li><strong>当我们知道了子序列的前两个数，就知道了整个子序列</strong></li>
<li><strong>当我们知道了子序列的后两个数，就知道了整个子序列</strong></li>
</ul>
<p>于是我们就将原问题转换成了：<strong>求序列最后两个数模<code>K</code>为<code>y</code>和<code>x</code>的子序列长度</strong>。</p>
<p>我们要求解这个原问题，就是求解它的子问题：<strong>求序列最后两个数模<code>K</code>为<code>x</code>和<code>y</code>的子序列长度</strong>。在这个子问题的基础上+1即可得到以<code>y</code>和<code>x</code>结尾的子序列的长度。于是就有了下面的状态转移方程：</p>
<ul>
<li><code>dp[y][x] = dp[x][y] + 1</code></li>
</ul>
<p>然后用两层循环遍历<code>0...k-1</code>即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maximumLength(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dp[y][x]表示序列最后两个数模 k 为 y 和 x 的子序列的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> dp(k, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(k));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> y:nums) {
</span></span><span style="display:flex;"><span>            y <span style="color:#f92672">%=</span> k;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> k; <span style="color:#f92672">++</span>x)
</span></span><span style="display:flex;"><span>                dp[y][x] <span style="color:#f92672">=</span> dp[x][y] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> INT_MIN;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> k; <span style="color:#f92672">++</span>j)
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> max(ans, dp[i][j]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="13最后一块石头的重量">13.最后一块石头的重量Ⅱ<a hidden class="anchor" aria-hidden="true" href="#13最后一块石头的重量">#</a></h1>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：stones = [31,26,33,21,40]
输出：5
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
<h2 id="思路-12">思路<a hidden class="anchor" aria-hidden="true" href="#思路-12">#</a></h2>
<p><strong>本题的意思是要将原来的石头尽可能分成重量接近的两堆，然后进行粉碎就可以得到最终最小的重量</strong>。</p>
<p>可以通过01背包来解决：定义<code>dp[i]</code>为背包容量为<code>i</code>的背包能装的最大重量，我们先计算石头的总重量<code>sum</code>，然后目标是<code>target=sum/2</code>，需要求出容量为<code>target</code>的背包所能装的最大重量，求出后将两部分相减即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lastStoneWeightII(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> stones) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(<span style="color:#ae81ff">15001</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i:stones) sum <span style="color:#f92672">+=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> stones.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> target; j <span style="color:#f92672">&gt;=</span> stones[i]; <span style="color:#f92672">--</span>j)
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">=</span> max(dp[j], dp[j<span style="color:#f92672">-</span>stones[i]] <span style="color:#f92672">+</span> stones[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">-</span> dp[target] <span style="color:#f92672">-</span> dp[target];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>至于为什么是<code>sum - dp[target] - dp[target]</code>，这是因为<code>target = sum / 2</code>是向下取整的，一定有<code>sum - dp[target] &gt;= dp[target]</code>。</p>
<h1 id="14目标和">14.目标和<a hidden class="anchor" aria-hidden="true" href="#14目标和">#</a></h1>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [1], target = 1
输出：1
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 20</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
</ul>
<h2 id="思路-13">思路<a hidden class="anchor" aria-hidden="true" href="#思路-13">#</a></h2>
<p>根据题意，我们需要在每个元素前添加 <code>+</code> 或 <code>-</code> 。所以我们可以把原集合分为两种集合：**加法集合 <code>add</code> <strong>与</strong>减法集合 <code>sub</code> **，在加法集合中，所有的元素前添加 <code>+</code> ，在减法集合中，所有的元素前添加 <code>-</code> 。</p>
<p>假设原集合的所有元素和为 <code>sum</code> ，我们有：<code>add + sub = sum</code> ，并且有 <code>add - sub = target</code> 。所以 <code>sub = add - target</code> ，将上式代入第一个式子，得到 <code>2*add - target = sum</code> ，于是乎 <code>add = (target + sum) / 2</code>。其中，<code>target</code> 和 <code>sum</code> 都是定值，我们<strong>只需要在原集合中找出一个子集，满足该子集和 <code>add</code> 等于 <code>(target + sum) / 2</code></strong> 。</p>
<p>这就转换成了一个01背包问题：给定一个 <code>nums</code> 集合，给定一个背包容量 <code>bagSize = (target + sum) / 2 </code>，求有多少种组合能够装满容量为<code>bagSize</code> 的背包。</p>
<p>定义 <code>dp[i]</code> 表示装满容量为 <code>i</code> 的背包有多少种方法。那么对于遍历到的数字 <code>nums[j]</code> ，有 <code>dp[i] += dp[i-nums[j]]</code> ，解释为：装满容量为 <code>i</code> 的背包的方法数量可以由装满容量为 <code>i - nums[j]</code> 的背包的方法数量推过来。</p>
<p>所以我们需要遍历所有物品，将 <code>dp[i-nums[j]]</code> 累加起来，最终得到 <code>dp[bagSize]</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> findTargetSumWays(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i : nums) sum <span style="color:#f92672">+=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (abs(target) <span style="color:#f92672">&gt;</span> sum) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// target 绝对值比 sum 还大，无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((target<span style="color:#f92672">+</span>sum) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 如果无法除尽，表示无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> bagSize <span style="color:#f92672">=</span> (target <span style="color:#f92672">+</span> sum) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(bagSize <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 注意 dp[0] 要初始化为 1 ，否则 dp 数组一直为 0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> bagSize; j <span style="color:#f92672">&gt;=</span> nums[i]; <span style="color:#f92672">--</span>j) {
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">+=</span> dp[j<span style="color:#f92672">-</span>nums[i]];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[bagSize];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="15重新放置石块">15.重新放置石块<a hidden class="anchor" aria-hidden="true" href="#15重新放置石块">#</a></h1>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，表示一些石块的初始位置。再给你两个长度 <strong>相等</strong> 下标从 <strong>0</strong> 开始的整数数组 <code>moveFrom</code> 和 <code>moveTo</code> 。</p>
<p>在 <code>moveFrom.length</code> 次操作内，你可以改变石块的位置。在第 <code>i</code> 次操作中，你将位置在 <code>moveFrom[i]</code> 的所有石块移到位置 <code>moveTo[i]</code> 。</p>
<p>完成这些操作后，请你按升序返回所有 <strong>有</strong> 石块的位置。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果一个位置至少有一个石块，我们称这个位置 <strong>有</strong> 石块。</li>
<li>一个位置可能会有多个石块。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
输出：[5,6,8,9]
解释：一开始，石块在位置 1,6,7,8 。
第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，位置 2,6,7,8 有石块。
第 i = 1 步操作中，我们将位置 7 处的石块移到位置 9 处，位置 2,6,8,9 有石块。
第 i = 2 步操作中，我们将位置 2 处的石块移到位置 5 处，位置 5,6,8,9 有石块。
最后，至少有一个石块的位置为 [5,6,8,9] 。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
输出：[2]
解释：一开始，石块在位置 [1,1,3,3] 。
第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，有石块的位置为 [2,2,3,3] 。
第 i = 1 步操作中，我们将位置 3 处的石块移到位置 2 处，有石块的位置为 [2,2,2,2] 。
由于 2 是唯一有石块的位置，我们返回 [2] 。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= moveFrom.length &lt;= 10^5</code></li>
<li><code>moveFrom.length == moveTo.length</code></li>
<li><code>1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 10^9</code></li>
<li>测试数据保证在进行第 <code>i</code> 步操作时，<code>moveFrom[i]</code> 处至少有一个石块。</li>
</ul>
<h2 id="思路-14">思路<a hidden class="anchor" aria-hidden="true" href="#思路-14">#</a></h2>
<p>本题简单来讲，是给你一个<strong>原始数组</strong>和两个<strong>移动数组</strong>，根据两个<strong>移动数组</strong>将<strong>原始数组</strong>中的数字进行<strong>依次</strong>替换，最后返回升序排列。</p>
<p>考虑到返回升序排列，我们可以用 <code>set</code> 容器实现升序。</p>
<p><strong>需要注意的是，当我们想通过迭代器修改集合中的元素，不能像数组中的下标访问一样根据索引访问数据，而是先删除原始数据再插入新数据。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> relocateMarbles(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> moveFrom, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> moveTo) {
</span></span><span style="display:flex;"><span>        set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> num_set;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i: nums) num_set.insert(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> moveFrom.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> index <span style="color:#f92672">=</span> num_set.find(moveFrom[i]);
</span></span><span style="display:flex;"><span>            num_set.erase(index); <span style="color:#75715e">// 通过迭代器先删除原始数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            num_set.insert(moveTo[i]); <span style="color:#75715e">// 再插入新数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i: num_set) ans.push_back(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="16解决智力问题">16.解决智力问题<a hidden class="anchor" aria-hidden="true" href="#16解决智力问题">#</a></h1>
<p>跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作。</p>
<ul>
<li>
<p>比方说，给你</p>
<pre tabindex="0"><code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]
</code></pre><ul>
<li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code> 。</li>
<li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code> 。</li>
</ul>
</li>
</ul>
<p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：questions = [[3,2],[4,3],[4,4],[2,5]]
输出：5
解释：解决问题 0 和 3 得到最高分。
- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。
- 不能解决问题 1 和 2
- 解决问题 3 ：获得 2 分
总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：7
解释：解决问题 1 和 4 得到最高分。
- 跳过问题 0
- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。
- 不能解决问题 2 和 3
- 解决问题 4 ：获得 5 分
总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= questions.length &lt;= 10^5</code></li>
<li><code>questions[i].length == 2</code></li>
<li><code>1 &lt;= pointsi, brainpoweri &lt;= 10^5</code></li>
</ul>
<h2 id="思路-15">思路<a hidden class="anchor" aria-hidden="true" href="#思路-15">#</a></h2>
<p>首先尝试用 <code>dp[i]</code> 表示解决前 <code>i</code> 道题可以获得的最高分数。根据是否选择解决第 <code>i</code> 题，会有以下两种情况：</p>
<ul>
<li>不解决第 <code>i</code> 题，此时 <code>dp[i] = dp[i-1]</code>；</li>
<li>解决第 <code>i</code> 题，此时要么前面的题目都未解决，要么上一道解决的题目对应的冷冻期已经结束。</li>
</ul>
<p>由于每道题对应的冷冻期都不一样，因此我们很难在不通过遍历 <code>[0, i-1]</code> 闭区间内的全部下标，以判断对应的冷冻期是否结束的情况下更新 <code>dp[i]</code> 。如果题目总数为 <code>n</code> 那么时间复杂度就为 <code>O(n^2)</code> ，不符合题目要求。</p>
<p>因此我们从<strong>无后效性</strong>的角度考虑 dp 数组的定义。对于每一道题目，解决与否会影响到<strong>后面</strong>一定数量题目的结果，但不会影响到<strong>前面</strong>题目的解决。因此我们可以考虑从反方向定义<strong>状态</strong>，即考虑解决<strong>每道题本身及以后的题目可以获得的最高分数</strong>。</p>
<p><strong>无后效性：某阶段的状态一旦确定，则此后过程的决策不再受此前各种状态及决策的影响</strong></p>
<p>于是我们定义 <code>dp[i]</code> 表示解决第 <code>i</code> 道题及以后的题目可以获得的最高分数。同时我们从后往前遍历题目，并更新 <code>dp</code> 数组。类似的，根据是否选择解决第 <code>i</code> 道题，会有以下两种情况：</p>
<ul>
<li>不解决第 <code>i</code> 题，此时 <code>dp[i] = dp[i+1]</code>；</li>
<li>解决第 <code>i</code> 题，我们只能解决下标大于 <code>i+brainpower[i]</code> 的题目，而此时需要根据 <code>dp</code> 数组的定义，解决这些题目的最高分数为 <code>dp[i+brainpower[i]+1]</code> 。</li>
</ul>
<p>因此，我们有：<code>dp[i] = points[i] + dp[i+brainpower[i]+1]</code> 。综合上述两种情况，我们能够得出状态转移方程：<code>dp[i] = max(dp[i+1], points[i]+dp[i+brainpower[i]+1])</code></p>
<p>另外还需要考虑 <code>i &gt;= n</code> 的边界条件，代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> mostPoints(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> questions) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> questions.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span> dp(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) 
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], questions[i][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span>dp[min(n, i<span style="color:#f92672">+</span>questions[i][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="17生成特殊数字的最少操作">17.生成特殊数字的最少操作<a hidden class="anchor" aria-hidden="true" href="#17生成特殊数字的最少操作">#</a></h1>
<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>num</code> ，表示一个非负整数。</p>
<p>在一次操作中，您可以选择 <code>num</code> 的任意一位数字并将其删除。请注意，如果你删除 <code>num</code> 中的所有数字，则 <code>num</code> 变为 <code>0</code>。</p>
<p>返回最少需要多少次操作可以使 <code>num</code> 变成特殊数字。</p>
<p>如果整数 <code>x</code> 能被 <code>25</code> 整除，则该整数 <code>x</code> 被认为是特殊数字。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：num = &#34;2245047&#34;
输出：2
解释：删除数字 num[5] 和 num[6] ，得到数字 &#34;22450&#34; ，可以被 25 整除。
可以证明要使数字变成特殊数字，最少需要删除 2 位数字。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：num = &#34;2908305&#34;
输出：3
解释：删除 num[3]、num[4] 和 num[6] ，得到数字 &#34;2900&#34; ，可以被 25 整除。
可以证明要使数字变成特殊数字，最少需要删除 3 位数字。
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：num = &#34;10&#34;
输出：1
解释：删除 num[0] ，得到数字 &#34;0&#34; ，可以被 25 整除。
可以证明要使数字变成特殊数字，最少需要删除 1 位数字。
</code></pre><p><strong>提示</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 100</code></li>
<li><code>num</code> 仅由数字 <code>'0'</code> 到 <code>'9'</code> 组成</li>
<li><code>num</code> 不含任何前导零</li>
</ul>
<h2 id="思路-16">思路<a hidden class="anchor" aria-hidden="true" href="#思路-16">#</a></h2>
<p>一个数能被 25 整除，只需满足下列条件：</p>
<ul>
<li>如果是 1 位数，那么就是 0</li>
<li>如果是 2 位数或者更多位数，那么它的<strong>最后两位</strong>必须是 00、25、50、75 中的一个</li>
</ul>
<p>我们观察第二种情况，可以得出我们只需要判断数字的最后两位即可。所以我们考虑<strong>从右往左遍历</strong>，当找到 0 或 5 的时候标记一下，继续往前找对应的数字，具体情况如下图：</p>
<p><img alt="lc2844.png" loading="lazy" src="https://pic.leetcode.cn/1721712236-KMehiq-lc2844.png"></p>
<p><strong>当我们找到满足条件的内容时，直接返回 <code>n - i - 2</code> ， <code>i</code> 是当前遍历到的数字下标</strong>。至于为什么是 <code>n - i - 2</code> ，因为 <code>n - i</code> 表示从第 <code>i</code> 位到数字末尾的长度，再 <code>-2</code> 表示在这段长度中减去满足条件的两个数字，即：<code>00、25、50、75</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minimumOperations(string num) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> num.length();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> found0 <span style="color:#f92672">=</span> false, found5 <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> num[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (found0 <span style="color:#f92672">&amp;&amp;</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">||</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;5&#39;</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                found5 <span style="color:#f92672">&amp;&amp;</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;2&#39;</span> <span style="color:#f92672">||</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;7&#39;</span>)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> n <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
</span></span><span style="display:flex;"><span>                found0 <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;5&#39;</span>) {
</span></span><span style="display:flex;"><span>                found5 <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">-</span> found0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="18掉落的方块">18.掉落的方块<a hidden class="anchor" aria-hidden="true" href="#18掉落的方块">#</a></h1>
<p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [lefti, sideLengthi]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLengthi</code> ，其左侧边与 x 轴上坐标点 <code>lefti</code> 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>
<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg"></p>
<pre tabindex="0"><code>输入：positions = [[1,2],[2,3],[6,1]]
输出：[2,5,5]
解释：
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
因此，返回 [2, 5, 5] 作为答案。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：positions = [[100,100],[200,100]]
输出：[100,100]
解释：
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
因此，返回 [100, 100] 作为答案。
注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 1000</code></li>
<li><code>1 &lt;= lefti &lt;= 10^8</code></li>
<li><code>1 &lt;= sideLengthi &lt;= 10^6</code></li>
</ul>
<h2 id="思路-17">思路<a hidden class="anchor" aria-hidden="true" href="#思路-17">#</a></h2>
<p>数据量不是很大，我们顺序遍历每个方块，对于每个方块再从头开始枚举已经稳定下来的方块，判断两个方块是否有重合，如果有就更新当前方块的最大高度即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> fallingSquares(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> positions) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> positions.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> height(n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当前方块的左右边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> left1 <span style="color:#f92672">=</span> positions[i][<span style="color:#ae81ff">0</span>], right1 <span style="color:#f92672">=</span> positions[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> positions[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            height[i] <span style="color:#f92672">=</span> positions[i][<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从头开始枚举，判断当前方块与前面稳定的方块是否有重叠
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> i; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> left2 <span style="color:#f92672">=</span> positions[j][<span style="color:#ae81ff">0</span>], right2 <span style="color:#f92672">=</span> positions[j][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> positions[j][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果有重叠，更新最大答案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (right1 <span style="color:#f92672">&gt;=</span> left2 <span style="color:#f92672">&amp;&amp;</span> right2 <span style="color:#f92672">&gt;=</span> left1) {
</span></span><span style="display:flex;"><span>                    height[i] <span style="color:#f92672">=</span> max(height[i], height[j] <span style="color:#f92672">+</span> positions[i][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 最后更新一遍当前最大高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            height[i] <span style="color:#f92672">=</span> max(height[i], height[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="19另一棵树的子树">19.另一棵树的子树<a hidden class="anchor" aria-hidden="true" href="#19另一棵树的子树">#</a></h1>
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
<p><strong>示例 1：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg"></p>
<pre tabindex="0"><code>输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
</code></pre><p><strong>示例 2：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg"></p>
<pre tabindex="0"><code>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>
<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>
<li><code>-10^4 &lt;= root.val &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= subRoot.val &lt;= 10^4</code></li>
</ul>
<h2 id="思路-18">思路<a hidden class="anchor" aria-hidden="true" href="#思路-18">#</a></h2>
<p>数据范围不是很大，直接 dfs 判断是否有子树和另一棵树相等即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查两棵树是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> check(TreeNode<span style="color:#f92672">*</span> o, TreeNode<span style="color:#f92672">*</span> t) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>o <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>t) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((o <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>t) <span style="color:#f92672">||</span> (<span style="color:#f92672">!</span>o <span style="color:#f92672">&amp;&amp;</span> t) <span style="color:#f92672">||</span> (o<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">!=</span> t<span style="color:#f92672">-&gt;</span>val)) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">check</span>(o<span style="color:#f92672">-&gt;</span>left, t<span style="color:#f92672">-&gt;</span>left) <span style="color:#f92672">&amp;&amp;</span> check(o<span style="color:#f92672">-&gt;</span>right, t<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(TreeNode<span style="color:#f92672">*</span> o, TreeNode<span style="color:#f92672">*</span> t) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>o) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 两棵树相等或者 o 的某棵子树和 t 相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> check(o, t) <span style="color:#f92672">||</span> dfs(o<span style="color:#f92672">-&gt;</span>left, t) <span style="color:#f92672">||</span> dfs(o<span style="color:#f92672">-&gt;</span>right, t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSubtree</span>(TreeNode<span style="color:#f92672">*</span> root, TreeNode<span style="color:#f92672">*</span> subRoot) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dfs(root, subRoot);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="20新增道路查询后的最短距离">20.新增道路查询后的最短距离Ⅰ<a hidden class="anchor" aria-hidden="true" href="#20新增道路查询后的最短距离">#</a></h1>
<p>给你一个整数 <code>n</code> 和一个二维整数数组 <code>queries</code>。</p>
<p>有 <code>n</code> 个城市，编号从 <code>0</code> 到 <code>n - 1</code>。初始时，每个城市 <code>i</code> 都有一条<strong>单向</strong>道路通往城市 <code>i + 1</code>（ <code>0 &lt;= i &lt; n - 1</code>）。</p>
<p><code>queries[i] = [ui, vi]</code> 表示新建一条从城市 <code>ui</code> 到城市 <code>vi</code> 的<strong>单向</strong>道路。每次查询后，你需要找到从城市 <code>0</code> 到城市 <code>n - 1</code> 的<strong>最短路径</strong>的<strong>长度</strong>。</p>
<p>返回一个数组 <code>answer</code>，对于范围 <code>[0, queries.length - 1]</code> 中的每个 <code>i</code>，<code>answer[i]</code> 是处理完<strong>前</strong> <code>i + 1</code> 个查询后，从城市 <code>0</code> 到城市 <code>n - 1</code> 的最短路径的<em>长度</em>。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> n = 5, queries = [[2, 4], [0, 2], [0, 4]]</p>
<p><strong>输出：</strong> [3, 2, 1]</p>
<p><strong>解释：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/28/image8.jpg"></p>
<p>新增一条从 2 到 4 的道路后，从 0 到 4 的最短路径长度为 3。</p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/28/image9.jpg"></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 4 的最短路径长度为 2。</p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/28/image10.jpg"></p>
<p>新增一条从 0 到 4 的道路后，从 0 到 4 的最短路径长度为 1。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> n = 4, queries = [[0, 3], [0, 2]]</p>
<p><strong>输出：</strong> [1, 1]</p>
<p><strong>解释：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/28/image11.jpg"></p>
<p>新增一条从 0 到 3 的道路后，从 0 到 3 的最短路径长度为 1。</p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/28/image12.jpg"></p>
<p>新增一条从 0 到 2 的道路后，从 0 到 3 的最短路径长度仍为 1。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= queries.length &lt;= 500</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= queries[i][0] &lt; queries[i][1] &lt; n</code></li>
<li><code>1 &lt; queries[i][1] - queries[i][0]</code></li>
<li>查询中没有重复的道路。</li>
</ul>
<h2 id="思路-19">思路<a hidden class="anchor" aria-hidden="true" href="#思路-19">#</a></h2>
<p>本题数据量不大，主要是熟悉 bfs 的使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bfs(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> city) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dist[i] 表示从第 0 个城市到达第 i 个城市所需要的最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dist(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        dist[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当前城市能够到达的城市
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v: city[u]) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 未访问过就更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 这里这样判断是因为我们是从前往后遍历城市的，当这个城市在前面被访问过，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// 那么从当前这个点再到这个城市的距离就会更大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (dist[v] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                    dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    q.push(v);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dist[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> shortestDistanceAfterQueries(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> queries) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 城市 i 能到达的城市
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> city(n);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) city[i].push_back(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 处理每次询问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>q : queries) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 对应城市加上能到达的城市
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            city[q[<span style="color:#ae81ff">0</span>]].push_back(q[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// bfs 一次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ans.push_back(bfs(n, city));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="21判断子序列">21.判断子序列<a hidden class="anchor" aria-hidden="true" href="#21判断子序列">#</a></h1>
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, &hellip; , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>致谢：</strong></p>
<p>特别感谢 <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：s = &#34;abc&#34;, t = &#34;ahbgdc&#34;
输出：true
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：s = &#34;axc&#34;, t = &#34;ahbgdc&#34;
输出：false
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 100</code></li>
<li><code>0 &lt;= t.length &lt;= 10^4</code></li>
<li>两个字符串都只由小写字符组成。</li>
</ul>
<h2 id="思路-20">思路<a hidden class="anchor" aria-hidden="true" href="#思路-20">#</a></h2>
<p>首先，如果 <code>s</code> 是空串，直接返回 <code>true</code> ，因为空串是任何字符串的子序列。</p>
<p>如果 <code>s</code> 不是空串，我们可以遍历 <code>t</code> ，在遍历的过程中看能否匹配 <code>s</code>  中的每个字母。按照子序列的定义，在遍历 <code>t</code> 的过程中，<strong>把没匹配到的字母删除，剩下得就是匹配的字母</strong>，即字符串 <code>s</code> ，这就说明 <code>s</code> 是 <code>t</code> 的子序列。</p>
<p>具体算法如下：</p>
<ol>
<li>初始化 <code>i = 0</code> 。</li>
<li>遍历字符串 <code>t</code> 中的字符 <code>c = t[j]</code> ，看其是否与 <code>s[i]</code>  匹配，如果匹配就把 <code>i</code> 加一。加一后，如果 <code>i</code> 等于 <code>s</code> 的长度，说明 <code>s</code> 的所有字符匹配完毕，<code>s</code> 是 <code>t</code> 的子序列，返回 <code>true</code> 。</li>
<li>如果遍历中没有返回，说明 <code>s</code> 不是 <code>t</code> 的子序列，返回 <code>false</code> 。</li>
</ol>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isSubsequence(string s, string t) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s.empty()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c: t) <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> c <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">++</span>i <span style="color:#f92672">==</span> s.length()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="22找出与数组相加的整数">22.找出与数组相加的整数Ⅱ<a hidden class="anchor" aria-hidden="true" href="#22找出与数组相加的整数">#</a></h1>
<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>从 <code>nums1</code> 中移除两个元素，并且所有其他元素都与变量 <code>x</code> 所表示的整数相加。如果 <code>x</code> 为负数，则表现为元素值的减少。</p>
<p>执行上述操作后，<code>nums1</code> 和 <code>nums2</code> <strong>相等</strong> 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 <strong>相等</strong> 。</p>
<p>返回能够实现数组相等的 <strong>最小</strong> 整数 <code>x</code> 。</p>
<p><strong>示例 1:</strong></p>
<p>**输入：**nums1 = [4,20,16,12,8], nums2 = [14,18,10]</p>
<p><strong>输出：</strong>-2</p>
<p><strong>解释：</strong></p>
<p>移除 <code>nums1</code> 中下标为 <code>[0,4]</code> 的两个元素，并且每个元素与 <code>-2</code> 相加后，<code>nums1</code> 变为 <code>[18,14,10]</code> ，与 <code>nums2</code> 相等。</p>
<p><strong>示例 2:</strong></p>
<p>**输入：**nums1 = [3,5,5,3], nums2 = [7,7]</p>
<p>**输出：**2</p>
<p><strong>解释：</strong></p>
<p>移除 <code>nums1</code> 中下标为 <code>[0,3]</code> 的两个元素，并且每个元素与 <code>2</code> 相加后，<code>nums1</code> 变为 <code>[7,7]</code> ，与 <code>nums2</code> 相等。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums1.length &lt;= 200</code></li>
<li><code>nums2.length == nums1.length - 2</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
<li>测试用例以这样的方式生成：存在一个整数 <code>x</code>，<code>nums1</code> 中的每个元素都与 <code>x</code> 相加后，再移除两个元素，<code>nums1</code> 可以与 <code>nums2</code> 相等。</li>
</ul>
<h2 id="思路-21">思路<a hidden class="anchor" aria-hidden="true" href="#思路-21">#</a></h2>
<p>把两个数组都从小到大排序。</p>
<p>由于只能移除两个元素，<strong>所以 <code>nums1</code> 的前三小元素必定有一个是保留下来的</strong>，我们可以枚举<strong>保留下来的最小元素</strong>是 <code>nums1[0]</code> 还是 <code>nums1[1]</code> 还是 <code>nums1[2]</code> 。</p>
<p>注意：保留下来的最小元素绝不可能是 <code>nums1[3]</code> 或更大的数，因为这意味着我们把前三小的数都移除了，而题目要求只能移除两个元素。</p>
<p>例如排序后 <code>nums1 = [2, 5, 6, 7, 8, 10]</code> ，<code>nums2 = [3, 4, 5, 8]</code> ，如果 <code>nums1</code> 中保留下来的最小元素是 <code>nums1[1] = 5</code> ，那么 <code>x = nums2[0] - nums[1] = 3 - 5 = -2</code> ，这意味着我们把 <code>nums1</code> 的每个数都加上 <code>x = -2</code> ，得到 <code>nums1' = [0, 3, 4, 5, 6, 8]</code> ，问题就变成判断 <code>nums2</code> 是否为 <code>nums1'</code> 的子序列，如果是子序列，那么就可以移除多余的两个数了。判断是否是子序列参照上一题 T21.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minimumAddedInteger(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums1, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums2) {
</span></span><span style="display:flex;"><span>        sort(nums1.begin(), nums1.end());
</span></span><span style="display:flex;"><span>        sort(nums2.begin(), nums2.end());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 前三小的数一定有一个保留下来，枚举留下来的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> nums2[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> nums1[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;</span> nums1.size(); <span style="color:#f92672">++</span>k) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (nums2[j] <span style="color:#f92672">==</span> nums1[k] <span style="color:#f92672">+</span> x <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">++</span>j <span style="color:#f92672">==</span> nums2.size()) <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> nums2[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> nums1[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="23统计好节点的数目建树dfs">23.统计好节点的数目（建树+dfs）<a hidden class="anchor" aria-hidden="true" href="#23统计好节点的数目建树dfs">#</a></h1>
<p>现有一棵 <strong>无向</strong> 树，树中包含 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 标记。树的根节点是节点 <code>0</code> 。给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code>，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 与节点 <code>bi</code> 之间存在一条边。</p>
<p>如果一个节点的所有子节点为根的子树包含的节点数相同，则认为该节点是一个 <strong>好节点</strong>。</p>
<p>返回给定树中 <strong>好节点</strong> 的数量。</p>
<p><strong>子树</strong> 指的是一个节点以及它所有后代节点构成的一棵树。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]</p>
<p>**输出：**7</p>
<p><strong>说明：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/05/26/tree1.png"></p>
<p>树的所有节点都是好节点。</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**edges = [[0,1],[1,2],[2,3],[3,4],[0,5],[1,6],[2,7],[3,8]]</p>
<p>**输出：**6</p>
<p><strong>说明：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-193552.png"></p>
<p>树中有 6 个好节点。上图中已将这些节点着色。</p>
<p><strong>示例 3：</strong></p>
<p>**输入：**edges = [[0,1],[1,2],[1,3],[1,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[9,12],[10,11]]</p>
<p>**输出：**12</p>
<p><strong>解释：</strong></p>
<p><img alt="img" loading="lazy" src="https://assets.leetcode.com/uploads/2024/08/08/rob.jpg"></p>
<p>除了节点 9 以外其他所有节点都是好节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li>输入确保 <code>edges</code> 总表示一棵有效的树。</li>
</ul>
<h2 id="思路-22">思路<a hidden class="anchor" aria-hidden="true" href="#思路-22">#</a></h2>
<p>建树操作可以参考本题，使用 <code>unordered_map</code> 创建无向树（有向树和无向树的区别在于向 <code>unordered_map</code> 中 push 的内容）。</p>
<p><strong>dfs 时要注意不要回溯到父节点</strong>。这里利用 <code>unordered_set</code> 不允许重复元素的特性，判断当前节点的所有子节点为根的子树包含的节点数是否相等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> tree;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> goodNodes;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dfs(<span style="color:#66d9ef">int</span> node, <span style="color:#66d9ef">int</span> parent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 自身也算在子树节点数目中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> childSizes;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> child: tree[node]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (child <span style="color:#f92672">!=</span> parent) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> childSubtreeSize <span style="color:#f92672">=</span> dfs(child, node);
</span></span><span style="display:flex;"><span>                size <span style="color:#f92672">+=</span> childSubtreeSize;
</span></span><span style="display:flex;"><span>                childSizes.insert(childSubtreeSize);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (childSizes.size() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            goodNodes<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> size;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countGoodNodes</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> edges.size() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        goodNodes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        tree.clear();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> edge: edges) {
</span></span><span style="display:flex;"><span>            tree[edge[<span style="color:#ae81ff">0</span>]].push_back(edge[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            tree[edge[<span style="color:#ae81ff">1</span>]].push_back(edge[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> goodNodes;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="24单调数组对的数目">24.单调数组对的数目Ⅱ<a hidden class="anchor" aria-hidden="true" href="#24单调数组对的数目">#</a></h1>
<p>给你一个长度为 <code>n</code> 的 <strong>正</strong> 整数数组 <code>nums</code> 。</p>
<p>如果两个 <strong>非负</strong> 整数数组 <code>(arr1, arr2)</code> 满足以下条件，我们称它们是 <strong>单调</strong> 数组对：</p>
<ul>
<li>两个数组的长度都是 <code>n</code> 。</li>
<li><code>arr1</code> 是单调 <strong>非递减</strong> 的，换句话说 <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code> 。</li>
<li><code>arr2</code> 是单调 <strong>非递增</strong> 的，换句话说 <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code> 。</li>
<li>对于所有的 <code>0 &lt;= i &lt;= n - 1</code> 都有 <code>arr1[i] + arr2[i] == nums[i]</code> 。</li>
</ul>
<p>请你返回所有 <strong>单调</strong> 数组对的数目。</p>
<p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**nums = [2,3,2]</p>
<p>**输出：**4</p>
<p><strong>解释：</strong></p>
<p>单调数组对包括：</p>
<ol>
<li><code>([0, 1, 1], [2, 2, 1])</code></li>
<li><code>([0, 1, 2], [2, 2, 0])</code></li>
<li><code>([0, 2, 2], [2, 1, 0])</code></li>
<li><code>([1, 2, 2], [1, 1, 0])</code></li>
</ol>
<p><strong>示例 2：</strong></p>
<p>**输入：**nums = [5,5,5,5]</p>
<p>**输出：**126</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="思路-23">思路<a hidden class="anchor" aria-hidden="true" href="#思路-23">#</a></h2>
<p>记 <code>f(i, j)</code> 表示考虑前 <code>i</code> 个元素，且 <code>arr1[i] = j</code> 的方案数。</p>
<p>由于 <code>arr1[i] + arr2[i] == nums[i]</code> ，因此 <code>arr2[i] = nums[i] - arr1[i] = nums[i] - j</code> 。</p>
<p>考虑 <code>arr1[i-1] = j'</code> ，根据题目要求：</p>
<ul>
<li><code>arr1</code> 非递减，因此 <code>j' &lt;= j</code></li>
<li><code>arr2</code> 非递增，因此 <code>nums[i] - j &lt;= nums[i-1] - j'</code> ，移项得 <code>j' &lt;= j + nums[i-1] - nums[i]</code></li>
</ul>
<p>因此 <code>f(i, j) = sum(f(i-1, j'))</code> ，其中 <code>j' &lt;= min(j, j + nums[i-1] - nums[i])</code> ，可以使用前缀和优化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> countOfPairs(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x : nums) mx <span style="color:#f92672">=</span> max(mx, x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 初始化 f[0][j] 以及对应的前缀和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> f[n][mx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], g[n][mx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        memset(f, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(f)); memset(g, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(g));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> nums[<span style="color:#ae81ff">0</span>]; i<span style="color:#f92672">++</span>) f[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        g[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> f[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> mx; i<span style="color:#f92672">++</span>) g[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> (g[<span style="color:#ae81ff">0</span>][i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> f[<span style="color:#ae81ff">0</span>][i]) <span style="color:#f92672">%</span> MOD;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 计算单个 DP 状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> nums[i]; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> lim <span style="color:#f92672">=</span> min(j, j <span style="color:#f92672">+</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> nums[i]);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (lim <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) f[i][j] <span style="color:#f92672">=</span> g[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][lim];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 计算前缀和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            g[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> f[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> mx; j<span style="color:#f92672">++</span>) g[i][j] <span style="color:#f92672">=</span> (g[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> f[i][j]) <span style="color:#f92672">%</span> MOD;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> g[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][mx];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="25特殊数组前缀和">25.特殊数组Ⅱ（前缀和）<a hidden class="anchor" aria-hidden="true" href="#25特殊数组前缀和">#</a></h1>
<p>如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 <strong>特殊数组</strong> 。</p>
<p>你有一个整数数组 <code>nums</code> 和一个二维整数矩阵 <code>queries</code>，对于 <code>queries[i] = [fromi, toi]</code>，请你帮助你检查</p>
<p>子数组 <code>nums[fromi..toi]</code> 是不是一个 <strong>特殊数组</strong> 。</p>
<p>返回布尔数组 <code>answer</code>，如果 <code>nums[fromi..toi]</code> 是特殊数组，则 <code>answer[i]</code> 为 <code>true</code> ，否则，<code>answer[i]</code> 为 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**nums = [3,4,1,2,6], queries = [[0,4]]</p>
<p><strong>输出：</strong>[false]</p>
<p><strong>解释：</strong></p>
<p>子数组是 <code>[3,4,1,2,6]</code>。2 和 6 都是偶数。</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**nums = [4,3,1,6], queries = [[0,2],[2,3]]</p>
<p><strong>输出：</strong>[false,true]</p>
<p><strong>解释：</strong></p>
<ol>
<li>子数组是 <code>[4,3,1]</code>。3 和 1 都是奇数。因此这个查询的答案是 <code>false</code>。</li>
<li>子数组是 <code>[1,6]</code>。只有一对：<code>(1,6)</code>，且包含了奇偶性不同的数字。因此这个查询的答案是 <code>true</code>。</li>
</ol>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= queries.length &lt;= 10^5</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= nums.length - 1</code></li>
</ul>
<h2 id="思路-24">思路<a hidden class="anchor" aria-hidden="true" href="#思路-24">#</a></h2>
<p>如果直接对于每个询问去遍历 <code>nums[from]到nums[to]</code> ，是 <code>O(n^2)</code> 的复杂度，看数据范围一定会超时。</p>
<p>如果一个子数组存在一堆相邻元素，它们的奇偶性相同，那么这个子数组一定不是特殊数组。</p>
<p>怎么快速判断是否有奇偶性相同的相邻元素？</p>
<p><strong>我们考虑这样一个问题：对于一个只含有 0 和 1 的数组，如何快速判断一个子数组是否全为 0 ？</strong></p>
<p><strong>如果子数组的元素和为 0</strong> ，那么这个子数组一定全为 0 ；<strong>如果子数组的元素和大于 0</strong> ，那么子数组一定包含 1 。</p>
<p>对于本题，定义一个长度为 <code>n-1</code> 的数组，<code>a</code> ，其中：</p>
<p><img alt="1.png" loading="lazy" src="https://s2.loli.net/2024/08/14/KHQfiU3x1BnzajM.png"></p>
<p>如果 <code>a</code> 的下标从 <code>from</code> 到 <code>to-1</code> 的子数组和等于 0 ，就说明 <code>nums</code> 的下标从 <code>from</code> 到 <code>to</code> 的这个子数组，其所有相邻元素的奇偶性都不同，那么该子数组就为特殊数组。</p>
<p>计算 <code>a</code> 的前缀和 <code>s</code> ，可以快速判断子数组和是否为 0 ，也就是判断：<code>s[to] - s[from] = 0</code> ，即：<code>s[from] = s[to]</code></p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> isArraySpecial(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> queries) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s(nums.size());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> nums.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            s[i] <span style="color:#f92672">=</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> (nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> nums[i] <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> res(queries.size());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> queries.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> q <span style="color:#f92672">=</span> queries[i];
</span></span><span style="display:flex;"><span>            res[i] <span style="color:#f92672">=</span> s[q[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">==</span> s[q[<span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="26最高乘法得分">26.最高乘法得分<a hidden class="anchor" aria-hidden="true" href="#26最高乘法得分">#</a></h1>
<p>给你一个大小为 4 的整数数组 <code>a</code> 和一个大小 <strong>至少</strong>为 4 的整数数组 <code>b</code>。</p>
<p>你需要从数组 <code>b</code> 中选择四个下标 <code>i0</code>, <code>i1</code>, <code>i2</code>, 和 <code>i3</code>，并满足 <code>i0 &lt; i1 &lt; i2 &lt; i3</code>。你的得分将是 <code>a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3]</code> 的值。</p>
<p>返回你能够获得的 <strong>最大</strong> 得分。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> a = [3,2,5,6], b = [2,-6,4,-5,-3,2,-7]</p>
<p><strong>输出：</strong> 26</p>
<p><strong>解释：</strong>
选择下标 0, 1, 2 和 5。得分为 <code>3 * 2 + 2 * (-6) + 5 * 4 + 6 * 2 = 26</code>。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> a = [-1,4,5,-2], b = [-5,-1,-3,-2,-4]</p>
<p><strong>输出：</strong> -1</p>
<p><strong>解释：</strong>
选择下标 0, 1, 3 和 4。得分为 <code>(-1) * (-5) + 4 * (-1) + 5 * (-2) + (-2) * (-4) = -1</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>a.length == 4</code></li>
<li><code>4 &lt;= b.length &lt;= 10^5</code></li>
<li><code>-10^5 &lt;= a[i], b[i] &lt;= 10^5</code></li>
</ul>
<h2 id="思路-25">思路<a hidden class="anchor" aria-hidden="true" href="#思路-25">#</a></h2>
<p>我们需要从数组 <code>b</code> 中选出一个长度为 4 的子序列，将其与数组 <code>a</code> 对应相乘，得到最大值。</p>
<p><strong>从右往左思考</strong>，我们以<code>a=[3,2,5,6], b=[2,−6,4,−5,−3,2,−7]</code> 为例。</p>
<p>从数组 <code>b</code> 的最右边开始，考虑选或不选 <code>b[6]</code> ：</p>
<ul>
<li>选 <code>b[6]</code> ，那么问题就转换成从 <code>b[0]</code> 到 <code>b[5]</code> 选 <strong>3</strong> 个数，使得最后结果最大；</li>
<li>不选 <code>b[6]</code> ，那么问题就转换成从 <code>b[0]</code> 到 <code>b[5]</code> 选 <strong>4</strong> 个数，使得最后结果最大；</li>
</ul>
<p>考虑选或不选，可以将原问题转换成规模更小的相似的子问题。</p>
<p>我们定义：<code>dp[i][j]</code> 表示从 <code>b[0]</code> 到 <code>b[i]</code> 选 <code>j + 1</code> 个数得到的最大值，基于上面的分析，有：</p>
<ul>
<li>不选 <code>b[i]</code> ，那么只需要考虑从 <code>b[0]</code> 到 <code>b[i-1]</code> 的最大值：<code>dp[i][j] = dp[i-1][j]</code>；</li>
<li>选 <code>b[i]</code> ，那么需要考虑从 <code>b[0]</code> 到 <code>b[i-1]</code> 中选 <code>j</code> 个数得到的最大值：<code>dp[i][j] = dp[i-1][j-1] + b[i] * a[j]</code></li>
</ul>
<p>两者取最大值（表示选或不选）：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + b[i] * a[j])</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> maxScore(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> b.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">++</span>j) dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> LLONG_MIN <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], dp[i][j] <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>) a[j] <span style="color:#f92672">*</span> b[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n][<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="27坐上公交的最晚时间">27.坐上公交的最晚时间<a hidden class="anchor" aria-hidden="true" href="#27坐上公交的最晚时间">#</a></h1>
<p>链接：<a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/description/">2332. 坐上公交的最晚时间 - 力扣（LeetCode）</a></p>
<p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>buses</code> ，其中 <code>buses[i]</code> 表示第 <code>i</code> 辆公交车的出发时间。同时给你一个下标从 <strong>0</strong> 开始长度为 <code>m</code> 的整数数组 <code>passengers</code> ，其中 <code>passengers[j]</code> 表示第 <code>j</code> 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>
<p>给你一个整数 <code>capacity</code> ，表示每辆公交车 <strong>最多</strong> 能容纳的乘客数目。</p>
<p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code> 时刻到达，公交在 <code>x</code> 时刻出发，满足 <code>y &lt;= x</code> 且公交没有满，那么你可以搭乘这一辆公交。<strong>最早</strong> 到达的乘客优先上车。</p>
<p>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong>不能</strong> 跟别的乘客同时刻到达。</p>
<p>**注意：**数组 <code>buses</code> 和 <code>passengers</code> 不一定是有序的。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2
输出：16
解释：
第 1 辆公交车载着第 1 位乘客。
第 2 辆公交车载着你和第 2 位乘客。
注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
输出：20
解释：
第 1 辆公交车载着第 4 位乘客。
第 2 辆公交车载着第 6 位和第 2 位乘客。
第 3 辆公交车载着第 1 位乘客和你。
</code></pre><h2 id="思路-26">思路<a hidden class="anchor" aria-hidden="true" href="#思路-26">#</a></h2>
<p>要得到能坐上公交的最晚时间，可以从后往前思考。</p>
<p>由于原数组不一定有序，我们先对两个数组分别进行排序。</p>
<ol>
<li>首先模拟当前所有乘客都上车的过程；</li>
<li>然后从后往前思考，从最后一辆车开始，寻找能<strong>插队</strong>的位置：
<ul>
<li>对于最后一辆车，假如所有乘客上车后仍然有空位，我们可以卡在<strong>最后一辆车发车的时间点</strong>上车；</li>
<li>如果没有空位，那么就<strong>往前找</strong>，看有哪个时间点是没有乘客上车的，我们在这个时间点上车，<strong>把后面的乘客挤下去（插队）</strong></li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> latestTimeCatchTheBus(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> buses, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> passengers, <span style="color:#66d9ef">int</span> capacity) {
</span></span><span style="display:flex;"><span>        ranges<span style="color:#f92672">::</span>sort(buses);
</span></span><span style="display:flex;"><span>        ranges<span style="color:#f92672">::</span>sort(passengers);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 模拟上车
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, c;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> t: buses) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (c <span style="color:#f92672">=</span> capacity; c <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> passengers.size() <span style="color:#f92672">&amp;&amp;</span> passengers[j] <span style="color:#f92672">&lt;=</span> t; <span style="color:#f92672">--</span>c) {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">++</span>j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 模拟插队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">--</span>j;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断最后一辆车是否有空位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> c <span style="color:#f92672">?</span> buses.back() <span style="color:#f92672">:</span> passengers[j];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 往前找插队的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ans <span style="color:#f92672">==</span> passengers[j]) {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">--</span>ans;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">--</span>j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="28适龄的朋友滑动窗口">28.适龄的朋友(滑动窗口)<a hidden class="anchor" aria-hidden="true" href="#28适龄的朋友滑动窗口">#</a></h1>
<p>在社交媒体网站上有 <code>n</code> 个用户。给你一个整数数组 <code>ages</code> ，其中 <code>ages[i]</code> 是第 <code>i</code> 个用户的年龄。</p>
<p>如果下述任意一个条件为真，那么用户 <code>x</code> 将不会向用户 <code>y</code>（<code>x != y</code>）发送好友请求：</p>
<ul>
<li><code>ages[y] &lt;= 0.5 * ages[x] + 7</code></li>
<li><code>ages[y] &gt; ages[x]</code></li>
<li><code>ages[y] &gt; 100 &amp;&amp; ages[x] &lt; 100</code></li>
</ul>
<p>否则，<code>x</code> 将会向 <code>y</code> 发送一条好友请求。</p>
<p>注意，如果 <code>x</code> 向 <code>y</code> 发送一条好友请求，<code>y</code> 不必也向 <code>x</code> 发送一条好友请求。另外，用户不会向自己发送好友请求。</p>
<p>返回在该社交媒体网站上产生的好友请求总数。</p>
<p><strong>示例 1：</strong></p>
<pre tabindex="0"><code>输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。
</code></pre><p><strong>示例 2：</strong></p>
<pre tabindex="0"><code>输入：ages = [16,17,18]
输出：2
解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。
</code></pre><p><strong>示例 3：</strong></p>
<pre tabindex="0"><code>输入：ages = [20,30,100,110,120]
输出：3
解释：产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。
</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>n == ages.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
<li><code>1 &lt;= ages[i] &lt;= 120</code></li>
</ul>
<p><strong>思路</strong></p>
<p>将原有的三个条件改写，当<strong>同时满足</strong>下面的条件时， x 向 y 发送好友请求：</p>
<ul>
<li><code>0.5 * ages[x] + 7 &lt; ages[y] &lt;= ages[x]</code></li>
<li><code>x != y</code></li>
</ul>
<p>注意到，如果第一个条件中的 <code>ages[y] &lt;= ages[x]</code> 成立，那么题目中的第三个条件按必定不成立。</p>
<p>我们用一个长为 121 的 cnt 数组统计每个年龄的人数。</p>
<p>枚举年龄 <code>ageX</code> ，我们需要知道：</p>
<ul>
<li>可以发送好友请求的最小年龄 <code>ageY</code> 是多少</li>
<li>年龄在 <code>[ageY, ageX]</code> 中的人数</li>
</ul>
<p>由于 <code>ageX</code> 越大，<code>ageY</code> 也越大，可以考虑<strong>滑动窗口</strong>。我们维护 <code>[ageY, ageX]</code> 中的人数 <code>cnt_window</code> ，如果 <code>cnt_window &gt; 0</code> ，说明存在可以发送好友请求的用户：</p>
<ul>
<li>当前 <code>cnt[ageX]</code> 个用户可以与 <code>cnt_window</code> 个用户发送好友请求，那么总共有 <code>cnt[ageX] * cnt_window</code> 个请求</li>
<li>其中有 <code>cnt[ageX]</code> 个好友请求是自己发给自己的，需要减去</li>
</ul>
<p>所以将 <code>cnt[ageX] * cnt_window - cnt[ageX]</code> 加入答案</p>
<p><strong>Code</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numFriendRequests(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> ages) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt[<span style="color:#ae81ff">121</span>]{};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> age: ages) cnt[age]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> age_y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, cnt_window <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> age_x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; age_x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">121</span>; <span style="color:#f92672">++</span>age_x) {
</span></span><span style="display:flex;"><span>            cnt_window <span style="color:#f92672">+=</span> cnt[age_x];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> age_y <span style="color:#f92672">&lt;=</span> age_x <span style="color:#f92672">+</span> <span style="color:#ae81ff">14</span>) {
</span></span><span style="display:flex;"><span>                cnt_window <span style="color:#f92672">-=</span> cnt[age_y];
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">++</span>age_y;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cnt_window <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">+=</span> cnt_window <span style="color:#f92672">*</span> cnt[age_x] <span style="color:#f92672">-</span> cnt[age_x];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">YUKIPEDIA&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
