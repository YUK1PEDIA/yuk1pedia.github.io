+++
date = '2024-08-09'
draft = false
title = '动态规划-买卖股票问题'
summary = ' '
+++

## 买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`



### 思路

两个思路，可以用 dp 也可以用贪心。

- dp 做法
  - 定义状态： `dp[i][0]` 表示第 `i` 天持有股票的最大利润，`dp[i][1]` 表示第 `i` 天不持有股票的最大利润（**注意此处持有表示拥有股票，并不一定指当天买入股票**）
  - 状态转移
    - 如果当天持有股票，就有两种情况：
      - 前一天就持有了股票，直接由前一天转移过来：`dp[i][0] = dp[i-1][0]`
      - 前一天并不持有股票，我们需要在当天购买股票：`dp[i][0] = -prices[i]` （**因为只能买卖一次股票，买入股票就一定是 `-prices[i]` 的利润**）
      - 在以上两种情况取最大值即可：` dp[i][0] = max(dp[i-1][0], -prices[i]);`
    - 如果当天不持有股票，也有两种情况：
      - 前一天就不持有股票：`dp[i][1] = dp[i-1][1]`
      - 前一天持有股票，这一天卖出：`dp[i][1] = dp[i-1][0] + prices[i]`
      - 两种情况取最大：`dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);`
  - 边界定义
    - 初始化第 0 天即可

代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][2]; // dp[i][0]表示第 i 天持有的最大利润，dp[i][1]表示第 i 天不持有的最大利润
        dp[0][0] = -prices[0], dp[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};
```



- 贪心做法
  - 遍历一次，实时更新最小值与答案

代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int minn =INT_MAX, ans = 0;
        for (int i = 0; i < n; ++i) {
            minn = min(minn, prices[i]);
            ans = max(prices[i] - minn, ans);
        }
        return ans;
    }
};
```







## 买卖股票的最佳时机Ⅱ

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`



### 思路

本题的状态转移方程其实和上一题基本一致，唯一区别就在于本题的股票可以买卖多次，所以买入股票的时候，第 `i` 天持有股票的利润就是：`dp[i][0] = dp[i-1][1] - prices[i]`

代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // dp[i][0]表示第 i 天持有股票，dp[i][1]表示第 i 天不持有股票
        auto dp = vector<vector<int>> (n, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};
```





## 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^5`



### 思路

这里加了个**最多完成两笔交易**的限制，意味着可以买卖一次、买卖两次，也可以不买卖。我们可以增加两个状态来区分第一次买卖和第二次买卖，具体可以看下面的代码。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (!n) return 0;
        // dp[i][0]表示第 i 天第一次持有，1 表示第一次不持有，2表示第二次持有，3表示第二次不持有
        auto dp = vector<vector<int>>(n, vector<int>(4));
        dp[0][0] = dp[0][2] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);
        }
        return dp[n-1][3];
    }
};
```

**需要注意：`dp[i][1]` ，表示的是第 `i` 天，买入股票的状态，并不是说⼀定要第 `i` 天买⼊股票。例如 `dp[i][1]` ，并不是说 第 `i` 天⼀定买入股票，有可能 第 i-1天 就买入了，那么 `dp[i][1]` 延续买入股票的这个状态。**







## 买卖股票的最佳时机Ⅳ

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `1 <= k <= 100`
- `1 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`



### 思路

和**买卖股票的最佳时机Ⅲ**类似，这里要求最多进行 `k` 次交易，那么我们就定义相应 `2*k+1` 个状态就可以了，这里多出来一个状态表示的**“不操作”**这个状态，这样的话，除了 `0` 以外，**偶数就是卖出，奇数就是买入**， `dp` 数组的定义和母题是一样的。

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if (!n) return 0;
        auto dp = vector<vector<int>>(n, vector<int>(2*k+1, 0));
        // 第 0 天买入一定是初始化为 -prices[0] （当天买当天卖）
        for (int j = 1; j < 2*k; j += 2) dp[0][j] = -prices[0];
        // 遍历每一天
        for (int i = 1; i < n; ++i)
            for (int j = 0; j < 2*k-1; j += 2) {
                // j+1 为奇数，表示买，j 为偶数，表示卖
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]);
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]);
            }
        return dp[n-1][2*k];
    }
};
```







## 最佳买卖股票时机含冷冻期

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

 

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`



### 思路

出现**冷冻期**后，状态的定义就比较复杂了，例如今天买⼊股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。

具体可以区分出四种状态：

- **状态⼀**：持有股票状态（今天买⼊股票，或者是之前就买⼊了股票然后没有操作，⼀直持有）

- 不持有股票状态，这⾥就有两种卖出股票状态

  - **状态⼆**：保持卖出股票的状态（两天前就卖出了股票，度过⼀天冷冻期。或者是前⼀天就是卖出股票状

    态，⼀直没操作）

  - **状态三**：今天卖出股票

- **状态四**：今天为冷冻期状态

明确状态后就可以开始找状态转移了，具体看如下代码：

```c++
/**
总共四种状态：0 表示今天保持持有、1 表示今天保持卖出、2 表示今天卖出、3表示今天冷冻期
**/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (!n) return 0;
        auto dp =vector<vector<int>>(n, vector<int>(4)); // 定义四种状态
        dp[0][0] = -prices[0]; // 初始化
        // 遍历每一天
        for (int i = 1; i < n; ++i) {
            // 当天持有状态可以从：1.前一天持有；2.前一天冷冻期，当天买入；
            // 3.前一天保持卖出（注意是保持卖出，不是卖出），今天买入这几种情况推导过来
            dp[i][0] = max({dp[i-1][0], dp[i-1][3] - prices[i], dp[i-1][1] - prices[i]});
            // 当天保持卖出可以从：1.前一天保持卖出；2.前一天冷冻期（大前天卖出）这两种情况推导过来
            dp[i][1] = max(dp[i-1][1], dp[i-1][3]);
            // 当天卖出前一天必须持有
            dp[i][2] = dp[i-1][0] + prices[i];
            // 当天冷冻期前一天必须卖出
            dp[i][3] = dp[i-1][2];
        }
        // 想要最大利润，最后一天必不能持有，返回最后一天剩余三种情况的最大值即可
        return max({dp[n-1][3], dp[n-1][2], dp[n-1][1]});
    }
};
```





## 买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

**示例 2：**

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

 

**提示：**

- `1 <= prices.length <= 5 * 10^4`
- `1 <= prices[i] < 5 * 10^4`
- `0 <= fee < 5 * 10^4`



### 思路

本题和**买卖股票的最佳时机Ⅱ**就是多了个减去手续费的操作

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        // dp[i][0]表示第 i 天持有股票，dp[i][1]表示第 i 天不持有股票
        auto dp = vector<vector<int>> (n, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};
```

