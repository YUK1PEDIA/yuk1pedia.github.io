<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="Docker - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/notes/2024-10-8-docker/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/notes/2024-10-8-docker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/notes/2024-10-8-docker/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="Docker"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2024-10-08T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yuk1pedia.github.io/notes/"},{"@type":"ListItem","position":2,"name":"Docker","item":"https://yuk1pedia.github.io/notes/2024-10-8-docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker","name":"Docker","description":"","keywords":[],"articleBody":"1.镜像和容器 利用 Docker 安装应用时，Docker 会自动搜索并下载应用镜像（image）。镜像不仅包含应用本身，还包含应用所需要的环境、配置、系统函数库（此处的环境是最轻量的，只包含容器内运行需要的环境，其他编辑操作可能包含）。Docker 会在运行镜像时创建一个隔离环境，称为容器（container）。\n镜像仓库：存储和管理镜像的平台，Docker 官方维护了一个公共仓库：https://hub.docker.com/\n2.命令解读 docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql docker run ：创建并运行一个容器，-d 是让容器在后台运行。 --name mysql ：给容器起个名字，必须唯一。 -p 3306:3306 ：设置端口映射，docker 创建的容器拥有独立的文件系统、内存、网络空间等，从外部直接对 docker 容器进行 ping 操作是 ping 不通的，需要设置服务器或虚拟机的端口映射，才能通过服务器或虚拟机访问到上面的 docker 容器。冒号前面的端口是宿主机端口，冒号后面是容器内端口。 -e KEY=VALUE ：设置环境变量。上面的命令中，TZ=Asia/Shanghai 是配置时区 mysql ：指定运行的镜像的名字 补充：镜像命名规范\n镜像名称一般分两部分组成：[repository]:[tag] 其中 repository 就是镜像名 tag 是镜像的版本 在没有指定 tag 时，默认是 latest ，代表最新版本的镜像 3.常见命令 docker rmi 是删除镜像，docker rm 是删除容器 docker run 是创建并运行容器，这条命令会创建一个新的容器，如果要启动已经有的容器，需要执行 docker start 命令 docker exec 是进入到容器内部 4.数据卷挂载 数据卷挂载 数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。\n在执行 docker run 命令时，使用 -v 数据卷:容器内目录 可以完成数据卷挂载\n例：docker run -d --name nginx -p 80:80 -v html:/user/share/nginx/html nginx\n当创建容器时，如果挂载了数据卷且数据卷不存在，会自动创建数据卷\n数据卷挂载后，我们可以直接在宿主机进行文件的编辑操作，不用进入到容器中下载需要的编辑工具再对文件进行编辑。\n数据卷的常见命令如下：\ndocker volume ls ：查看数据卷 docker volume rm ：删除数据卷 docker volume inspect ：查看数据卷详情 docker volume prune ：删除未使用的数据卷 本地挂载 我们进行数据卷挂载时，可以不通过数据卷名称进行挂载。\n只用将之前的 docker run 命令里的 -v 数据卷:容器内目录 换成 -v 本地目录:容器内目录 即可完成本地目录挂载\n本地目录必须以 “/” 或 “./” 开头，如果直接以名称开头，会被识别为数据卷而非本地目录 -v mysql:/var/lib/mysql 会被识别为一个数据卷叫 mysql -v ./mysql:/var/lib/mysql 会被识别为当前目录下的 mysql 目录 5.自定义镜像 镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。\nDockerfile Dockerfile是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。将来 Docker 可以根据 Dockerfile 帮我们构建镜像。常见指令如下：\n指令 说明 示例 FROM 指定基础镜像 FROM centos:6 ENV 设置环境变量，可在后面指令使用 ENV key value COPY 拷贝本地文件到镜像的指定目录 COPY ./jrell.tar.gz /tmp RUN 执行 Linux 的 shell 命令，一般是安装过程的命令 RUN tar -zxvf /tmp/jrell.tar.gz \u0026\u0026 EXPORTS path=/tmp/jrell:$path EXPOSE 指定容器运行时监听的端口，是给镜像使用者看的 EXPOSE 8080 ENTRYPOINT 镜像中应用的启动命令，启动运行时调用 ENTRYPOINT java -jar xx.jar 编写好了 Dockerfile ，可以利用下面命令来构建镜像：\ndocker build -t myImage:1.0 .\n-t ：是给镜像起名，格式依然是 repository:tag 的格式，不指定 tag 时，默认为 latest . ：是指定 Dockerfile 所在目录，如果就在当前目录，则指定为 “.” 6.容器网络互连 ","wordCount":"212","inLanguage":"en","datePublished":"2024-10-08T00:00:00Z","dateModified":"2024-10-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuk1pedia.github.io/notes/2024-10-8-docker/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yuk1pedia.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Docker</h1><div class=post-meta><span title='2024-10-08 00:00:00 +0000 UTC'>October 8, 2024</span></div></header><div class=post-content><h2 id=1镜像和容器>1.镜像和容器<a hidden class=anchor aria-hidden=true href=#1镜像和容器>#</a></h2><p>利用 Docker 安装应用时，Docker 会自动搜索并下载应用<strong>镜像（image）</strong>。镜像不仅包含应用本身，还包含应用所需要的环境、配置、系统函数库（此处的环境是<strong>最轻量的</strong>，只包含容器内运行需要的环境，其他编辑操作可能包含）。Docker 会在运行镜像时创建一个隔离环境，称为<strong>容器（container）</strong>。</p><p><strong>镜像仓库</strong>：存储和管理镜像的平台，Docker 官方维护了一个公共仓库：https://hub.docker.com/</p><h2 id=2命令解读>2.命令解读<a hidden class=anchor aria-hidden=true href=#2命令解读>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span>docker run -d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	--name mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	-p 3306:3306 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	-e TZ<span style=color:#f92672>=</span>Asia/Shanghai <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	-e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>	mysql<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li><code>docker run</code> ：创建并运行一个容器，<strong>-d</strong> 是让容器在后台运行。</li><li><code>--name mysql</code> ：给容器起个名字，<strong>必须唯一</strong>。</li><li><code>-p 3306:3306</code> ：设置端口映射，docker 创建的容器拥有独立的文件系统、内存、网络空间等，从外部直接对 docker 容器进行 ping 操作是 ping 不通的，需要设置服务器或虚拟机的端口映射，才能通过服务器或虚拟机访问到上面的 docker 容器。<strong>冒号前面的端口是宿主机端口，冒号后面是容器内端口</strong>。</li><li><code>-e KEY=VALUE</code> ：设置环境变量。上面的命令中，<code>TZ=Asia/Shanghai</code> 是配置时区</li><li><code>mysql</code> ：指定运行的镜像的名字</li></ul><p><strong>补充：镜像命名规范</strong></p><ul><li>镜像名称一般分两部分组成：<code>[repository]:[tag]</code><ul><li>其中 <em>repository</em> 就是镜像名</li><li><em>tag</em> 是镜像的版本</li></ul></li><li>在没有指定 <em>tag</em> 时，默认是 <em>latest</em> ，代表最新版本的镜像</li></ul><h2 id=3常见命令>3.常见命令<a hidden class=anchor aria-hidden=true href=#3常见命令>#</a></h2><p><img alt=1.jpg loading=lazy src=https://s2.loli.net/2024/10/08/SzMIaOdynwvUPQh.jpg></p><ul><li><code>docker rmi</code> 是删除镜像，<code>docker rm</code> 是删除容器</li><li><code>docker run</code> 是<strong>创建并运行容器</strong>，这条命令会创建一个新的容器，如果要启动已经有的容器，需要执行 <code>docker start</code> 命令</li><li><code>docker exec</code> 是进入到容器内部</li></ul><h2 id=4数据卷挂载>4.数据卷挂载<a hidden class=anchor aria-hidden=true href=#4数据卷挂载>#</a></h2><h3 id=数据卷挂载>数据卷挂载<a hidden class=anchor aria-hidden=true href=#数据卷挂载>#</a></h3><p><strong>数据卷（volume）<strong>是一个虚拟目录，是</strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p><p><img alt=1.jpg loading=lazy src=https://s2.loli.net/2024/10/08/sG4LVg3XIKkTiBF.jpg></p><ul><li><p>在执行 <code>docker run</code> 命令时，使用 <code>-v 数据卷:容器内目录</code> 可以完成数据卷挂载</p><p>例：<code>docker run -d --name nginx -p 80:80 -v html:/user/share/nginx/html nginx</code></p></li><li><p>当创建容器时，如果挂载了数据卷且数据卷不存在，会自动创建数据卷</p></li></ul><p>数据卷挂载后，我们<strong>可以直接在宿主机进行文件的编辑操作</strong>，不用进入到容器中下载需要的编辑工具再对文件进行编辑。</p><p>数据卷的常见命令如下：</p><ul><li><code>docker volume ls</code> ：查看数据卷</li><li><code>docker volume rm</code> ：删除数据卷</li><li><code>docker volume inspect</code> ：查看数据卷详情</li><li><code>docker volume prune</code> ：删除未使用的数据卷</li></ul><h3 id=本地挂载>本地挂载<a hidden class=anchor aria-hidden=true href=#本地挂载>#</a></h3><p>我们进行数据卷挂载时，可以不通过数据卷名称进行挂载。</p><p>只用将之前的 <code>docker run</code> 命令里的 <code>-v 数据卷:容器内目录</code> 换成 <code>-v 本地目录:容器内目录</code> 即可完成本地目录挂载</p><ul><li>本地目录必须以 &ldquo;/&rdquo; 或 &ldquo;./&rdquo; 开头，<strong>如果直接以名称开头，会被识别为数据卷而非本地目录</strong><ul><li><code>-v mysql:/var/lib/mysql</code> 会被识别为一个数据卷叫 <em>mysql</em></li><li><code>-v ./mysql:/var/lib/mysql</code> 会被识别为当前目录下的 <code>mysql</code> 目录</li></ul></li></ul><h2 id=5自定义镜像>5.自定义镜像<a hidden class=anchor aria-hidden=true href=#5自定义镜像>#</a></h2><p>镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。</p><h3></h3><h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3><p>Dockerfile是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。将来 Docker 可以根据 Dockerfile 帮我们构建镜像。常见指令如下：</p><table><thead><tr><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td><td>FROM centos:6</td></tr><tr><td>ENV</td><td>设置环境变量，可在后面指令使用</td><td>ENV key value</td></tr><tr><td>COPY</td><td>拷贝本地文件到镜像的指定目录</td><td>COPY ./jrell.tar.gz /tmp</td></tr><tr><td>RUN</td><td>执行 Linux 的 shell 命令，一般是安装过程的命令</td><td>RUN tar -zxvf /tmp/jrell.tar.gz && EXPORTS path=/tmp/jrell:$path</td></tr><tr><td>EXPOSE</td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td>EXPOSE 8080</td></tr><tr><td>ENTRYPOINT</td><td>镜像中应用的启动命令，启动运行时调用</td><td>ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p><img alt=1.jpg loading=lazy src=https://s2.loli.net/2024/10/08/MRIDxjaAP7ztBQK.jpg></p><p>编写好了 Dockerfile ，可以利用下面命令来构建镜像：</p><p><code>docker build -t myImage:1.0 .</code></p><ul><li><code>-t</code> ：是给镜像起名，格式依然是 <code>repository:tag</code> 的格式，不指定 <em>tag</em> 时，默认为 <em>latest</em></li><li><code>.</code> ：是指定 Dockerfile 所在目录，如果就在当前目录，则指定为 &ldquo;.&rdquo;</li></ul><h2 id=6容器网络互连>6.容器网络互连<a hidden class=anchor aria-hidden=true href=#6容器网络互连>#</a></h2><p><img alt=1.jpg loading=lazy src=https://s2.loli.net/2024/10/08/n1MKjAk87w6LHEa.jpg></p><p><img alt=1.jpg loading=lazy src=https://s2.loli.net/2024/10/08/J5kC8m6wjELIdor.jpg></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>