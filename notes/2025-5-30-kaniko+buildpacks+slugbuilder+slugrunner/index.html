<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>kaniko 与 buildpacks, slugbuilder, slugrunner | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="kaniko 与 buildpacks, slugbuilder, slugrunner - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yukipedia.cn/notes/2025-5-30-kaniko+buildpacks+slugbuilder+slugrunner/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/notes/2025-5-30-kaniko+buildpacks+slugbuilder+slugrunner/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/notes/2025-5-30-kaniko+buildpacks+slugbuilder+slugrunner/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="kaniko 与 buildpacks, slugbuilder, slugrunner"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="kaniko 与 buildpacks, slugbuilder, slugrunner"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yukipedia.cn/notes/"},{"@type":"ListItem","position":2,"name":"kaniko 与 buildpacks, slugbuilder, slugrunner","item":"https://yukipedia.cn/notes/2025-5-30-kaniko+buildpacks+slugbuilder+slugrunner/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kaniko 与 buildpacks, slugbuilder, slugrunner","name":"kaniko 与 buildpacks, slugbuilder, slugrunner","description":"","keywords":[],"articleBody":"kaniko 什么是 kaniko？ 学习 kaniko 之前，先要了解什么是 docker daemon docker daemon（docker 守护进程） 是 docker 的核心后台服务，在后台管理所有与容器相关的事情 比如：\n镜像管理：下载、存储、构建镜像（docker pull） 容器生命周期：创建、启动、停止、删除容器（docker run / stop / rm） 资源分配：给容器分配 cpu、内存等 网络和存储：管理容器的网络连接和文件存储 举个例子，当我们运行 docker build 时，表面上是我们输入了 build 命令，实际上是 docker cli 把构建请求发送给 docker daemon，之后 daemon 读取 dockerfile，下载基础镜像，执行每一层指令，生成最终镜像，全程由 daemon 在后台完成\n了解 docker daemon 后，再了解什么是 kaniko：\nkaniko 是 Google 推出的容器工具，主要目的是在 避免使用 docker daemon 的前提下，根据 dockerfile 构建 docker 镜像，适用于在 容器内 / k8s 集群中构建镜像\n一般来说，docker daemon 默认运行在宿主机上。如果想在 docker 容器中进行镜像的构建，就需要在容器内运行一个独立的 docker daemon，也就是 Docker-in-Docker(DinD)，使容器具备完整的构建能力 或者，可以将宿主机的 docker daemon 套接字挂载到容器内，容器直接调用宿主机的 daemon 构建镜像 为什么需要 kaniko docker 构建镜像是 daemon-based 的，强依赖于宿主机上的 docker daemon 并且需要 特权模式，这对于强调 隔离性和安全 的云原生来说是不太能接受的，因此需要一种能够不使用 docker daemon 就可以构建容器镜像的方式，也就是 kaniko 存在的原因。\n安全性：\n传统的 docker build 必须用到宿主机的资源，包括 root 权限或 docker 用户组权限、挂载 /var/run/docker.sock，如果出现漏洞或者恶意操作，宿主机就可能被入侵。\n而 kaniko 可以在非特权容器（无需 –privileged）中构建镜像，保证了安全问题\n隔离性：\n传统的 docker 必须通过宿主机的 docker daemon 执行构建，存在权限相关问题 kaniko 完全在 用户空间 模拟 docker 构建流程，无需特权权限，彻底隔离了宿主机敏感资源 buildpacks, slugbuilder, slugrunner 什么是 buildpacks？ buildpacks 是一种自动化构建工具，用于将应用程序源代码转化为可运行的容器镜像，然后上传到制品库中，无需手动编写 dockerfile。并且 buildpacks 可以将源代码构建为符合 OCI 规范的镜像。\nbuildpacks 如何工作？ CNB(Cloud Native Buildpacks) 主要由 3 个组件组成：Builder、Buildpack 和 Stack\nBuildpack 本质是一个可执行单元的集合，负责监测代码类型并完成构建，比如：\ndetect 脚本检查代码特征，比如发现 pom.xml 则判定为 Java 项目 build 脚本负责安装依赖、编译代码，生成可运行的应用层 每个 buildpack 专注一种语言，多个 buildpack 可组合使用 Builder buildpacks 会通过 “检测”、“构建”、“输出” 完成一个构建逻辑，为了完成一个应用的构建，通常会使用到多个 buildpacks，那么 builder 就相当于一个 “构建工厂”，负责 将应用源代码构建成应用镜像，builder 中包含：\n多个有序的 buildpack（比如先 Java 后 Node.js） 基础环境镜像 Lifecycle（检测、构建、导出镜像） Stack build image 为 Builders 提供基础环境（比如带 maven 的 Ubuntu 镜像），run image 在运行时为应用镜像提供基础环境，Stack 就是这两者的组合。\n工作流程 belike 以 Django 项目为例：\n检测阶段（Detect）：\nBuilder 中的每个 Buildpack 依次检查代码：\nPython Buildpack 发现 requirement.txt，标记自己为 “适用” Django Buildpack 进一步检测 manage.py 或 settings.py，确认 Django 框架存在 其他 Buildpack 若未检测到特征，比如 Node.js 未检测到 package.json，则跳过 构建阶段（Build） 依赖安装\n根据 requirement.txt 安装 python 依赖，缓存到独立层（避免重复下载） 自动创建激活虚拟环境 静态文件处理 运行 python manage.py collectstatic 收集静态文件 数据库迁移 运行 python manage.py migrate 生成数据库迁移文件 启动配置 设置环境变量，生成启动命令 导出镜像（Export）\nLifecycle 将所有层（依赖、静态文件、编译结果）与 run image 合并 生成符合 OCI 规范的最终镜像 镜像自动继承 run image 的安全补丁 slugbuilder, slugrunner slugbuilder builder 的一种，slugbuilder 会在基础的 heroku runner 镜像上加层，最后组成一个完整的可运行的镜像。\nslugbuilder 是镜像构建阶段的基础环境，通过顺序执行多个 buildpack 将应用源代码构建成镜像层\nslugrunner slugrunner 是应用运行阶段的基础环境，用于承载构建阶段的产物，组成可以最终运行的容器镜像 ","wordCount":"269","inLanguage":"en","datePublished":"2025-05-30T00:00:00Z","dateModified":"2025-05-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/notes/2025-5-30-kaniko+buildpacks+slugbuilder+slugrunner/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">kaniko 与 buildpacks, slugbuilder, slugrunner</h1><div class=post-meta><span title='2025-05-30 00:00:00 +0000 UTC'>May 30, 2025</span></div></header><div class=post-content><h1 id=kaniko>kaniko<a hidden class=anchor aria-hidden=true href=#kaniko>#</a></h1><h2 id=什么是-kaniko>什么是 kaniko？<a hidden class=anchor aria-hidden=true href=#什么是-kaniko>#</a></h2><p>学习 kaniko 之前，先要了解什么是 docker daemon
docker daemon（docker 守护进程） 是 docker 的核心后台服务，在后台管理所有与容器相关的事情
比如：</p><ol><li>镜像管理：下载、存储、构建镜像（<code>docker pull</code>）</li><li>容器生命周期：创建、启动、停止、删除容器（<code>docker run / stop / rm</code>）</li><li>资源分配：给容器分配 cpu、内存等</li><li>网络和存储：管理容器的网络连接和文件存储</li></ol><p>举个例子，当我们运行 <code>docker build</code> 时，表面上是我们输入了 build 命令，实际上是 docker cli 把构建请求发送给 docker daemon，之后 daemon 读取 dockerfile，下载基础镜像，执行每一层指令，生成最终镜像，全程由 daemon 在后台完成</p><p>了解 docker daemon 后，再了解什么是 kaniko：</p><p>kaniko 是 Google 推出的容器工具，主要目的是在 <strong>避免使用 docker daemon 的前提下，根据 dockerfile 构建 docker 镜像</strong>，适用于在 容器内 / k8s 集群中构建镜像</p><ul><li>一般来说，docker daemon 默认运行在宿主机上。如果想在 docker 容器中进行镜像的构建，就需要在容器内运行一个独立的 docker daemon，也就是 Docker-in-Docker(DinD)，使容器具备完整的构建能力</li><li>或者，可以将宿主机的 docker daemon 套接字挂载到容器内，容器直接调用宿主机的 daemon 构建镜像</li></ul><h2 id=为什么需要-kaniko>为什么需要 kaniko<a hidden class=anchor aria-hidden=true href=#为什么需要-kaniko>#</a></h2><p>docker 构建镜像是 daemon-based 的，强依赖于宿主机上的 docker daemon 并且需要 <strong>特权模式</strong>，这对于强调 <strong>隔离性和安全</strong> 的云原生来说是不太能接受的，因此需要一种能够不使用 docker daemon 就可以构建容器镜像的方式，也就是 kaniko 存在的原因。</p><ul><li><p>安全性：</p><ul><li><p>传统的 <code>docker build</code> 必须用到宿主机的资源，包括 root 权限或 docker 用户组权限、挂载 /var/run/docker.sock，如果出现漏洞或者恶意操作，宿主机就可能被入侵。</p></li><li><p>而 kaniko 可以在非特权容器（无需 &ndash;privileged）中构建镜像，保证了安全问题</p></li></ul></li><li><p>隔离性：</p><ul><li>传统的 docker 必须通过宿主机的 docker daemon 执行构建，存在权限相关问题</li><li>kaniko 完全在 用户空间 模拟 docker 构建流程，无需特权权限，彻底隔离了宿主机敏感资源</li></ul></li></ul><h1 id=buildpacks-slugbuilder-slugrunner>buildpacks, slugbuilder, slugrunner<a hidden class=anchor aria-hidden=true href=#buildpacks-slugbuilder-slugrunner>#</a></h1><h2 id=什么是-buildpacks>什么是 buildpacks？<a hidden class=anchor aria-hidden=true href=#什么是-buildpacks>#</a></h2><p>buildpacks 是一种自动化构建工具，用于将应用程序源代码转化为可运行的容器镜像，然后上传到制品库中，无需手动编写 dockerfile。并且 buildpacks 可以将源代码构建为符合 OCI 规范的镜像。</p><h2 id=buildpacks-如何工作>buildpacks 如何工作？<a hidden class=anchor aria-hidden=true href=#buildpacks-如何工作>#</a></h2><p>CNB(Cloud Native Buildpacks) 主要由 3 个组件组成：<strong>Builder、Buildpack 和 Stack</strong></p><h3 id=buildpack>Buildpack<a hidden class=anchor aria-hidden=true href=#buildpack>#</a></h3><p>本质是一个可执行单元的集合，负责监测代码类型并完成构建，比如：</p><ul><li>detect 脚本检查代码特征，比如发现 pom.xml 则判定为 Java 项目</li><li>build 脚本负责安装依赖、编译代码，生成可运行的应用层</li><li>每个 buildpack 专注一种语言，多个 buildpack 可组合使用</li></ul><h3 id=builder>Builder<a hidden class=anchor aria-hidden=true href=#builder>#</a></h3><p>buildpacks 会通过 “检测”、“构建”、“输出” 完成一个构建逻辑，为了完成一个应用的构建，通常会使用到多个 buildpacks，那么 builder 就相当于一个 “构建工厂”，负责 <strong>将应用源代码构建成应用镜像</strong>，builder 中包含：</p><ul><li>多个有序的 buildpack（比如先 Java 后 Node.js）</li><li>基础环境镜像</li><li>Lifecycle（检测、构建、导出镜像）</li></ul><h3 id=stack>Stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h3><p>build image 为 Builders 提供基础环境（比如带 maven 的 Ubuntu 镜像），<code>run image</code> 在运行时为应用镜像提供基础环境，Stack 就是这两者的组合。</p><h3 id=工作流程-belike>工作流程 belike<a hidden class=anchor aria-hidden=true href=#工作流程-belike>#</a></h3><p>以 Django 项目为例：</p><ol><li><p>检测阶段（Detect）：</p><p>Builder 中的每个 Buildpack 依次检查代码：</p><ul><li>Python Buildpack 发现 requirement.txt，标记自己为 “适用”</li><li>Django Buildpack 进一步检测 manage.py 或 settings.py，确认 Django 框架存在</li><li>其他 Buildpack 若未检测到特征，比如 Node.js 未检测到 package.json，则跳过</li></ul></li><li><p>构建阶段（Build）
依赖安装</p><ul><li>根据 requirement.txt 安装 python 依赖，缓存到独立层（避免重复下载）</li><li>自动创建激活虚拟环境<ul><li>静态文件处理</li></ul></li><li>运行 python manage.py collectstatic 收集静态文件<ul><li>数据库迁移</li></ul></li><li>运行 python manage.py migrate 生成数据库迁移文件<ul><li>启动配置</li></ul></li><li>设置环境变量，生成启动命令</li></ul></li><li><p>导出镜像（Export）</p><ul><li>Lifecycle 将所有层（依赖、静态文件、编译结果）与 run image 合并</li><li>生成符合 OCI 规范的最终镜像</li><li>镜像自动继承 run image 的安全补丁</li></ul></li></ol><h2 id=slugbuilder-slugrunner>slugbuilder, slugrunner<a hidden class=anchor aria-hidden=true href=#slugbuilder-slugrunner>#</a></h2><h3 id=slugbuilder>slugbuilder<a hidden class=anchor aria-hidden=true href=#slugbuilder>#</a></h3><ul><li><p>builder 的一种，slugbuilder 会在基础的 heroku runner 镜像上加层，最后组成一个完整的可运行的镜像。</p></li><li><p>slugbuilder 是镜像构建阶段的基础环境，通过顺序执行多个 buildpack 将应用源代码构建成镜像层</p></li></ul><h2 id=slugrunner>slugrunner<a hidden class=anchor aria-hidden=true href=#slugrunner>#</a></h2><ul><li>slugrunner 是应用运行阶段的基础环境，用于承载构建阶段的产物，组成可以最终运行的容器镜像</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>