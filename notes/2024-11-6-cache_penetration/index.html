<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>缓存穿透、缓存雪崩、缓存击穿与缓存污染 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="缓存穿透、缓存雪崩、缓存击穿与缓存污染 - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/notes/2024-11-6-cache_penetration/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/notes/2024-11-6-cache_penetration/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/notes/2024-11-6-cache_penetration/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="缓存穿透、缓存雪崩、缓存击穿与缓存污染"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2024-11-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="缓存穿透、缓存雪崩、缓存击穿与缓存污染"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yuk1pedia.github.io/notes/"},{"@type":"ListItem","position":2,"name":"缓存穿透、缓存雪崩、缓存击穿与缓存污染","item":"https://yuk1pedia.github.io/notes/2024-11-6-cache_penetration/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"缓存穿透、缓存雪崩、缓存击穿与缓存污染","name":"缓存穿透、缓存雪崩、缓存击穿与缓存污染","description":"","keywords":[],"articleBody":"1.缓存穿透 什么是缓存穿透？\n我们使用 redis 大部分情况都是通过 key 查询对应的值，假如发送的请求传进来的 key 是不存在redis 中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。\n分析：\n关键在于在 redis 查不到 key 值，这和缓存击穿有根本的区别，区别在于缓存穿透的情况是传进来的 key 在 redis 中是不存在的。假如有黑客传进大量的不存在的 key ，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。\n解决方案：\n把无效的 key 存进 redis 中。如果 redis 查不到数据，数据库也查不到，我们把这个 key 值保存进 redis ，设置 value=“null” ，当下次再通过这个 key 查询时就不需要再查询数据库。但这种处理方式肯定是有问题的，假如传进来的这个不存在的 key 值每次都是随机的，那存进 redis 也没有意义，会造成无意义的内存消耗，并且如果某个之前访问过的 key 此时设置了对应的值，那么就会造成 redis 和数据库的短暂不一致。 使用布隆过滤器。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。 布隆过滤器的一种实现：\n初始化一个较大的数组，用来存放二进制 0 或 1。一开始数组中数据都为 0，当一个 key 来了之后经过 3 次 hash 计算，得到三个下标 index，将数组中这三个下标对应的数据从 0 改为 1，这样的话数组中三个位置就能标明一个 key 的存在。 当然这种实现也是有误判率的，应该说布隆过滤器的误判率不可能为 0。如果我们想要减少误判率，就得增加数组的长度，但这样会造成更多的内存消耗。 2.缓存雪崩 什么是缓存雪崩？\n当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接访问数据库，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量让数据库宕机，这就是缓存雪崩。\n分析：\n造成缓存雪崩的关键在于在同一时间大规模的 key 失效。为什么会出现这个问题呢，有几种可能，第一种可能是 redis 宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？\n解决方案：\n在原有的失效时间上加上一个随机值，比如 1-5 分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。 如果真的发生了缓存雪崩，有没有什么兜底的措施？\n使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求访问数据库。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。 提高数据库的容灾能力，可以使用分库分表，读写分离的策略。 为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。 3.缓存击穿 什么是缓存击穿？\n其实跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部访问到数据库上，导致数据库压力剧增，这种现象就叫做缓存击穿。\n分析：\n关键在于某个热点的 key 失效了，导致大并发集中访问在数据库上。所以要从两个方面解决，第一是否可以考虑热点 key 不设置过期时间，第二是否可以考虑降低访问在数据库上的请求数量。\n解决方案：\n如果业务允许的话，对于热点的 key 可以设置永不过期的 key。 使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻访问在数据库上的请求，防止数据库宕机。当然这样会导致系统的性能变差。 逻辑过期，当发现缓存中数据已经过期，先获取互斥锁，然后新建一个线程去进行缓存更新（数据同步）。在缓存更新的过程中如果收到获取数据的请求，先返回已过期的旧数据，保证高性能。 4.缓存污染 什么是缓存污染？\nLinux （实现两个 LRU 链表）和 MySQL （划分两个区域）通过改进传统的 LRU 数据结构，避免了预读失效带来的影响。\n但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么还存在缓存污染的问题。\n当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。\n缓存污染会带来什么问题？\n缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。\n以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。\n当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。\n注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。\n比如，在一个数据量非常大的表，执行了这条语句：\nselect * from t_user where name like \"%xiaolin%\"; 可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：\n从磁盘读到的页加入到 LRU 链表的 old 区域头部； 当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部； 接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里； 如此往复，直到扫描完表中的所有记录。 经过这一番折腾，由于这条 SQL 语句访问的页非常多，每访问一个页，都会将其加入 young 区域头部，那么原本 young 区域的热点数据都会被替换掉，导致缓存命中率下降。那些在批量扫描时，而被加入到 young 区域的页，如果在很长一段时间都不会再被访问的话，那么就污染了 young 区域。\n怎么避免缓存污染造成的影响？\n前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），这种 LRU 算法进入活跃 LRU 链表的门槛太低了！正是因为门槛太低，才导致在发生缓存污染的时候，很容易就将原本在活跃 LRU 链表里的热点数据淘汰了。\n所以，只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉。\nLinux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：\nLinux 操作系统：在内存页被访问第二次的时候，才将页从 inactive list 升级到 active list 里。 MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断： 如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域； 如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域； 提高了进入活跃 LRU 链表（或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。\n在批量读取数据时候，如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域），也就不会把热点数据淘汰，只会待在非活跃 LRU 链表（或者 old 区域）中，后续很快也会被淘汰。\n","wordCount":"264","inLanguage":"en","datePublished":"2024-11-06T00:00:00Z","dateModified":"2024-11-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuk1pedia.github.io/notes/2024-11-6-cache_penetration/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yuk1pedia.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">缓存穿透、缓存雪崩、缓存击穿与缓存污染</h1><div class=post-meta><span title='2024-11-06 00:00:00 +0000 UTC'>November 6, 2024</span></div></header><div class=post-content><h2 id=1缓存穿透>1.缓存穿透<a hidden class=anchor aria-hidden=true href=#1缓存穿透>#</a></h2><p><strong>什么是缓存穿透？</strong></p><p>我们使用 redis 大部分情况都是通过 key 查询对应的值，假如发送的请求传进来的 key 是不存在redis 中的，那么就查不到缓存，<strong>查不到缓存就会去数据库查询</strong>。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</p><p><strong>分析：</strong></p><p>关键在于在 redis <strong>查不到</strong> key 值，<strong>这和缓存击穿有根本的区别</strong>，区别在于<strong>缓存穿透的情况是传进来的 key 在 redis 中是不存在的</strong>。假如有黑客传进大量的不存在的 key ，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示，要对调用方保持这种“不信任”的心态。</p><p><strong>解决方案：</strong></p><ol><li><strong>把无效的 key 存进 redis 中</strong>。如果 redis 查不到数据，数据库也查不到，我们把这个 key 值保存进 redis ，设置 value=&ldquo;null&rdquo; ，当下次再通过这个 key 查询时就不需要再查询数据库。但这种处理方式肯定是有问题的，假如传进来的这个不存在的 key 值每次都是随机的，那存进 redis 也没有意义，<strong>会造成无意义的内存消耗，并且如果某个之前访问过的 key 此时设置了对应的值，那么就会造成 redis 和数据库的短暂不一致</strong>。</li><li><strong>使用布隆过滤器</strong>。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。</li></ol><p><strong>布隆过滤器的一种实现：</strong></p><ul><li>初始化一个较大的数组，用来存放二进制 0 或 1。一开始数组中数据都为 0，当一个 key 来了之后经过 3 次 hash 计算，得到三个下标 index，将数组中这三个下标对应的数据从 0 改为 1，这样的话数组中三个位置就能标明一个 key 的存在。</li><li>当然这种实现也是有误判率的，应该说布隆过滤器的误判率不可能为 0。如果我们想要减少误判率，就得增加数组的长度，但这样会造成更多的内存消耗。</li></ul><p><img alt=1.png loading=lazy src=https://s2.loli.net/2024/11/06/YZkldE2mDuoGrJs.png></p><h2 id=2缓存雪崩>2.缓存雪崩<a hidden class=anchor aria-hidden=true href=#2缓存雪崩>#</a></h2><p><strong>什么是缓存雪崩？</strong></p><p>当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接访问数据库，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量让数据库宕机，这就是缓存雪崩。</p><p><strong>分析：</strong></p><p>造成缓存雪崩的关键在于在同一时间大规模的 key 失效。为什么会出现这个问题呢，有几种可能，第一种可能是 redis 宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？</p><p><img alt=1.png loading=lazy src=https://s2.loli.net/2024/11/06/3ZbpNV7h9gEnjS4.png></p><p><strong>解决方案：</strong></p><ol><li>在原有的失效时间上加上一个随机值，比如 1-5 分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</li></ol><p><strong>如果真的发生了缓存雪崩，有没有什么兜底的措施？</strong></p><ol start=2><li>使用<strong>熔断机制</strong>。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求访问数据库。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li><li>提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</li><li>为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</li></ol><h2 id=3缓存击穿>3.缓存击穿<a hidden class=anchor aria-hidden=true href=#3缓存击穿>#</a></h2><p><strong>什么是缓存击穿？</strong></p><p>其实跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部访问到数据库上，导致数据库压力剧增，这种现象就叫做缓存击穿。</p><p><strong>分析：</strong></p><p>关键在于某个热点的 key 失效了，导致大并发集中访问在数据库上。所以要从两个方面解决，<strong>第一是否可以考虑热点 key 不设置过期时间，第二是否可以考虑降低访问在数据库上的请求数量</strong>。</p><p><strong>解决方案：</strong></p><ol><li>如果业务允许的话，对于热点的 key 可以设置永不过期的 key。</li><li>使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻访问在数据库上的请求，防止数据库宕机。<strong>当然这样会导致系统的性能变差</strong>。</li><li>逻辑过期，当发现缓存中数据已经过期，先获取互斥锁，然后新建一个线程去进行缓存更新（数据同步）。<strong>在缓存更新的过程中如果收到获取数据的请求，先返回已过期的旧数据，保证高性能</strong>。</li></ol><h2 id=4缓存污染>4.缓存污染<a hidden class=anchor aria-hidden=true href=#4缓存污染>#</a></h2><p><strong>什么是缓存污染？</strong></p><p>Linux （实现两个 LRU 链表）和 MySQL （划分两个区域）通过改进传统的 LRU 数据结构，避免了预读失效带来的影响。</p><p>但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么<strong>还存在缓存污染的问题</strong>。</p><p>当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，<strong>如果这些大量的数据在很长一段时间都不被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。</strong></p><p><strong>缓存污染会带来什么问题？</strong></p><p>缓存污染带来的影响就是很致命的，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。</p><p>以 MySQL 举例子，Linux 发生缓存污染的现象也是类似。</p><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 I/O，MySQL 性能就会急剧下降。</p><p>注意， 缓存污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成缓存污染。</p><p>比如，在一个数据量非常大的表，执行了这条语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t_user <span style=color:#66d9ef>where</span> name <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#34;%xiaolin%&#34;</span>;
</span></span></code></pre></div><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是<strong>页被访问的时候，就要将该页放到 young 区域头部</strong>；</li><li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，由于这条 SQL 语句访问的页非常多，每访问一个页，都会将其加入 young 区域头部，那么<strong>原本 young 区域的热点数据都会被替换掉，导致缓存命中率下降</strong>。那些在批量扫描时，而被加入到 young 区域的页，如果在很长一段时间都不会再被访问的话，那么就污染了 young 区域。</p><p><strong>怎么避免缓存污染造成的影响？</strong></p><p>前面的 LRU 算法只要数据被访问一次，就将数据加入活跃 LRU 链表（或者 young 区域），<strong>这种 LRU 算法进入活跃 LRU 链表的门槛太低了</strong>！正是因为门槛太低，才导致在发生缓存污染的时候，很容易就将原本在活跃 LRU 链表里的热点数据淘汰了。</p><p>所以，<strong>只要我们提高进入到活跃 LRU 链表（或者 young 区域）的门槛，就能有效地保证活跃 LRU 链表（或者 young 区域）里的热点数据不会被轻易替换掉</strong>。</p><p>Linux 操作系统和 MySQL Innodb 存储引擎分别是这样提高门槛的：</p><ul><li><strong>Linux 操作系统</strong>：在内存页被访问<strong>第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。</li><li><strong>MySQL Innodb</strong>：在内存页被访问<strong>第二次</strong>的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行<strong>停留在 old 区域的时间判断</strong>：<ul><li>如果第二次的访问时间与第一次访问的时间<strong>在 1 秒内</strong>（默认值），那么该页就<strong>不会</strong>被从 old 区域升级到 young 区域；</li><li>如果第二次的访问时间与第一次访问的时间<strong>超过 1 秒</strong>，那么该页就<strong>会</strong>从 old 区域升级到 young 区域；</li></ul></li></ul><p>提高了进入活跃 LRU 链表（或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。</p><p>在批量读取数据时候，<strong>如果这些大量数据只会被访问一次，那么它们就不会进入到活跃 LRU 链表（或者 young 区域）</strong>，也就不会把热点数据淘汰，只会待在非活跃 LRU 链表（或者 old 区域）中，后续很快也会被淘汰。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>