<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>python + django | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="python + django - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yuk1pedia.github.io/notes/2025-5-3-python+django/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yuk1pedia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yuk1pedia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yuk1pedia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yuk1pedia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yuk1pedia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yuk1pedia.github.io/notes/2025-5-3-python+django/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yuk1pedia.github.io/notes/2025-5-3-python+django/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="python + django"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-05-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="python + django"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yuk1pedia.github.io/notes/"},{"@type":"ListItem","position":2,"name":"python + django","item":"https://yuk1pedia.github.io/notes/2025-5-3-python+django/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"python + django","name":"python \u002b django","description":"","keywords":[],"articleBody":"python 语法 文件类型相关\npython 是动态类型语言，存在三种文件类型：python file、python unit test 和 python stub\npython file：普通的 Python 脚本文件，用于编写常规的 Python 代码，如业务逻辑、工具脚本、程序主体等 python unit test：专门用于编写单元测试的文件，通常与测试框架（如 unittest、pytest）配合使用，用于验证代码功能的正确性 python stub：存根文件（.pyi），用于类型提示（Type Hints），不包含实际代码逻辑，仅定义函数、类、变量的类型签名 最后一个 python stub可能不太好理解，由于 python 是动态类型语言，写代码时不强制声明变量类型，但在大型项目里，不明确类型会让代码阅读和维护变难，IDE 也不好做智能提示，Python stub 就是专门用来写类型信息的文件，它里面只写函数、变量、类等的类型，没有实际代码逻辑\n变量\npython 中对象分为可变对象和不可变对象，主要区别体现在 对象的值能否被修改\n不可变对象：一旦创建，其值就不能被修改。若要修改值，实际上是创建了一个新对象，原对象保持不变。不可变对象有：int、float、str、tuple 和 bool 等等 可变对象：对象创建后，其值可以在原地被修改，不会创建新的对象。主要有：list、dict 和 set 等 cnt = 2 print(id(cnt)) cnt += 2 print(id(cnt)) 比如上面代码，cnt 前后指向的是不同的对象，输出结果如下：\n140711354237896 140711354237960 python 中没有内置的常量类型，但通常约定使用 全大写 来指出应将某个变量视为常量\nMAX_CONNECTIONS = 5000 列表\npython 中的 list 本质上是一个动态数组，也就是可变长度的数组\n动态数组：在内存中连续分配，通过索引能够实现随机访问，时间复杂度为 O(1) 空间分配策略：为避免频繁的内存分配，list 在创建时会 预先分配比实际所需更多的内存空间。当元素增多并超出已分配的空间时，list 会重新分配更大的内存空间，然后把原有元素复制到新空间，释放旧内存 补充：tuple 和 list tuple 是不可变序列，底层实现为静态数组，元组的元素在内存中也是连续分配的 由于 tuple 不可变，在创建时就会根据元素数量一次性分配 固定大小 的内存空间 删除 list 中的元素时，如果知道要删除元素的索引位置，可以使用 pop() 或者 del\nmotorcycles = ['honda', 'yamaha', 'suzuki'] # 删除 'yamaha' del motorcycles[1] print(motorcycles) # 默认弹出末尾元素，可以指定索引，此处删除的是 'suzuki' print(motorcycles.pop()) print(motorcycles) 但区别是 del 无法拿到删除的元素，pop() 可以拿到删除的元素，输出结果如下：\n['honda', 'suzuki'] suzuki ['honda'] 如果说我们不知道元素的索引位置，但知道我们想删除的内容，可以使用 remove()\nmotorcycles = ['honda', 'yamaha', 'suzuki', 'ducati'] print(motorcycles) motorcycles.remove('ducati') print(motorcycles) 输出结果：\n['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] remove() 和 pop() 类似，也可以返回被删除的元素，另外，方法 remove() 只删除第一个指定的值。如果要删除的值可能在列表中 出现多次，就需要使用循环来确保将每个值都删除\n对于列表复制，需要使用切片，如果直接赋值，两个列表指向的会是同一个对象\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli'] # 同一个对象 players2 = players # 副本，不同的对象 players3 = players[:] print(id(players)) print(id(players2)) print(id(players3)) 输出结果：\n2011801227200 2011801227200 2011800984832 面向对象\n以下面的代码为例，了解 python 中的面向对象思想\nclass Dog: # 类属性 species = \"Canis familiaris\" # 在 __init__ 中添加实例属性 def __init__(self, name, age): self.name = name self.age = age # 动态添加实例属性 def set_age(self, age): self.age = age def sit(self): print(f\"{self.name} is now sitting.\") def roll_over(self): print(f\"{self.name} rolled over.\") my_dog = Dog('Willie', 6) print(f\"My dog's name is {my_dog.name}\") print(f\"My dog is {my_dog.age} years old\") my_dog.sit() my_dog.roll_over() python 是动态类型语言，定义类时不需要像 java 那样单独把类中的属性显示写出来\n在类中定义属性有两种常见方式：类属性 和 实例属性\n类属性：属于类本身的属性，所有实例共享该属性，可以在类的定义中直接赋值来定义类属性，比如上面代码的 species\n实例属性：属于类的每个实例，通常在 __init__ 方法中通过 self 参数来定义和初始化实例属性，也可以在其他实例方法中动态添加\n在 python 中，不存在像 java 那种严格意义上的私有属性（使用 private 修饰），但可以通过 单下划线前缀（弱私有约定） 来限制访问\nclass Person: def __init__(self, name, age): self._name = name self._age = age def _display_info(self): print(f\"Name: {self._name}, Age: {self._age}\") p = Person(\"Alice\", 25) # 可以访问，但不建议 print(p._name) p._display_info() 在上述代码中，_name、_age 和 _display_info 以单下划线开头，按照约定应在类内部使用，但仍然可以在类外部访问它们 。因此这仅仅是一种约定，而非强制性的修饰符\n类的继承\n# 父类 class Car: def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = f\"{self.year} {self.make} {self.model}\" return long_name.title() def read_odometer(self): print(f\"This car has {self.odometer_reading} miles on it.\") def update_odometer(self, mileage): if mileage \u003e= self.odometer_reading: self.odometer_reading += mileage else: print(\"You can't roll back odometer!\") def increment_odometer(self, miles): self.odometer_reading += miles # 子类 class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year) my_tesla = ElectricCar('tesla', 'models', 2019) 创建子类时，父类 必须包含 在当前文件中，且位于子类前面。这里的 必须包含 不是说父类与子类必须写在同一个 .py 文件中，我们也可以把父类和子类分别写在不同的 .py 文件里，比如下面的代码：\n# animal.py class Animal: def __init__(self, name): self.name = name def speak(self): print(f\"{self.name} makes a sound.\") # dog.py from animal import Animal class Dog(Animal): def speak(self): print(f\"{self.name} barks.\") # 创建子类实例并调用方法 dog = Dog(\"Buddy\") dog.speak() 运行 dog.py 时，python 会先从 animal.py 文件里导入 Animal 类，然后创建 Dog 类的实例并调用其方法\n重写父类方法\n父类方法不符合子类模拟的实物行为时，都可以进行重写。为此，可在子类中定义一个与要重写的父类方法同名的方法，这样，python 将不考虑父类方法，只关注子类方法\n算法相关 如何遍历可迭代对象？\n以 https://leetcode.cn/problems/two-sum/description/ 为例\n使用 range 函数，其中使用到 range 去创建一个可迭代对象（对象中数字从 0 开始）\nrange 的完整语法：range(start, stop[, step])，其中： start：可选参数，序列起始值，默认为 0 stop：必选参数，序列结束值，生成的序列不包含该值 step：可选参数，序列步长，默认是 1 class Solution: def twoSum(self, nums: List[int], target: int) -\u003e List[int]: for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j] return [] 使用 enumerate 函数，遍历可迭代对象时同时获取元素的索引和值\nenumerate 的完整语法：enumerate(iterable, start=0)，其中： iterable：必选参数，代表要遍历的可迭代对象 start：可选参数，用于指定索引的起始值，默认是 0 class Solution: def twoSum(self, nums: List[int], target: int) -\u003e List[int]: indices = {} for i, v in enumerate(nums): pre = target - v if pre in indices: return [i, indices[pre]] indices[v] = i return [] 这里提到 range 函数生成可迭代对象，该对象不是 list 也不是 tuple，而是 range 类型\nrange 对象是可迭代的，所以可以用于 for 循环\nfor i in range(5): print(i) 内存高效：range 对象不会像 list 那样一次性把所有元素存储在内存中，而是在迭代时逐个生成元素，因此在处理大序列时，能节省大量内存\n不可变：一旦 range 对象被创建，其元素和范围就不能改变。若要得到不同的范围，需要重新创建一个新的 range 对象\n文件与异常 文件\nwith open('test.txt') as file_object: contents = file_object.read() print(contents) 上面的代码里，open() 函数打开对应文件，返回一个表示文件 test.txt 的对象，python 将该对象赋给 file_object 供以后使用\n关键字 with 在不再需要访问文件后将其关闭，我们也可以调用 open() 和 close() 来打开和关闭文件，但这样做时，如果程序存在 bug 导致 close() 未执行，文件将不会关闭，可能导致数据丢失或受损\ntips：如果文件的绝对路径比较长，可以把它赋给一个变量，再把变量传递给 open()\n异常\n类似 java，当发生让 python 不知所措的错误时，它都会创建一个异常对象。如果程序中有处理该异常的代码，程序将继续运行；如果未对异常进行处理，程序将停止并显示 traceback，其中包含有关异常的报告\n写代码时如果认为可能发生错误，可编写一个 try-except 代码块来处理可能引发的异常。如果 try 代码块中的代码引发了异常，python 将查找与之匹配的 except 代码块并运行其中的代码\n# 程序停止，显示 traceback print(1 / 0) # 程序继续执行，异常被捕获并运行 except 代码块中的代码 try: print(1 / 0) except ZeroDivisionError: print(\"You can't divide by zero\") 静默失败\n每次捕获到异常时，可能不需要告诉用户，想让程序保持静默，这里就可以使用 pass 语句\ndef count_words(filename): # 计算一个文件大致包含多少个单词 try: --snip-- except FileNotFoundError: pass else: --snip filenames = {'1', '2', '3', '4'} for filename in filenames: count_words(filename) 假设文件 “3” 不存在，python 在执行上述代码时，只会打印 1、2、4 的单词数，不会有任何 traceback\nDjango Django 是一个高级的 Python Web 框架，采用了模型-视图-控制器（MVC）的架构模式，能够快速、高效地构建 Web 应用程序。\n在 PyCharm 中创建一个 Django 项目，PyCharm 会自动构建项目需要的虚拟环境，下面是完成创建的目录结构。\n目录 learning_log 包含 5 个文件，最重要的是 settings.py、urls.py 和 wsgi.py。\nsettings.py：指定 Django 如何与系统交互以及如何管理项目，可以根据具体需求，选择修改一些设置并添加一些设置 urls.py：该文件告诉 Django 应该创建哪些页面来响应浏览器请求 wsgi.py：wsgi 是 Web Server Gateway Interface 的缩写，在 Django 项目中，wsgi.py 文件是启动 WSGI 服务器的入口文件，它负责创建一个 WSGI 应用程序对象，加载 Django 项目的配置（设置 DJANGO_SETTINGS_MODULE 环境变量指定配置文件 ），并将应用程序对象传递给 WSGI 服务器，使服务器能处理传入的 HTTP 请求 asgi.py(补充)：asgi 是 Asynchronous Server Gateway Interface 的缩写，是异步服务器网关接口，是对 wsgi 的扩展，用于处理异步 Web 请求，能更好地支持异步编程和 WebSocket 等长连接操作 创建数据库 首先创建一个供 Django 使用的数据库，在终端执行下面的指令：\n我们将修改数据库成为 迁移 数据库，首次执行 migrate 命令时，将让 Django 确保数据库与项目的当前状态匹配。在使用 SQLite 的新项目中首次执行这个命令时，Django 将新建一个数据库。SQLite 是一种使用单个文件的数据库，不用太关注数据库管理的问题。\n查看项目 可以使用 runserver 查看项目的状态：\nDjango 启动了一个名为 development server 的服务器，此时使用浏览器访问 http://localhost:8000/ 以请求页面，Django 服务器将进行相应，生成合适的页面并发送给浏览器，如下图：\n应用程序 在 Django 中，应用程序（app）是一个具备独立功能的模块，类似于 java spring 框架的 module。\n每个 Django 应用程序专注于一个特定的功能领域，比如博客项目可以有一个 “文章” 应用程序，专门负责文章的创建、编辑、展示和删除操作；还可以有一个 “评论” 应用程序，用于处理用户对文章的评论功能\n一个新创建的应用程序如下图\n应用程序中各个 .py 文件的作用：\n__init__.py：Python 中用于标识该目录是一个 Python 包，早期可用于导入包时执行初始化代码，现在空文件也能让目录成为包，方便模块组织和管理 admin.py：用于注册模型到 Django 自带的后台管理系统，注册后可在后台对相应模型数据进行增删改查等操作 ，方便管理网站数据 apps.py：定义应用程序的配置类（AppConfig），可配置应用元数据和行为，如设置应用名称、标签；重写 ready() 方法可执行启动初始化操作，像信号注册 models.py：定义数据模型，即映射数据库表结构，每个模型类对应数据库一张表，类中的字段对应表中的列，通过它可进行数据库交互，实现数据存储、查询、修改、删除等操作 tests.py：编写测试代码的地方，用于对应用程序功能进行自动化测试，确保应用按预期工作，提高代码稳定性和可靠性，比如测试视图逻辑、模型方法等是否正确 views.py：处理业务逻辑，接收用户请求，根据请求进行数据处理（可能涉及调用模型获取数据），然后选择合适模板渲染并返回响应给用户 定义模型 此处定义了一个 Topic 类，继承 Model，在该类中添加了两个属性：text 和 date_added，表示用户在学习笔记中创建的主题。\n属性 text 是一个 CharField —— 由字符组成的数据，属性 date_added 是一个 DateTimeField —— 记录日期和时间的数据。\n激活模型 要使用模型，必须让 Django 将上面的应用程序包含到项目中，这里就需要修改 settings.py 文件，其中有个片段告诉 Django 哪些应用程序被安装到了项目中并将协同工作，在里面添加自己的应用程序即可。\n注意，这里务必将自己创建的应用程序放到默认应用程序前面，这样能够覆盖默认应用程序的行为。\n接下来，需要让 Django 修改数据库，使其能够存储与模型 Topic 相关的信息，为此，在终端窗口中执行下面的命令：\n输出表明 Django 创建了一个名为 0001_initial.py 的迁移文件，这个文件将在数据库中为模型 Topic 创建一个表。\n补充：Django 中的 迁移 是管理数据库结构变化的一种机制，用于在开发过程中修改模型（Model）并同步数据库的变化。当对 Django 模型进行更改时，迁移会记录这些变化，每次修改后运行 python manage.py makemigrations 命令，Django 会生成迁移文件，该文件记录了从一个数据库状态到另一个状态需要执行的操作，比如下图中的 0001_initial.py 迁移文件：\n下面应用这种迁移，让 Django 替我们修改数据库：\n每当需要修改 “学习笔记” 管理的数据时，都采取如下三个步骤：修改 models.py，对 learning_logs 调用 makemigrations，以及让 Django 迁移项目\nDjango 管理网站 ","wordCount":"827","inLanguage":"en","datePublished":"2025-05-03T00:00:00Z","dateModified":"2025-05-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuk1pedia.github.io/notes/2025-5-3-python+django/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yuk1pedia.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuk1pedia.github.io/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuk1pedia.github.io/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">python + django</h1><div class=post-meta><span title='2025-05-03 00:00:00 +0000 UTC'>May 3, 2025</span></div></header><div class=post-content><h2 id=python>python<a hidden class=anchor aria-hidden=true href=#python>#</a></h2><h3 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h3><p><strong>文件类型相关</strong></p><p>python 是动态类型语言，存在三种文件类型：python file、python unit test 和 python stub</p><ul><li>python file：普通的 Python 脚本文件，用于编写常规的 Python 代码，如业务逻辑、工具脚本、程序主体等</li><li>python unit test：专门用于编写单元测试的文件，通常与测试框架（如 <code>unittest</code>、<code>pytest</code>）配合使用，用于验证代码功能的正确性</li><li>python stub：存根文件（<code>.pyi</code>），用于类型提示（Type Hints），不包含实际代码逻辑，仅定义函数、类、变量的类型签名</li></ul><p>最后一个 python stub可能不太好理解，由于 python 是动态类型语言，写代码时不强制声明变量类型，但在大型项目里，不明确类型会让代码阅读和维护变难，IDE 也不好做智能提示，Python stub 就是专门用来写类型信息的文件，它里面只写函数、变量、类等的类型，没有实际代码逻辑</p><p><strong>变量</strong></p><p>python 中对象分为可变对象和不可变对象，主要区别体现在 <strong>对象的值能否被修改</strong></p><ul><li><strong>不可变对象</strong>：一旦创建，其值就不能被修改。<strong>若要修改值，实际上是创建了一个新对象，原对象保持不变</strong>。不可变对象有：int、float、str、tuple 和 bool 等等</li><li><strong>可变对象</strong>：对象创建后，其值可以在原地被修改，不会创建新的对象。主要有：list、dict 和 set 等</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>print(id(cnt))
</span></span><span style=display:flex><span>cnt <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>print(id(cnt))
</span></span></code></pre></div><p>比如上面代码，cnt 前后指向的是不同的对象，输出结果如下：</p><pre tabindex=0><code>140711354237896
140711354237960
</code></pre><p><strong>python 中没有内置的常量类型</strong>，但通常约定使用 <strong>全大写</strong> 来指出应将某个变量视为常量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>MAX_CONNECTIONS <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span>
</span></span></code></pre></div><p><strong>列表</strong></p><p>python 中的 <code>list</code> 本质上是一个动态数组，也就是可变长度的数组</p><ul><li><strong>动态数组</strong>：在内存中连续分配，通过索引能够实现随机访问，时间复杂度为 <code>O(1)</code></li><li><strong>空间分配策略</strong>：为避免频繁的内存分配，<code>list</code> 在创建时会 <strong>预先分配比实际所需更多的内存空间</strong>。当元素增多并超出已分配的空间时，<code>list</code> 会重新分配更大的内存空间，然后把原有元素复制到新空间，释放旧内存</li><li>补充：<code>tuple</code> 和 <code>list</code><ul><li><code>tuple</code> 是不可变序列，底层实现为静态数组，元组的元素在内存中也是连续分配的</li><li>由于 <code>tuple</code> 不可变，在创建时就会根据元素数量一次性分配 <strong>固定大小</strong> 的内存空间</li></ul></li></ul><p>删除 <code>list</code> 中的元素时，<strong>如果知道要删除元素的索引位置</strong>，可以使用 <code>pop()</code> 或者 <code>del</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>motorcycles <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;honda&#39;</span>, <span style=color:#e6db74>&#39;yamaha&#39;</span>, <span style=color:#e6db74>&#39;suzuki&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># 删除 &#39;yamaha&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>del</span> motorcycles[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>print(motorcycles)
</span></span><span style=display:flex><span><span style=color:#75715e># 默认弹出末尾元素，可以指定索引，此处删除的是 &#39;suzuki&#39;</span>
</span></span><span style=display:flex><span>print(motorcycles<span style=color:#f92672>.</span>pop())
</span></span><span style=display:flex><span>print(motorcycles)
</span></span></code></pre></div><p>但区别是 <code>del</code> 无法拿到删除的元素，<code>pop()</code> 可以拿到删除的元素，输出结果如下：</p><pre tabindex=0><code>[&#39;honda&#39;, &#39;suzuki&#39;]
suzuki
[&#39;honda&#39;]
</code></pre><p>如果说我们不知道元素的索引位置，但知道我们想删除的内容，可以使用 <code>remove()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>motorcycles <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;honda&#39;</span>, <span style=color:#e6db74>&#39;yamaha&#39;</span>, <span style=color:#e6db74>&#39;suzuki&#39;</span>, <span style=color:#e6db74>&#39;ducati&#39;</span>]
</span></span><span style=display:flex><span>print(motorcycles)
</span></span><span style=display:flex><span>motorcycles<span style=color:#f92672>.</span>remove(<span style=color:#e6db74>&#39;ducati&#39;</span>)
</span></span><span style=display:flex><span>print(motorcycles)
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>[&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;, &#39;ducati&#39;]
[&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]
</code></pre><p><code>remove()</code> 和 <code>pop()</code> 类似，也可以返回被删除的元素，另外，<strong>方法 <code>remove()</code> 只删除第一个指定的值</strong>。如果要删除的值可能在列表中 出现多次，就需要使用循环来确保将每个值都删除</p><p>对于列表复制，需要使用切片，如果直接赋值，两个列表指向的会是同一个对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>players <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;charles&#39;</span>, <span style=color:#e6db74>&#39;martina&#39;</span>, <span style=color:#e6db74>&#39;michael&#39;</span>, <span style=color:#e6db74>&#39;florence&#39;</span>, <span style=color:#e6db74>&#39;eli&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># 同一个对象</span>
</span></span><span style=display:flex><span>players2 <span style=color:#f92672>=</span> players
</span></span><span style=display:flex><span><span style=color:#75715e># 副本，不同的对象</span>
</span></span><span style=display:flex><span>players3 <span style=color:#f92672>=</span> players[:]
</span></span><span style=display:flex><span>print(id(players))
</span></span><span style=display:flex><span>print(id(players2))
</span></span><span style=display:flex><span>print(id(players3))
</span></span></code></pre></div><p>输出结果：</p><pre tabindex=0><code>2011801227200
2011801227200
2011800984832
</code></pre><p><strong>面向对象</strong></p><p>以下面的代码为例，了解 python 中的面向对象思想</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 类属性</span>
</span></span><span style=display:flex><span>    species <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Canis familiaris&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 在 __init__ 中添加实例属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 动态添加实例属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_age</span>(self, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sit</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> is now sitting.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>roll_over</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> rolled over.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_dog <span style=color:#f92672>=</span> Dog(<span style=color:#e6db74>&#39;Willie&#39;</span>, <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;My dog&#39;s name is </span><span style=color:#e6db74>{</span>my_dog<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;My dog is </span><span style=color:#e6db74>{</span>my_dog<span style=color:#f92672>.</span>age<span style=color:#e6db74>}</span><span style=color:#e6db74> years old&#34;</span>)
</span></span><span style=display:flex><span>my_dog<span style=color:#f92672>.</span>sit()
</span></span><span style=display:flex><span>my_dog<span style=color:#f92672>.</span>roll_over()
</span></span></code></pre></div><p>python 是动态类型语言，定义类时不需要像 java 那样单独把类中的属性显示写出来</p><p>在类中定义属性有两种常见方式：<strong>类属性</strong> 和 <strong>实例属性</strong></p><ul><li><p><strong>类属性</strong>：属于类本身的属性，<strong>所有实例共享该属性</strong>，可以在类的定义中直接赋值来定义类属性，比如上面代码的 <code>species</code></p></li><li><p><strong>实例属性</strong>：属于类的每个实例，通常在 <code>__init__</code> 方法中通过 <code>self</code> 参数来定义和初始化实例属性，也可以在其他实例方法中动态添加</p></li></ul><p>在 python 中，不存在像 java 那种严格意义上的私有属性（使用 <code>private</code> 修饰），但可以通过 <strong>单下划线前缀（弱私有约定）</strong> 来限制访问</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_display_info</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Name: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>_name<span style=color:#e6db74>}</span><span style=color:#e6db74>, Age: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>_age<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> Person(<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>25</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 可以访问，但不建议</span>
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>_name)  
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>_display_info()
</span></span></code></pre></div><p>在上述代码中，<code>_name</code>、<code>_age</code> 和 <code>_display_info</code> 以单下划线开头，按照约定应在类内部使用，<strong>但仍然可以在类外部访问它们</strong> 。因此这仅仅是一种约定，而非强制性的修饰符</p><p><strong>类的继承</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 父类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Car</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, make, model, year):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>make <span style=color:#f92672>=</span> make
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>model <span style=color:#f92672>=</span> model
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>year <span style=color:#f92672>=</span> year
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>odometer_reading <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_descriptive_name</span>(self):
</span></span><span style=display:flex><span>        long_name <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>year<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>make<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>model<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> long_name<span style=color:#f92672>.</span>title()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_odometer</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;This car has </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>odometer_reading<span style=color:#e6db74>}</span><span style=color:#e6db74> miles on it.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update_odometer</span>(self, mileage):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> mileage <span style=color:#f92672>&gt;=</span> self<span style=color:#f92672>.</span>odometer_reading:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>odometer_reading <span style=color:#f92672>+=</span> mileage
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;You can&#39;t roll back odometer!&#34;</span>)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>increment_odometer</span>(self, miles):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>odometer_reading <span style=color:#f92672>+=</span> miles
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 子类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ElectricCar</span>(Car):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, make, model, year):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span><span style=color:#a6e22e>__init__</span>(make, model, year)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>my_tesla <span style=color:#f92672>=</span> ElectricCar(<span style=color:#e6db74>&#39;tesla&#39;</span>, <span style=color:#e6db74>&#39;models&#39;</span>, <span style=color:#ae81ff>2019</span>)
</span></span></code></pre></div><p>创建子类时，父类 <strong>必须包含</strong> 在当前文件中，且位于子类前面。这里的 <strong>必须包含</strong> 不是说父类与子类必须写在同一个 <code>.py</code> 文件中，我们也可以把父类和子类分别写在不同的 <code>.py</code> 文件里，比如下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># animal.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>speak</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> makes a sound.&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># dog.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> animal <span style=color:#f92672>import</span> Animal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Animal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>speak</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74> barks.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建子类实例并调用方法</span>
</span></span><span style=display:flex><span>dog <span style=color:#f92672>=</span> Dog(<span style=color:#e6db74>&#34;Buddy&#34;</span>)
</span></span><span style=display:flex><span>dog<span style=color:#f92672>.</span>speak()
</span></span></code></pre></div><p>运行 <code>dog.py</code> 时，python 会先从 <code>animal.py</code> 文件里导入 <code>Animal</code> 类，然后创建 <code>Dog</code> 类的实例并调用其方法</p><p><strong>重写父类方法</strong></p><p>父类方法不符合子类模拟的实物行为时，都可以进行重写。为此，可在子类中定义一个与要重写的父类方法同名的方法，这样，python 将不考虑父类方法，只关注子类方法</p><h3 id=算法相关>算法相关<a hidden class=anchor aria-hidden=true href=#算法相关>#</a></h3><p><strong>如何遍历可迭代对象？</strong></p><p>以 <a href=https://leetcode.cn/problems/two-sum/description/>https://leetcode.cn/problems/two-sum/description/</a> 为例</p><ul><li><p>使用 <code>range</code> 函数，其中使用到 <code>range</code> 去创建一个可迭代对象（对象中数字从 0 开始）</p><ul><li><code>range</code> 的完整语法：<code>range(start, stop[, step])</code>，其中：<ul><li><code>start</code>：可选参数，序列起始值，默认为 0</li><li><code>stop</code>：必选参数，序列结束值，生成的序列不包含该值</li><li><code>step</code>：可选参数，序列步长，默认是 1</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(nums)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, len(nums)):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>+</span> nums[j] <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> [i, j]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> []
</span></span></code></pre></div></li><li><p>使用 <code>enumerate</code> 函数，<strong>遍历可迭代对象时同时获取元素的索引和值</strong></p><ul><li><code>enumerate</code> 的完整语法：<code>enumerate(iterable, start=0)</code>，其中：<ul><li><code>iterable</code>：必选参数，代表要遍历的可迭代对象</li><li><code>start</code>：可选参数，用于指定索引的起始值，默认是 0</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        indices <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, v <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>            pre <span style=color:#f92672>=</span> target <span style=color:#f92672>-</span> v
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> pre <span style=color:#f92672>in</span> indices:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> [i, indices[pre]]
</span></span><span style=display:flex><span>            indices[v] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> []
</span></span></code></pre></div></li></ul><p><strong>这里提到 <code>range</code> 函数生成可迭代对象</strong>，该对象不是 list 也不是 tuple，而是 range 类型</p><ul><li><p>range 对象是可迭代的，所以可以用于 for 循环</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>	print(i)
</span></span></code></pre></div></li><li><p><strong>内存高效</strong>：range 对象不会像 list 那样一次性把所有元素存储在内存中，而是在迭代时逐个生成元素，因此在处理大序列时，能节省大量内存</p></li><li><p><strong>不可变</strong>：一旦 range 对象被创建，其元素和范围就不能改变。若要得到不同的范围，需要重新创建一个新的 range 对象</p></li></ul><h3 id=文件与异常>文件与异常<a hidden class=anchor aria-hidden=true href=#文件与异常>#</a></h3><p><strong>文件</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;test.txt&#39;</span>) <span style=color:#66d9ef>as</span> file_object:
</span></span><span style=display:flex><span>    contents <span style=color:#f92672>=</span> file_object<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>print(contents)
</span></span></code></pre></div><p>上面的代码里，<code>open()</code> 函数打开对应文件，返回一个表示文件 <code>test.txt</code> 的对象，python 将该对象赋给 <code>file_object</code> 供以后使用</p><p><strong>关键字 <code>with</code> 在不再需要访问文件后将其关闭</strong>，我们也可以调用 <code>open()</code> 和 <code>close()</code> 来打开和关闭文件，但这样做时，如果程序存在 bug 导致 <code>close()</code> 未执行，文件将不会关闭，可能导致数据丢失或受损</p><p>tips：如果文件的绝对路径比较长，可以把它赋给一个变量，再把变量传递给 <code>open()</code></p><p><strong>异常</strong></p><p>类似 java，当发生让 python 不知所措的错误时，它都会创建一个异常对象。如果程序中有处理该异常的代码，程序将继续运行；如果未对异常进行处理，程序将停止并显示 traceback，其中包含有关异常的报告</p><p>写代码时如果认为可能发生错误，可编写一个 <code>try-except</code> 代码块来处理可能引发的异常。如果 try 代码块中的代码引发了异常，python 将查找与之匹配的 except 代码块并运行其中的代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 程序停止，显示 traceback</span>
</span></span><span style=display:flex><span>print(<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 程序继续执行，异常被捕获并运行 except 代码块中的代码</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;You can&#39;t divide by zero&#34;</span>)
</span></span></code></pre></div><p><strong>静默失败</strong></p><p>每次捕获到异常时，可能不需要告诉用户，想让程序保持静默，这里就可以使用 <code>pass</code> 语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_words</span>(filename):
</span></span><span style=display:flex><span>	<span style=color:#75715e># 计算一个文件大致包含多少个单词</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>--</span>snip<span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>except</span> <span style=color:#a6e22e>FileNotFoundError</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>--</span>snip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>filenames <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;2&#39;</span>, <span style=color:#e6db74>&#39;3&#39;</span>, <span style=color:#e6db74>&#39;4&#39;</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> filename <span style=color:#f92672>in</span> filenames:
</span></span><span style=display:flex><span>	count_words(filename)
</span></span></code></pre></div><p>假设文件 “3” 不存在，python 在执行上述代码时，只会打印 1、2、4 的单词数，不会有任何 traceback</p><h2 id=django>Django<a hidden class=anchor aria-hidden=true href=#django>#</a></h2><p>Django 是一个高级的 <strong>Python Web 框架</strong>，采用了模型-视图-控制器（MVC）的架构模式，能够快速、高效地构建 Web 应用程序。</p><p>在 PyCharm 中创建一个 Django 项目，PyCharm 会自动构建项目需要的虚拟环境，下面是完成创建的目录结构。</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/03/J1Zku7IUTGyeFSC.png></p><p>目录 learning_log 包含 5 个文件，最重要的是 settings.py、urls.py 和 wsgi.py。</p><ul><li>settings.py：指定 Django 如何与系统交互以及如何管理项目，可以根据具体需求，选择修改一些设置并添加一些设置</li><li>urls.py：该文件告诉 Django 应该创建哪些页面来响应浏览器请求</li><li>wsgi.py：wsgi 是 <strong>Web Server Gateway Interface</strong> 的缩写，在 Django 项目中，<code>wsgi.py</code> 文件是启动 WSGI 服务器的入口文件，它负责创建一个 WSGI 应用程序对象，加载 Django 项目的配置（设置 <code>DJANGO_SETTINGS_MODULE</code> 环境变量指定配置文件 ），并将应用程序对象传递给 WSGI 服务器，使服务器能处理传入的 HTTP 请求</li><li>asgi.py(补充)：asgi 是 Asynchronous Server Gateway Interface 的缩写，是异步服务器网关接口，是对 wsgi 的扩展，用于处理异步 Web 请求，能更好地支持异步编程和 WebSocket 等长连接操作</li></ul><h3 id=创建数据库>创建数据库<a hidden class=anchor aria-hidden=true href=#创建数据库>#</a></h3><p>首先创建一个供 Django 使用的数据库，在终端执行下面的指令：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/03/kpstZbCAw4zm1T3.png></p><p>我们将修改数据库成为 <strong>迁移</strong> 数据库，首次执行 migrate 命令时，将让 Django 确保数据库与项目的当前状态匹配。在使用 SQLite 的新项目中首次执行这个命令时，Django 将新建一个数据库。<strong>SQLite 是一种使用单个文件的数据库</strong>，不用太关注数据库管理的问题。</p><h3 id=查看项目>查看项目<a hidden class=anchor aria-hidden=true href=#查看项目>#</a></h3><p>可以使用 runserver 查看项目的状态：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/03/gl6YKfxzSTkPNdw.png></p><p>Django 启动了一个名为 development server 的服务器，此时使用浏览器访问 <code>http://localhost:8000/</code> 以请求页面，Django 服务器将进行相应，生成合适的页面并发送给浏览器，如下图：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/03/PJFz4wBdyfxrTop.png></p><h3 id=应用程序>应用程序<a hidden class=anchor aria-hidden=true href=#应用程序>#</a></h3><p>在 Django 中，应用程序（app）是一个具备独立功能的模块，类似于 java spring 框架的 module。</p><p>每个 Django 应用程序专注于一个特定的功能领域，比如博客项目可以有一个 “文章” 应用程序，专门负责文章的创建、编辑、展示和删除操作；还可以有一个 “评论” 应用程序，用于处理用户对文章的评论功能</p><p>一个新创建的应用程序如下图</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/nuEherN213HRX9j.png></p><p>应用程序中各个 <code>.py</code> 文件的作用：</p><ul><li><strong><code>__init__.py</code></strong>：Python 中用于标识该目录是一个 Python 包，早期可用于导入包时执行初始化代码，现在空文件也能让目录成为包，方便模块组织和管理</li><li><strong><code>admin.py</code></strong>：用于注册模型到 Django 自带的后台管理系统，注册后可在后台对相应模型数据进行增删改查等操作 ，方便管理网站数据</li><li><strong><code>apps.py</code></strong>：定义应用程序的配置类（<code>AppConfig</code>），可配置应用元数据和行为，如设置应用名称、标签；重写 <code>ready()</code> 方法可执行启动初始化操作，像信号注册</li><li><strong><code>models.py</code></strong>：定义数据模型，即映射数据库表结构，每个模型类对应数据库一张表，类中的字段对应表中的列，通过它可进行数据库交互，实现数据存储、查询、修改、删除等操作</li><li><strong><code>tests.py</code></strong>：编写测试代码的地方，用于对应用程序功能进行自动化测试，确保应用按预期工作，提高代码稳定性和可靠性，比如测试视图逻辑、模型方法等是否正确</li><li><strong><code>views.py</code></strong>：处理业务逻辑，接收用户请求，根据请求进行数据处理（可能涉及调用模型获取数据），然后选择合适模板渲染并返回响应给用户</li></ul><h4 id=定义模型>定义模型<a hidden class=anchor aria-hidden=true href=#定义模型>#</a></h4><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/KwiQrs1ImlSzZth.png></p><p>此处定义了一个 Topic 类，继承 Model，在该类中添加了两个属性：text 和 date_added，表示用户在学习笔记中创建的主题。</p><p>属性 text 是一个 CharField —— 由字符组成的数据，属性 date_added 是一个 DateTimeField —— 记录日期和时间的数据。</p><h4 id=激活模型>激活模型<a hidden class=anchor aria-hidden=true href=#激活模型>#</a></h4><p>要使用模型，必须让 Django 将上面的应用程序包含到项目中，这里就需要修改 settings.py 文件，其中有个片段告诉 Django 哪些应用程序被安装到了项目中并将协同工作，在里面添加自己的应用程序即可。</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/hHWFp4VizMs6BUL.png></p><p>注意，这里务必将自己创建的应用程序放到默认应用程序前面，<strong>这样能够覆盖默认应用程序的行为</strong>。</p><p>接下来，需要让 Django 修改数据库，使其能够存储与模型 Topic 相关的信息，为此，在终端窗口中执行下面的命令：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/qEBDusGhbiFA41d.png></p><p>输出表明 Django 创建了一个名为 <code>0001_initial.py</code> 的迁移文件，这个文件将在数据库中为模型 Topic 创建一个表。</p><p>补充：Django 中的 <strong>迁移</strong> 是管理数据库结构变化的一种机制，用于在开发过程中修改模型（Model）并同步数据库的变化。当对 Django 模型进行更改时，迁移会记录这些变化，每次修改后运行 <code>python manage.py makemigrations</code> 命令，Django 会生成迁移文件，该文件记录了从一个数据库状态到另一个状态需要执行的操作，比如下图中的 <code>0001_initial.py</code> 迁移文件：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/ikVgS5I6mYfz9l1.png></p><p>下面应用这种迁移，让 Django 替我们修改数据库：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/05/04/7sMfLJ3xSFNBOCG.png></p><p>每当需要修改 “学习笔记” 管理的数据时，都采取如下三个步骤：修改 <code>models.py</code>，对 <code>learning_logs</code> 调用 <code>makemigrations</code>，以及让 Django 迁移项目</p><h4 id=django-管理网站>Django 管理网站<a hidden class=anchor aria-hidden=true href=#django-管理网站>#</a></h4></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yuk1pedia.github.io/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>