<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>云原生 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="云原生 - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yukipedia.cn/notes/2025-4-25-cloud_native/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/notes/2025-4-25-cloud_native/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/notes/2025-4-25-cloud_native/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="云原生"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-04-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="云原生"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yukipedia.cn/notes/"},{"@type":"ListItem","position":2,"name":"云原生","item":"https://yukipedia.cn/notes/2025-4-25-cloud_native/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"云原生","name":"云原生","description":"","keywords":[],"articleBody":"什么是云原生？ 云原生是一种构建和运行应用程序的方法，它利用云计算的优势，使应用程序能够更好地适应云环境的动态性、弹性和分布式特性。云原生技术体系包含容器、容器编排、微服务、服务网格、不可变基础设施等一系列技术和理念。\n弹性伸缩：能够根据业务负载的变化自动调整资源，实现快速的扩缩容，以确保应用程序始终能够以最佳性能运行 高可用性：通过多副本、故障转移等机制，保证应用程序在部分组件出现故障时仍能正常运行，提供持续的服务 敏捷开发与部署：支持快速迭代和频繁部署，开发团队可以更高效地进行应用程序的开发、测试和上线 资源高效利用：容器化技术使得多个应用程序可以共享底层基础设施资源，提高资源的利用率，降低成本 云原生代表技术 容器 一般我们说的“容器”（LinuxContainer，LXC），都是 “Linux容器” 。开源解决方案供应商红帽官网给出的容器定义：Linux® 容器是与系统其他部分隔离开的一系列进程。运行这些进程所需的所有文件都由另一个镜像提供，这意味着从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。\n容器提供进程级的隔离，可以将操作系统管理的资源划分到相互隔离的组中，在相互隔离的组之间解决资源使用存在冲突的问题。比如 APP1 只能在 centOS 上运行，APP2 只能在 Ubuntu 上运行，而同一个操作系统同时运行 APP1 和 APP2 就产生冲突，容器技术则恰恰可以解决这类问题。\nDocker Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，即：整个操作系统的文件系统也打包了进去。Docker 项目大大降低了容器技术的使用门槛，轻量级，可移植，虚拟化，语言无关，写了程序扔上去做成镜像可以随处部署和运行，开发、测试和生产环境彻底统一了，还能进行资源管控和虚拟化。\n典型的 Docker 平台包括 Kubernetes、Openshift V3 等。一句话解释 Docker？\n没有集装箱就没有全球化，Docker 就是 IT 世界里的集装箱。\nKubernetes 有了容器，就需要编排管理容器的生命周期，K8s 就是一个通用容器编排调度器，用于编排管理容器的生命周期。\n一个 K8s 集群，主要包括两个部分：一个 Master 节点和一群 Node 节点。\nMaster（主节点）：控制 K8s 节点的机器，也是创建作业任务的地方 Node（节点）：这些机器在 K8s 主节点的控制下执行被分配的任务，一个 Node 可能会运行多个 Pod，Pod 中的容器共同协作来提供某种服务 Pod：K8s 中最小的可部署和可管理的计算单元，由一个或多个容器构成的集合，作为一个整体被部署到一个单一节点。同一个 Pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷 Replicationcontroller：控制一个 Pod 在集群上运行的实例数量，用于确保 Pod 的副本数量始终保持在指定的数量 Service：用来暴露 Pod 的一种抽象机制，可以把它想象成一个 “网关” 或者 “地址簿”。因为 Pod 可能会在不同的 Node 上被创建、销毁或者重新调度，它们的 IP 地址是动态变化的。而 Service 为 Pod 提供了一个固定的 IP 地址和 DNS 名称，其他应用程序可以通过这个固定的地址来访问 Pod 提供的服务，而不需要关心 Pod 具体在哪个节点上以及其 IP 地址的变化 Kubelet：这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行 K8s 的出现与其说是从最初的容器编排解决方案开始，倒不如说是为了解决应用上云（即云原生应用）这个难题。\n微服务 微服务的核心是将传统的大单体应用拆为更小的组件或模块，组件或模块就叫微服务。这个拆分是一个纵向的拆分，需要做到从底层的基础设施 → 数据库 → 应用中间件 → 软件应用部署包都能做到完全独立的一套，尽量实现彻底的 松耦合。同时，各个微服务之间又能通过轻量的 http rest 接口进行交互和协同。核心就两点：大的单体要拆分，晓得微服务接口要通过轻量的 http rest 接口协同\nIaaS、PaaS 和 SaaS IaaS（Infrastructure-as-a-Service，基础设施即服务） 提供给消费者的服务是对所有设施的利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。主要功能就是将底层的硬件资源以服务的方式对外暴露，为上层提供服务。\nIaaS 模式下，只提供云计算服务的基础设施，用户可以根据自己的需求在云端租用服务器、存储空间、网络带宽等基础设施，就像在本地拥有自己的机房一样，但无需实际购买和维护硬件设备。\n适用于对基础设施有高度控制权和定制化需求的用户，如大型企业的自有数据中心迁移到云端、需要自行安装和配置操作系统及软件的开发团队等。\nPaaS（Platform-as-a-Service，平台即服务） 在 IaaS 的基础上，提供一个完整的开发和运行平台，包括操作系统、数据库、中间件、开发工具等。用户可以在这个平台上快速开发、测试和部署应用程序，无需关注底层基础设施的管理和维护。\nPaaS 平台为开发者提供了一系列的开发工具和框架，比如常见的编程语言运行环境（像 Java、Python 等）、数据库管理系统（如 MySQL、Oracle），还有各种中间件等。开发者不需要自己在本地电脑或服务器上安装和配置这些软件，直接在 PaaS 平台上就可以开始编写代码开发应用程序。\n当开发者把应用程序开发好后，可以很方便地将其部署到 PaaS 平台上。平台会自动处理应用程序运行所需的各种资源配置，比如服务器的分配、网络设置等，开发者不用像以前那样手动去配置这些复杂的环境，只需要简单操作几步就能让应用程序上线运行。\nPaaS 平台还承担了应用程序的运维工作。它会自动监控应用的运行状态，比如查看服务器的性能指标、应用的响应时间等。如果发现问题，平台能自动进行一些处理，像自动扩展服务器资源来应对访问量的突然增加，或者在出现故障时自动进行恢复。开发者不用专门去关注服务器是不是出故障了、软件是不是需要更新等问题，平台都能帮着处理好。\nSaaS（Software-as-a-Service，软件即服务） 直接提供软件应用程序服务，用户通过互联网访问和使用软件，无需在本地安装和维护软件。软件供应商负责软件的部署、升级和维护等工作，用户只需按照使用量或订阅模式支付费用。\n","wordCount":"142","inLanguage":"en","datePublished":"2025-04-25T00:00:00Z","dateModified":"2025-04-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/notes/2025-4-25-cloud_native/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">云原生</h1><div class=post-meta><span title='2025-04-25 00:00:00 +0000 UTC'>April 25, 2025</span></div></header><div class=post-content><h2 id=什么是云原生>什么是云原生？<a hidden class=anchor aria-hidden=true href=#什么是云原生>#</a></h2><p>云原生是一种构建和运行应用程序的方法，它利用云计算的优势，使应用程序能够更好地适应云环境的动态性、弹性和分布式特性。云原生技术体系包含容器、容器编排、微服务、服务网格、不可变基础设施等一系列技术和理念。</p><ul><li><strong>弹性伸缩</strong>：能够根据业务负载的变化自动调整资源，实现快速的扩缩容，以确保应用程序始终能够以最佳性能运行</li><li><strong>高可用性</strong>：通过多副本、故障转移等机制，保证应用程序在部分组件出现故障时仍能正常运行，提供持续的服务</li><li><strong>敏捷开发与部署</strong>：支持快速迭代和频繁部署，开发团队可以更高效地进行应用程序的开发、测试和上线</li><li><strong>资源高效利用</strong>：容器化技术使得多个应用程序可以共享底层基础设施资源，提高资源的利用率，降低成本</li></ul><h2 id=云原生代表技术>云原生代表技术<a hidden class=anchor aria-hidden=true href=#云原生代表技术>#</a></h2><h3 id=容器>容器<a hidden class=anchor aria-hidden=true href=#容器>#</a></h3><p>一般我们说的“容器”（LinuxContainer，LXC），都是 “Linux容器” 。开源解决方案供应商红帽官网给出的容器定义：Linux® 容器是与系统其他部分隔离开的一系列进程。运行这些进程所需的所有文件都由另一个镜像提供，这意味着从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。</p><p><strong>容器提供进程级的隔离</strong>，可以将操作系统管理的资源划分到相互隔离的组中，在相互隔离的组之间解决资源使用存在冲突的问题。比如 APP1 只能在 centOS 上运行，APP2 只能在 Ubuntu 上运行，而同一个操作系统同时运行 APP1 和 APP2 就产生冲突，<strong>容器技术</strong>则恰恰可以解决这类问题。</p><h3 id=docker>Docker<a hidden class=anchor aria-hidden=true href=#docker>#</a></h3><p>Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，<strong>即：整个操作系统的文件系统也打包了进去</strong>。Docker 项目大大降低了容器技术的使用门槛，轻量级，可移植，虚拟化，语言无关，写了程序扔上去做成镜像可以随处部署和运行，开发、测试和生产环境彻底统一了，还能进行资源管控和虚拟化。</p><p>典型的 Docker 平台包括 <strong>Kubernetes</strong>、Openshift V3 等。一句话解释 Docker？</p><p><strong>没有集装箱就没有全球化，Docker 就是 IT 世界里的集装箱</strong>。</p><h3 id=kubernetes>Kubernetes<a hidden class=anchor aria-hidden=true href=#kubernetes>#</a></h3><p>有了容器，就需要编排管理容器的生命周期，K8s 就是一个通用容器编排调度器，用于编排管理容器的生命周期。</p><p>一个 K8s 集群，主要包括两个部分：一个 Master 节点和一群 Node 节点。</p><ul><li><strong>Master（主节点）</strong>：控制 K8s 节点的机器，也是创建作业任务的地方</li><li><strong>Node（节点）</strong>：这些机器在 K8s 主节点的控制下执行被分配的任务，一个 Node 可能会运行多个 Pod，Pod 中的容器共同协作来提供某种服务</li><li>Pod：<strong>K8s 中最小的可部署和可管理的计算单元</strong>，由一个或多个容器构成的集合，作为一个整体被部署到一个单一节点。同一个 Pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷</li><li><strong>Replicationcontroller</strong>：控制一个 Pod 在集群上运行的实例数量，用于确保 Pod 的副本数量始终保持在指定的数量</li><li><strong>Service</strong>：用来暴露 Pod 的一种抽象机制，可以把它想象成一个 “网关” 或者 “地址簿”。<strong>因为 Pod 可能会在不同的 Node 上被创建、销毁或者重新调度，它们的 IP 地址是动态变化的</strong>。而 Service 为 Pod 提供了一个固定的 IP 地址和 DNS 名称，其他应用程序可以通过这个固定的地址来访问 Pod 提供的服务，而不需要关心 Pod 具体在哪个节点上以及其 IP 地址的变化</li><li><strong>Kubelet</strong>：这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行</li></ul><p>K8s 的出现与其说是从最初的容器编排解决方案开始，倒不如说是<strong>为了解决应用上云</strong>（即云原生应用）这个难题。</p><h3 id=微服务>微服务<a hidden class=anchor aria-hidden=true href=#微服务>#</a></h3><p>微服务的核心是将传统的大单体应用拆为更小的组件或模块，<strong>组件或模块就叫微服务</strong>。这个拆分是一个纵向的拆分，需要做到从底层的基础设施 → 数据库 → 应用中间件 → 软件应用部署包都能做到完全独立的一套，尽量实现彻底的 <strong>松耦合</strong>。同时，各个微服务之间又能通过轻量的 http rest 接口进行交互和协同。核心就两点：大的单体要拆分，晓得微服务接口要通过轻量的 http rest 接口协同</p><h2 id=iaaspaas-和-saas>IaaS、PaaS 和 SaaS<a hidden class=anchor aria-hidden=true href=#iaaspaas-和-saas>#</a></h2><h3 id=iaasinfrastructure-as-a-service基础设施即服务>IaaS（Infrastructure-as-a-Service，基础设施即服务）<a hidden class=anchor aria-hidden=true href=#iaasinfrastructure-as-a-service基础设施即服务>#</a></h3><p>提供给消费者的服务是对所有设施的利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。主要功能就是<strong>将底层的硬件资源以服务的方式对外暴露，为上层提供服务</strong>。</p><p>IaaS 模式下，只提供云计算服务的基础设施，用户可以根据自己的需求在云端租用服务器、存储空间、网络带宽等基础设施，就像在本地拥有自己的机房一样，但无需实际购买和维护硬件设备。</p><p>适用于对基础设施有高度控制权和定制化需求的用户，如大型企业的自有数据中心迁移到云端、需要自行安装和配置操作系统及软件的开发团队等。</p><h3 id=paasplatform-as-a-service平台即服务>PaaS（Platform-as-a-Service，平台即服务）<a hidden class=anchor aria-hidden=true href=#paasplatform-as-a-service平台即服务>#</a></h3><p>在 IaaS 的基础上，提供一个完整的开发和运行平台，包括操作系统、数据库、中间件、开发工具等。用户可以在这个平台上快速开发、测试和部署应用程序，无需关注底层基础设施的管理和维护。</p><p>PaaS 平台为开发者提供了一系列的开发工具和框架，比如常见的编程语言运行环境（像 Java、Python 等）、数据库管理系统（如 MySQL、Oracle），还有各种中间件等。开发者不需要自己在本地电脑或服务器上安装和配置这些软件，直接在 PaaS 平台上就可以开始编写代码开发应用程序。</p><p>当开发者把应用程序开发好后，可以很方便地将其部署到 PaaS 平台上。平台会自动处理应用程序运行所需的各种资源配置，比如服务器的分配、网络设置等，开发者不用像以前那样手动去配置这些复杂的环境，只需要简单操作几步就能让应用程序上线运行。</p><p>PaaS 平台还承担了应用程序的运维工作。它会自动监控应用的运行状态，比如查看服务器的性能指标、应用的响应时间等。如果发现问题，平台能自动进行一些处理，像自动扩展服务器资源来应对访问量的突然增加，或者在出现故障时自动进行恢复。开发者不用专门去关注服务器是不是出故障了、软件是不是需要更新等问题，平台都能帮着处理好。</p><h3 id=saassoftware-as-a-service软件即服务>SaaS（Software-as-a-Service，软件即服务）<a hidden class=anchor aria-hidden=true href=#saassoftware-as-a-service软件即服务>#</a></h3><p>直接提供软件应用程序服务，用户通过互联网访问和使用软件，无需在本地安装和维护软件。软件供应商负责软件的部署、升级和维护等工作，用户只需按照使用量或订阅模式支付费用。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>