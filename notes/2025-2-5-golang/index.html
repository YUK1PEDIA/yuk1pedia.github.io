<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go基础学习笔记 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="Go基础学习笔记 - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yukipedia.cn/notes/2025-2-5-golang/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/notes/2025-2-5-golang/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/notes/2025-2-5-golang/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="Go基础学习笔记"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go基础学习笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://yukipedia.cn/notes/"},{"@type":"ListItem","position":2,"name":"Go基础学习笔记","item":"https://yukipedia.cn/notes/2025-2-5-golang/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go基础学习笔记","name":"Go基础学习笔记","description":"","keywords":[],"articleBody":"[TOC]\n主要特征 语法简单，自带 gc 静态编译，编译好后在服务器直接运行 简单的思想，没有继承、多态、类等 语法层支持并发，拥有同步并发的 channel 类型，使并发开发变得非常方便 内置类型丰富，函数多返回值 反射 Golang 内置类型和函数 内置类型 值类型\nbool int(32 or 64), int8, int16, int32, int64 uint(32 or 64), uint8(byte), uint16, uint32, uint64 float32, float64 string complex64, complex128 array -- 固定长度的数组 引用类型（指针类型）\nslice -- 序列数组(最常用) map -- 映射 chan -- 管道 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。\nappend -- 用来追加元素到数组、slice中,返回修改后的数组、slice close -- 主要用来关闭channel delete -- 从map中删除key对应的value panic -- 停止常规的goroutine （panic和recover：用来做错误处理） recover -- 允许程序定义goroutine的panic动作 imag -- 返回complex的实部 （complex、real imag：用于创建和操作复数） real -- 返回complex的虚部 make -- 用来分配内存，返回Type本身(只能应用于slice, map, channel) new -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 cap -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） copy -- 用于复制和连接slice，返回复制的数目 len -- 来求长度，比如string、array、slice、map、channel ，返回长度 print、println -- 底层打印函数，在部署环境中建议使用 fmt 包 内置接口\ntype error interface { //只要实现了Error()函数，返回值为String的都实现了err接口 Error() String } init 函数和 main 函数 init 函数 go 语言中 init 函数用于包（package）的初始化，该函数是 go 语言的一个重要特性。\ninit 函数有如下特征：\ninit 函数是用于程序执行前做包初始化的函数，比如初始化包里的变量等 每个包可以拥有多个 init 函数 包的每个源文件也可以拥有多个 init 函数 同一个包中多个 init 函数的执行顺序 go 语言没有明确的说明 不同包的 init 函数按照包导入的依赖关系决定该初始化函数的执行顺序 init 函数不能被其他函数调用，而是在 main 函数执行之前自动被调用 main 函数 Go语言程序的默认入口函数(主函数)：func main()\nfunc main() { // 函数体 } 两种函数的异同 相同点：\n两个函数在定义时不能有任何的参数和返回值，且 Go 程序自动调用 不同点：\ninit 函数可以应用于任意包中，且可以重复定义多个 main 函数只能用于 main 包中，且只能定义一个 两个函数的执行顺序：\n同一个 go 文件中的 init() 调用顺序是从上到下的 同一个 package 中不同文件是按文件名字符串比较 “从小到大” 顺序调用各文件中的 init() 函数 对于不同的 package ，如果不相互依赖的话，按照 main 包中 “先 import 的后调用” 的顺序调用包中的 init() ，如果 package 存在依赖，则先调用最早被以来的 package 中的 init() ，最后调用 main 函数 运算符 算术运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符\n关系运算符 运算符 描述 == 检查两个值是否相等，如果相等返回 True 否则返回 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False \u003e 检查左边值是否大于右边值，如果是返回 True 否则返回 False \u003e= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False \u003c 检查左边值是否小于右边值，如果是返回 True 否则返回 False \u003c= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False 逻辑运算符 运算符 描述 \u0026\u0026 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True 位运算符 运算符 描述 \u0026 参与运算的两数各对应的二进位相与（两位均为1才为1） | 参与运算的两数各对应的二进位相或（两位有一个为1就为1） ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1） « 左移 n 位就是乘以 2 的 n 次方。“a « b” 是把 a 的各二进位全部左移 b 位，高位丢弃，低位补 0 » 右移 n 位就是除以 2 的 n 次方。“a » b” 是把 a 的各二进位全部右移 b 位 赋值运算符 运算符 描述 = 将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 «= 左移后赋值 »= 右移后赋值 \u0026= 按位与后赋值 |= 按位或后赋值 ^= 按位异或后赋值 下划线 “_” 是特殊标识符，用来忽略结果\n下划线在 import 中\n当导入一个包时，该包下的文件里所有的 init() 函数都会被执行。如果我们仅仅希望它执行 init() 函数，不想把整个包都导入进来，就可以使用 import _ 包路径 来引用该包\n示例 1：\n代码结构\nsrc | +--- main.go | +--- hello | +--- hello.go package main import _ \"./hello\" func main() { // hello.Print() //编译报错：./main.go:6:5: undefined: hello } hello.go\npackage hello import \"fmt\" func init() { fmt.Println(\"imp-init() come here.\") } func Print() { fmt.Println(\"Hello!\") } 输出结果：\nimp-init() come here. 示例 2：\nimport \"database/sql\" import _ \"github.com/go-sql-driver/mysql\" 第二个 import 就是不直接使用 mysql 包，只是执行这个包的 init() 函数，把 mysql 的驱动注册到 sql 包里，然后程序里就可以使用 sql 包来访问 mysql 数据库了\n下划线在代码中\npackage main import ( \"os\" ) func main() { buf := make([]byte, 1024) f, _ := os.Open(\"/Users/***/Desktop/text.txt\") defer f.Close() for { n, _ := f.Read(buf) if n == 0 { break } os.Stdout.Write(buf[:n]) } } 解释 1：下划线意思是忽略这个变量，比如： os.Open ，返回值为 *os.File, error 普通写法是：f, err := os.Open(\"xxxxxx\") 如果此时不需要知道返回的错误值，就可以用：f, _ := os.Open(\"xxxxxx\") ，如此就忽略了 error 变量 解释 2：下划线作为占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值，所以就把该值赋给下划线，意思是丢掉不要，这样编译器可以更好的优化。 任何类型的单个值都可以丢给下划线，这种情况是占位用的，比如方法返回两个结果，而你只想要一个结果，那另一个就用 “_” 占位 变量与常量 变量 Go 语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且 Go 语言的变量声明后必须使用\nGo 语言的变量声明格式为：\nvar 变量名 变量类型 变量声明以关键字 var 开头，变量类型放在变量的后面，行尾无需分号：\nvar name string var age int var ok bool 每声明一个变量就写一个 var 比较繁琐，Go 语言还支持批量变量声明：\nvar ( a string b int c bool d float32 ) Go 语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为 0 ，字符串变量的默认值为空字符串，布尔型变量默认为false。切片、函数、指针变量的默认为 nil\n当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：\nvar 变量名 类型 = 表达式 // example var name string = \"hello\" var sex int = 1 或者一次初始化多个变量：\nvar name, sex = \"hello\", 1 类型推导：有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化\nvar name = \"hello\" var sex = 1 短变量声明：在函数内部，可以使用更简略的 := 方式声明并初始化变量\npackage main import ( \"fmt\" ) // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m fmt.Println(m, n) } 匿名变量：在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线 _ 表示\nfunc foo() (int, string) { return 10, \"hello\" } func main() { x, _ := foo() _, y := foo() fmt.Println(\"x=\", x) fmt.Println(\"y=\", y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明（在 Lua 等编程语言里，匿名变量也被叫做哑元变量)\n注意事项：\n函数外的每个语句必须以关键字开始（var、const、func 等） := 不能在函数外使用 _ 多用于占位，表示忽略值 常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把 var 换成了 const ，常量在定义的时候必须赋值\nconst pi = 3.1415 const e = 2.7182 声明了 pi 和 e 这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了\n多个常量也可以一起声明：\nconst ( pi = 3.1415 e = 2.7182 ) const 同时声明多个常量时，如果省略了值则表示和上面一行的值相同\nconst ( n1 = 100 n2 n3 ) 常量 n1 、n2、n3 的值均为 100\niota：iota 是 Go 语言的常量计数器，只能在常量的表达式中使用。 iota 在 const 关键字出现时将被重置为 0 。const 中每新增一行常量声明将使 iota 计数一次（iota 可理解为 const 语句块中的行索引）。 使用 iota 能简化定义，在定义枚举时很有用\nconst ( n1 = 100 // 0 n2\t// 1 n3\t// 2 ) 使用 _ 跳过某些值：\nconst ( n1 = 100 // 0 n2\t// 1 _\tn3\t// 3 ) 使用示例：\nconst ( n1 = iota // 0 n2 = 100 n3 = iota // 2 n4 // 3 ) const n5 = iota // 0 定义数量级：\nconst ( _ = iota KB = 1 \u003c\u003c (10 * iota) MB = 1 \u003c\u003c (10 * iota) GB = 1 \u003c\u003c (10 * iota) TB = 1 \u003c\u003c (10 * iota) PB = 1 \u003c\u003c (10 * iota) ) 多个 iota 定义在一行：\nconst ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) 基本类型 整形：整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64 。其中，uint8 就是 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型\n浮点型：Go语言支持两种浮点型数：float32 和 float64 。这两种浮点型数据格式遵循 IEEE 754 标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64\n复数：complex64 和 complex128 ，复数有实部和虚部，complex64 的实部和虚部为 32 位，complex128 的实部和虚部为 64 位\n布尔值：Go语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true 和 false 两个值\n注意：布尔类型变量的默认值为 false ，Go 语言中不允许将整型强制转换为布尔型，布尔型无法参与数值运算，也无法与其他类型进行转换 字符串：Go 语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用 UTF-8 编码。 字符串的值为双引号中的内容，可以在Go语言的源码中直接添加非 ASCII 码字符，例如：\ns1 := \"hello\" s2 := \"你好\" // 非 ASCII码 多行字符串：Go 语言中使用反引号定义多行字符串，例如：\ns1 := `第一行 第二行 第三行 ` fmt.Println(s1) 字符串常用操作：\n方法 介绍 len(str) 求长度 + 或 fmt.Sprintf 拼接字符串 strings.Split 分割字符串 strings.Contains 判断是否包含 strings.HasPrefix, strings.HasSuffix 前缀/后缀判断 strings.Index(), strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join 操作 byte 和 rune 类型：\n组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号 ’ 包裹起来，如：\nvar a := '中' var b := 'x' Go 语言的字符有以下两种：\nuint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符 rune 类型，代表一个 UTF-8 字符 当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32 。 Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾\n// 遍历字符串 func traversalString() { s := \"pprof.cn博客\" for i := 0; i \u003c len(s); i++ { //byte fmt.Printf(\"%v(%c) \", s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(\"%v(%c) \", r, r) } fmt.Println() } 输出如下：\n112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢) 112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客) 因为 UTF8 编码下一个中文汉字由 3~4 个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果 字符串底层是一个 byte 数组，所以可以和 []byte 类型相互转换。 rune 类型用来表示 UTF-8 字符，一个 rune 字符由一个或多个 byte 组成，注意：字符串是不能修改的 修改字符串：要修改字符串，需要先将其转换成 []rune 或 []byte ，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组\nfunc changeString() { s1 := \"hello\" // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = 'H' fmt.Println(string(byteS1)) // 输出：Hello s2 := \"博客\" runeS2 := []rune(s2) runeS2[0] = '狗' fmt.Println(string(runeS2)) // 输出：狗客 } 类型转换：Go 语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用\n基本语法：\nT(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等\n比如计算直角三角形的斜边长时使用 math 包的 Sqrt() 函数，该函数接收的是 float64 类型的参数，而变量 a 和 b 都是 int 类型的，这个时候就需要将 a 和 b 强制类型转换为 float64 类型\nfunc sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } 数组 Array 数组定义：\nvar a [len]int 比如：var a [5]int ，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变 长度是数组类型的一部分，因此，var a[5]int 和 var a[10]int 是不同的类型 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值 指针数组 [n]*T，数组指针 *[n]T 一维数组\n// 全局： var arr0 [5]int = [5]int{1, 2, 3} var arr1 = [5]int{1, 2, 3, 4, 5} var arr2 = [...]int{1, 2, 3, 4, 5, 6} var str = [5]string{3: \"hello world\", 4: \"tom\"} // 局部： a := [3]int{1, 2} // 未初始化元素值为 0。 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。 c := [5]int{2: 100, 4: 200} // 使用索引号初始化元素。 d := [...]struct { name string age uint8 }{ {\"user1\", 10}, // 可省略元素类型。 {\"user2\", 20}, // 别忘了最后一行的逗号。 } package main import ( \"fmt\" ) var arr0 [5]int = [5]int{1, 2, 3} var arr1 = [5]int{1, 2, 3, 4, 5} var arr2 = [...]int{1, 2, 3, 4, 5, 6} var str = [5]string{3: \"hello world\", 4: \"tom\"} func main() { a := [3]int{1, 2} // 未初始化元素值为 0。 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。 c := [5]int{2: 100, 4: 200} // 使用引号初始化元素。 d := [...]struct { name string age uint8 }{ {\"user1\", 10}, // 可省略元素类型。 {\"user2\", 20}, // 别忘了最后一行的逗号。 } fmt.Println(arr0, arr1, arr2, str) fmt.Println(a, b, c, d) } 输出结果： [1 2 3 0 0] [1 2 3 4 5] [1 2 3 4 5 6] [ hello world tom] [1 2 0] [1 2 3 4] [0 0 100 0 200] [{user1 10} {user2 20}] 多维数组 \u0026 多维数组遍历\n参考：https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84Array.html 数组拷贝和传参\npackage main import \"fmt\" func printArr(arr *[5]int) { arr[0] = 10 // 循环中 i 是元素下标，v 是元素数值 for i, v := range arr { fmt.Println(i, v) } } func main() { var arr1 [5]int printArr(\u0026arr1) fmt.Println(arr1) arr2 := [...]int{2, 4, 6, 8, 10} printArr(\u0026arr2) fmt.Println(arr2) } 输出结果： 0 10 1 0 2 0 3 0 4 0 [10 0 0 0 0] 0 10 1 4 2 6 3 8 4 10 [10 4 6 8 10] 切片 Slice slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案\n切片是数组的一个引用，但自身是结构体，通过值拷贝传递\n切片的长度可以改变，因此切片是一个可变数组\n切片遍历方式和数组一样，可以用 len() 求长度，表示可用元素数量，读写操作不能超过该限制\ncap() 可以求出切片最大扩张容量，不能超出数组限制：0 \u003c= len(slice) \u003c= len(array) ，其中 array 是 slice 引用的数组\n定义：var 变量名 []类型 ，比如：var str []string 、var arr []int\n如果 slice == nil ，那么 len()、cap() 结果都等于 0\n创建切片的各种方式\npackage main import \"fmt\" func main() { //1.使用 var 声明切片 s1，s1 是一个 nil 切片，没有分配内存 var s1 []int if s1 == nil { fmt.Println(\"是空\") } else { fmt.Println(\"不是空\") } // 2.使用 := 简短声明，创建切片 s2 并初始化为空切片 // 空切片与 nil 切片不同，空切片底层数组已分配内存，但是容量为 0，而 nil 切片没有分配内存 s2 := []int{} // 3.使用 make() 创建切片，可以指定切片长度和容量 var s3 []int = make([]int, 0) fmt.Println(s1, s2, s3) // 4.初始化赋值 var s4 []int = make([]int, 0, 0) fmt.Println(s4) s5 := []int{1, 2, 3} fmt.Println(s5) // 5.从数组切片 arr := [5]int{1, 2, 3, 4, 5} var s6 []int // 前包后不包 s6 = arr[1:4] fmt.Println(s6) } 注意：切片的长度是当前切片存储的元素数量，通过 len() 获取切片长度；切片容量是从切片的起始位置到底层数组的末尾的元素数量，也就是切片能容纳的元素的最大数量，通过 cap() 获取切片长度\n切片初始化\n// 全局： var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} var slice0 []int = arr[start:end] var slice1 []int = arr[:end] var slice2 []int = arr[start:] var slice3 []int = arr[:] var slice4 = arr[:len(arr)-1] //去掉切片的最后一个元素 // 局部： arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} slice5 := arr[start:end] slice6 := arr[:end] slice7 := arr[start:] slice8 := arr[:] slice9 := arr[:len(arr)-1] //去掉切片的最后一个元素 package main import ( \"fmt\" ) var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} var slice0 []int = arr[2:8] var slice1 []int = arr[0:6] //可以简写为 var slice []int = arr[:end] var slice2 []int = arr[5:10] //可以简写为 var slice[]int = arr[start:] var slice3 []int = arr[0:len(arr)] //var slice []int = arr[:] var slice4 = arr[:len(arr)-1] //去掉切片的最后一个元素 func main() { fmt.Printf(\"全局变量：arr %v\\n\", arr) fmt.Printf(\"全局变量：slice0 %v\\n\", slice0) fmt.Printf(\"全局变量：slice1 %v\\n\", slice1) fmt.Printf(\"全局变量：slice2 %v\\n\", slice2) fmt.Printf(\"全局变量：slice3 %v\\n\", slice3) fmt.Printf(\"全局变量：slice4 %v\\n\", slice4) fmt.Printf(\"-----------------------------------\\n\") arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0} slice5 := arr[2:8] slice6 := arr[0:6] //可以简写为 slice := arr[:end] slice7 := arr[5:10] //可以简写为 slice := arr[start:] slice8 := arr[0:len(arr)] //slice := arr[:] slice9 := arr[:len(arr)-1] //去掉切片的最后一个元素 fmt.Printf(\"局部变量： arr2 %v\\n\", arr2) fmt.Printf(\"局部变量： slice5 %v\\n\", slice5) fmt.Printf(\"局部变量： slice6 %v\\n\", slice6) fmt.Printf(\"局部变量： slice7 %v\\n\", slice7) fmt.Printf(\"局部变量： slice8 %v\\n\", slice8) fmt.Printf(\"局部变量： slice9 %v\\n\", slice9) } 输出结果： 全局变量：arr [0 1 2 3 4 5 6 7 8 9] 全局变量：slice0 [2 3 4 5 6 7] 全局变量：slice1 [0 1 2 3 4 5] 全局变量：slice2 [5 6 7 8 9] 全局变量：slice3 [0 1 2 3 4 5 6 7 8 9] 全局变量：slice4 [0 1 2 3 4 5 6 7 8] ----------------------------------- 局部变量： arr2 [9 8 7 6 5 4 3 2 1 0] 局部变量： slice5 [2 3 4 5 6 7] 局部变量： slice6 [0 1 2 3 4 5] 局部变量： slice7 [5 6 7 8 9] 局部变量： slice8 [0 1 2 3 4 5 6 7 8 9] 局部变量： slice9 [0 1 2 3 4 5 6 7 8] 通过 make 来创建切片\nvar slice []type = make([]type, len) slice := make([]type, len) slice := make([]type, len, cap) 切片的内存布局如下：\n读写操作实际目标是切片指向的底层数组，需要注意索引号的差别\npackage main import ( \"fmt\" ) func main() { data := [...]int{0, 1, 2, 3, 4, 5} s := data[2:4] s[0] += 100 s[1] += 200 fmt.Println(s) fmt.Println(data) } 输出如下： [102 203] [0 1 102 203 4 5] 可直接创建 slice 对象，自动分配底层数组\npackage main import \"fmt\" func main() { s1 := []int{0, 1, 2, 3, 8: 100} // 通过初始化表达式构造，可使用索引号。 fmt.Println(s1, len(s1), cap(s1)) s2 := make([]int, 6, 8) // 使用 make 创建，指定 len 和 cap 值。 fmt.Println(s2, len(s2), cap(s2)) s3 := make([]int, 6) // 省略 cap，相当于 cap = len。 fmt.Println(s3, len(s3), cap(s3)) } 输出如下：\n[0 1 2 3 0 0 0 0 100] 9 9 [0 0 0 0 0 0] 6 8 [0 0 0 0 0 0] 6 6 使用 make 动态创建 slice，避免了数组必须用常量做长度的麻烦，还可用指针直接访问底层数组，退化成普通数组操作\npackage main import \"fmt\" func main() { s := []int{0, 1, 2, 3} p := \u0026s[2] // *int, 获取底层数组元素指针。 *p += 100 fmt.Println(s) } 输出：\n[0 1 102 3] 使用 append 操作切片\npackage main import ( \"fmt\" ) func main() { var a = []int{1, 2, 3} fmt.Printf(\"slice a : %v\\n\", a) var b = []int{4, 5, 6} fmt.Printf(\"slice b : %v\\n\", b) c := append(a, b...) fmt.Printf(\"slice c : %v\\n\", c) d := append(c, 7) fmt.Printf(\"slice d : %v\\n\", d) e := append(d, 8, 9, 10) fmt.Printf(\"slice e : %v\\n\", e) } 输出：\nslice a : [1 2 3] slice b : [4 5 6] slice c : [1 2 3 4 5 6] slice d : [1 2 3 4 5 6 7] slice e : [1 2 3 4 5 6 7 8 9 10] append: 向 slice 尾部添加数据，返回新的 slice 对象\npackage main import ( \"fmt\" ) func main() { s1 := make([]int, 0, 5) fmt.Printf(\"%p\\n\", \u0026s1) s2 := append(s1, 1) fmt.Printf(\"%p\\n\", \u0026s2) fmt.Println(s1, s2) } 输出：\n0xc42000a060 0xc42000a080 [] [1] 超出原 slice.cap 限制，就会重新分配底层数组，让该 slice 引用新的底层数组，即使原数组并未填满\npackage main import ( \"fmt\" ) func main() { data := [...]int{0, 1, 2, 3, 4, 10: 0} s := data[:2:3] s = append(s, 100, 200) // 一次 append 两个值，超出 s.cap 限制。 fmt.Println(s, data) // 重新分配底层数组，与原数组无关。 fmt.Println(\u0026s[0], \u0026data[0]) // 比对底层数组起始指针。 } 输出：\n[0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0] 0xc4200160f0 0xc420070060 go 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收\nslice 中 cap 重新分配规律\npackage main import ( \"fmt\" ) func main() { s := make([]int, 0, 1) c := cap(s) for i := 0; i \u003c 50; i++ { s = append(s, i) if n := cap(s); n \u003e c { fmt.Printf(\"cap: %d -\u003e %d\\n\", c, n) c = n } } } 输出：\ncap: 1 -\u003e 2 cap: 2 -\u003e 4 cap: 4 -\u003e 8 cap: 8 -\u003e 16 cap: 16 -\u003e 32 cap: 32 -\u003e 64 切片拷贝\npackage main import ( \"fmt\" ) func main() { s1 := []int{1, 2, 3, 4, 5} fmt.Printf(\"slice s1 : %v\\n\", s1) s2 := make([]int, 10) fmt.Printf(\"slice s2 : %v\\n\", s2) copy(s2, s1) fmt.Printf(\"copied slice s1 : %v\\n\", s1) fmt.Printf(\"copied slice s2 : %v\\n\", s2) s3 := []int{1, 2, 3} fmt.Printf(\"slice s3 : %v\\n\", s3) s3 = append(s3, s2...) fmt.Printf(\"appended slice s3 : %v\\n\", s3) s3 = append(s3, 4, 5, 6) fmt.Printf(\"last slice s3 : %v\\n\", s3) } 输出：\nslice s1 : [1 2 3 4 5] slice s2 : [0 0 0 0 0 0 0 0 0 0] copied slice s1 : [1 2 3 4 5] copied slice s2 : [1 2 3 4 5 0 0 0 0 0] slice s3 : [1 2 3] appended slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0] last slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0 4 5 6] copy: 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠\n应及时讲所需数据 copy 到较小的 slice，以便释放超大号底层数组内存\nslice 遍历\npackage main import ( \"fmt\" ) func main() { data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} slice := data[:] for index, value := range slice { fmt.Printf(\"inde : %v , value : %v\\n\", index, value) } } 输出：\ninde : 0 , value : 0 inde : 1 , value : 1 inde : 2 , value : 2 inde : 3 , value : 3 inde : 4 , value : 4 inde : 5 , value : 5 inde : 6 , value : 6 inde : 7 , value : 7 inde : 8 , value : 8 inde : 9 , value : 9 切片 resize\npackage main import ( \"fmt\" ) func main() { var a = []int{1, 3, 4, 5} fmt.Printf(\"slice a : %v , len(a) : %v\\n\", a, len(a)) b := a[1:2] fmt.Printf(\"slice b : %v , len(b) : %v\\n\", b, len(b)) c := b[0:3] fmt.Printf(\"slice c : %v , len(c) : %v\\n\", c, len(c)) } 输出：\nslice a : [1 3 4 5] , len(a) : 4 slice b : [3] , len(b) : 1 slice c : [3 4 5] , len(c) : 3 字符串与切片\nstring 底层是一个 byte 数组，因此也可以进行切片操作\npackage main import ( \"fmt\" ) func main() { str := \"hello world\" s1 := str[0:5] fmt.Println(s1) s2 := str[6:] fmt.Println(s2) } 输出：\nhello world string 本身是不可变的，要改变 string 中的字符，需要如下操作：\n英文字符串：\npackage main import ( \"fmt\" ) func main() { str := \"Hello world\" s := []byte(str) //中文字符需要用[]rune(str) s[6] = 'G' s = s[:8] s = append(s, '!') str = string(s) fmt.Println(str) } 输出：\nHello Go! 含有中文字符\npackage main import ( \"fmt\" ) func main() { str := \"你好，世界！hello world！\" s := []rune(str) s[3] = '够' s[4] = '浪' s[12] = 'g' s = s[:14] str = string(s) fmt.Println(str) } 输出：\n你好，够浪！hello go ","wordCount":"2846","inLanguage":"en","datePublished":"2025-02-05T00:00:00Z","dateModified":"2025-02-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/notes/2025-2-5-golang/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go基础学习笔记</h1><div class=post-meta><span title='2025-02-05 00:00:00 +0000 UTC'>February 5, 2025</span></div></header><div class=post-content><p>[TOC]</p><h2 id=主要特征>主要特征<a hidden class=anchor aria-hidden=true href=#主要特征>#</a></h2><ul><li>语法简单，自带 gc</li><li>静态编译，编译好后在服务器直接运行</li><li>简单的思想，没有继承、多态、类等</li><li>语法层支持并发，拥有同步并发的 channel 类型，使并发开发变得非常方便</li><li>内置类型丰富，函数多返回值</li><li>反射</li></ul><h2 id=golang-内置类型和函数>Golang 内置类型和函数<a hidden class=anchor aria-hidden=true href=#golang-内置类型和函数>#</a></h2><h3 id=内置类型>内置类型<a hidden class=anchor aria-hidden=true href=#内置类型>#</a></h3><p><strong>值类型</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>int(<span style=color:#ae81ff>32</span> <span style=color:#a6e22e>or</span> <span style=color:#ae81ff>64</span>), <span style=color:#66d9ef>int8</span>, <span style=color:#66d9ef>int16</span>, <span style=color:#66d9ef>int32</span>, <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>uint(<span style=color:#ae81ff>32</span> <span style=color:#a6e22e>or</span> <span style=color:#ae81ff>64</span>), uint8(<span style=color:#66d9ef>byte</span>), <span style=color:#66d9ef>uint16</span>, <span style=color:#66d9ef>uint32</span>, <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float32</span>, <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>complex64</span>, <span style=color:#66d9ef>complex128</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>array</span>    <span style=color:#f92672>--</span> <span style=color:#a6e22e>固定长度的数组</span>
</span></span></code></pre></div><p><strong>引用类型（指针类型）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>slice</span>   <span style=color:#f92672>--</span> <span style=color:#a6e22e>序列数组</span>(<span style=color:#a6e22e>最常用</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>map</span>     <span style=color:#f92672>--</span> <span style=color:#a6e22e>映射</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>chan</span>    <span style=color:#f92672>--</span> <span style=color:#a6e22e>管道</span>
</span></span></code></pre></div><h3 id=内置函数>内置函数<a hidden class=anchor aria-hidden=true href=#内置函数>#</a></h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>append</span>          <span style=color:#f92672>--</span> <span style=color:#a6e22e>用来追加元素到数组</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>slice中</span>,<span style=color:#a6e22e>返回修改后的数组</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>slice</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>close</span>           <span style=color:#f92672>--</span> <span style=color:#a6e22e>主要用来关闭channel</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>delete</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>从map中删除key对应的value</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>panic</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>停止常规的goroutine</span>  <span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>panic和recover</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#a6e22e>用来做错误处理</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>recover</span>         <span style=color:#f92672>--</span> <span style=color:#a6e22e>允许程序定义goroutine的panic动作</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>imag</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>返回complex的实部</span>   <span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>complex</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>real</span> <span style=color:#a6e22e>imag</span><span style=color:#960050;background-color:#1e0010>：</span><span style=color:#a6e22e>用于创建和操作复数</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>real</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>返回complex的虚部</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>make</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>用来分配内存</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>返回Type本身</span>(<span style=color:#a6e22e>只能应用于slice</span>, <span style=color:#66d9ef>map</span>, <span style=color:#a6e22e>channel</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>new</span>                <span style=color:#f92672>--</span> <span style=color:#a6e22e>用来分配内存</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>主要用来分配值类型</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>比如int</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#66d9ef>struct</span><span style=color:#960050;background-color:#1e0010>。</span><span style=color:#a6e22e>返回指向Type的指针</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cap</span>                <span style=color:#f92672>--</span> <span style=color:#a6e22e>capacity是容量的意思</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>用于返回某个类型的最大容量</span><span style=color:#960050;background-color:#1e0010>（</span><span style=color:#a6e22e>只能用于切片和</span> <span style=color:#66d9ef>map</span><span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>copy</span>            <span style=color:#f92672>--</span> <span style=color:#a6e22e>用于复制和连接slice</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>返回复制的数目</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>len</span>                <span style=color:#f92672>--</span> <span style=color:#a6e22e>来求长度</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>比如string</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>array</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>slice</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#66d9ef>map</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>channel</span> <span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>返回长度</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>print</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>println</span>     <span style=color:#f92672>--</span> <span style=color:#a6e22e>底层打印函数</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>在部署环境中建议使用</span> <span style=color:#a6e22e>fmt</span> <span style=color:#a6e22e>包</span>
</span></span></code></pre></div><p><strong>内置接口</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>error</span> <span style=color:#66d9ef>interface</span> { <span style=color:#75715e>//只要实现了Error()函数，返回值为String的都实现了err接口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Error</span>()    <span style=color:#a6e22e>String</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=init-函数和-main-函数>init 函数和 main 函数<a hidden class=anchor aria-hidden=true href=#init-函数和-main-函数>#</a></h2><h3 id=init-函数>init 函数<a hidden class=anchor aria-hidden=true href=#init-函数>#</a></h3><p>go 语言中 <code>init</code> 函数用于包（package）的初始化，该函数是 go 语言的一个重要特性。</p><p><code>init</code> 函数有如下特征：</p><ol><li><code>init</code> 函数是用于程序执行前做包初始化的函数，比如<strong>初始化包里的变量</strong>等</li><li>每个包可以拥有多个 <code>init</code> 函数</li><li>包的每个源文件也可以拥有多个 <code>init</code> 函数</li><li>同一个包中多个 <code>init</code> 函数的执行顺序 go 语言没有明确的说明</li><li>不同包的 <code>init</code> 函数按照包导入的依赖关系决定该初始化函数的执行顺序</li><li><code>init</code> 函数不能被其他函数调用，而是在 <code>main</code> 函数执行之前自动被调用</li></ol><h3 id=main-函数>main 函数<a hidden class=anchor aria-hidden=true href=#main-函数>#</a></h3><p>Go语言程序的默认入口函数(主函数)：func main()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 函数体</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=两种函数的异同>两种函数的异同<a hidden class=anchor aria-hidden=true href=#两种函数的异同>#</a></h3><ul><li><p>相同点：</p><ul><li>两个函数在定义时不能有任何的参数和返回值，且 Go 程序自动调用</li></ul></li><li><p>不同点：</p><ul><li><code>init</code> 函数可以应用于任意包中，且可以重复定义多个</li><li><code>main</code> 函数只能用于 <code>main</code> 包中，且只能定义一个</li></ul></li><li><p>两个函数的执行顺序：</p><ul><li>同一个 go 文件中的 <code>init()</code> 调用顺序是<strong>从上到下</strong>的</li><li>同一个 package 中不同文件是按文件名字符串比较 “从小到大” 顺序调用各文件中的 <code>init()</code> 函数</li><li>对于不同的 package ，如果不相互依赖的话，按照 main 包中 <strong>“先 import 的后调用”</strong> 的顺序调用包中的 <code>init()</code> ，如果 package 存在依赖，则先调用最早被以来的 package 中的 <code>init()</code> ，最后调用 main 函数</li></ul></li></ul><h2 id=运算符>运算符<a hidden class=anchor aria-hidden=true href=#运算符>#</a></h2><ol><li>算术运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意： ++（自增）和&ndash;（自减）在Go语言中是单独的语句，并不是运算符</strong></p><ol start=2><li>关系运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False</td></tr><tr><td>!=</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False</td></tr><tr><td>></td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False</td></tr><tr><td>>=</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False</td></tr></tbody></table><ol start=3><li>逻辑运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&&</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False</td></tr><tr><td>||</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True</td></tr></tbody></table><ol start=4><li>位运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&</td><td>参与运算的两数各对应的二进位相与（两位均为1才为1）</td></tr><tr><td>|</td><td>参与运算的两数各对应的二进位相或（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1（两位不一样则为1）</td></tr><tr><td>&#171;</td><td>左移 n 位就是乘以 2 的 n 次方。“a &#171; b” 是把 a 的各二进位全部左移 b 位，高位丢弃，低位补 0</td></tr><tr><td>&#187;</td><td>右移 n 位就是除以 2 的 n 次方。“a &#187; b” 是把 a 的各二进位全部右移 b 位</td></tr></tbody></table><ol start=5><li>赋值运算符</li></ol><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&#171;=</td><td>左移后赋值</td></tr><tr><td>&#187;=</td><td>右移后赋值</td></tr><tr><td>&=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><h2 id=下划线>下划线<a hidden class=anchor aria-hidden=true href=#下划线>#</a></h2><p>“_” 是特殊标识符，用来忽略结果</p><ol><li><p>下划线在 <code>import</code> 中</p><ul><li><p>当导入一个包时，该包下的文件里所有的 <code>init()</code> 函数都会被执行。如果我们仅仅希望它执行 <code>init()</code> 函数，不想把整个包都导入进来，就可以使用 <code>import _ 包路径</code> 来引用该包</p></li><li><p>示例 1：</p><ul><li><p>代码结构</p><pre tabindex=0><code>src 
|
+--- main.go            
|
+--- hello
       |
        +--- hello.go
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;./hello&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// hello.Print() </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//编译报错：./main.go:6:5: undefined: hello</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>hello.go</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>hello</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;imp-init() come here.&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Print</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>输出结果：</p><pre tabindex=0><code>imp-init() come here.
</code></pre></li></ul></li><li><p>示例 2：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;database/sql&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;github.com/go-sql-driver/mysql&#34;</span>
</span></span></code></pre></div><p>第二个 <code>import</code> 就是不直接使用 mysql 包，只是执行这个包的 <code>init()</code> 函数，把 mysql 的驱动注册到 sql 包里，然后程序里就可以使用 sql 包来访问 mysql 数据库了</p></li></ul></li><li><p>下划线在代码中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;/Users/***/Desktop/text.txt&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buf</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>buf</span>[:<span style=color:#a6e22e>n</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>解释 1：下划线意思是<strong>忽略这个变量</strong>，比如： <code>os.Open</code> ，返回值为 <code>*os.File, error</code><ul><li>普通写法是：<code>f, err := os.Open("xxxxxx")</code></li><li>如果此时不需要知道返回的错误值，就可以用：<code>f, _ := os.Open("xxxxxx")</code> ，如此就忽略了 error 变量</li></ul></li><li>解释 2：下划线作为占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值，所以就把该值赋给下划线，意思是丢掉不要，这样编译器可以更好的优化。<ul><li><strong>任何类型</strong>的单个值都可以丢给下划线，这种情况是占位用的，比如方法返回两个结果，而你只想要一个结果，那另一个就用 &ldquo;_&rdquo; 占位</li></ul></li></ul></li></ol><h2 id=变量与常量>变量与常量<a hidden class=anchor aria-hidden=true href=#变量与常量>#</a></h2><h3 id=变量>变量<a hidden class=anchor aria-hidden=true href=#变量>#</a></h3><p>Go 语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。<strong>并且 Go 语言的变量声明后必须使用</strong></p><p>Go 语言的变量声明格式为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>变量名</span> <span style=color:#a6e22e>变量类型</span>
</span></span></code></pre></div><p>变量声明以关键字 <code>var</code> 开头，变量类型放在变量的后面，行尾无需分号：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><p>每声明一个变量就写一个 <code>var</code> 比较繁琐，Go 语言还支持批量变量声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span> <span style=color:#66d9ef>float32</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Go 语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为 0 ，字符串变量的默认值为空字符串，布尔型变量默认为<code>false</code>。切片、函数、指针变量的默认为 <code>nil</code></p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>变量名</span> <span style=color:#a6e22e>类型</span> = <span style=color:#a6e22e>表达式</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// example</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span> = <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sex</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>或者一次初始化多个变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>sex</span> = <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p><strong>类型推导</strong>：有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sex</span> = <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p><strong>短变量声明</strong>：在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 全局变量m</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>200</span> <span style=color:#75715e>// 此处声明局部变量m</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>匿名变量</strong>：在使用多重赋值时，如果想要忽略某个值，可以使用<strong>匿名变量（anonymous variable）</strong>。 匿名变量用一个下划线 <code>_</code> 表示</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>() (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;x=&#34;</span>, <span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;y=&#34;</span>, <span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明（在 Lua 等编程语言里，匿名变量也被叫做哑元变量)</p><p>注意事项：</p><ul><li><strong>函数外</strong>的每个语句必须以关键字开始（var、const、func 等）</li><li><code>:=</code> 不能在函数外使用</li><li><code>_</code> 多用于占位，表示忽略值</li></ul><h3 id=常量>常量<a hidden class=anchor aria-hidden=true href=#常量>#</a></h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把 <code>var</code> 换成了 <code>const</code> ，<strong>常量在定义的时候必须赋值</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pi</span> = <span style=color:#ae81ff>3.1415</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>e</span> = <span style=color:#ae81ff>2.7182</span>
</span></span></code></pre></div><p>声明了 <code>pi</code> 和 <code>e</code> 这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了</p><p>多个常量也可以一起声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pi</span> = <span style=color:#ae81ff>3.1415</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> = <span style=color:#ae81ff>2.7182</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p><code>const</code> 同时声明多个常量时，如果省略了值则表示和上面一行的值相同</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n1</span> = <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n2</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n3</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>常量 <code>n1</code> 、<code>n2</code>、<code>n3</code> 的值均为 100</p><p><strong>iota</strong>：<code>iota</code> 是 Go 语言的常量计数器，只能在常量的表达式中使用。 <code>iota</code> 在 <code>const</code> 关键字出现时将被重置为 0 。<code>const</code> 中每新增一行常量声明将使 <code>iota</code> 计数一次（<code>iota</code> 可理解为 <code>const</code> 语句块中的行索引）。 使用 <code>iota</code> 能简化定义，在定义枚举时很有用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n1</span> = <span style=color:#ae81ff>100</span> <span style=color:#75715e>// 0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n2</span>		 <span style=color:#75715e>// 1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n3</span>		 <span style=color:#75715e>// 2</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>使用 <code>_</code> 跳过某些值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n1</span> = <span style=color:#ae81ff>100</span> <span style=color:#75715e>// 0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n2</span>		 <span style=color:#75715e>// 1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>		 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n3</span>		 <span style=color:#75715e>// 3</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>使用示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n1</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n2</span> = <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n3</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 2</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n4</span> <span style=color:#75715e>// 3</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>n5</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0</span>
</span></span></code></pre></div><p>定义数量级：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>  = <span style=color:#66d9ef>iota</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>KB</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>iota</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MB</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>iota</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>GB</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>iota</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>TB</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>iota</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PB</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>iota</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>多个 <code>iota</code> 定义在一行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e>//1,2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>                      <span style=color:#75715e>//2,3</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>f</span>                      <span style=color:#75715e>//3,4</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h2 id=基本类型>基本类型<a hidden class=anchor aria-hidden=true href=#基本类型>#</a></h2><ol><li><p><strong>整形</strong>：整型分为以下两个大类： 按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code> 。其中，<code>uint8</code> 就是 <code>byte</code> 型，<code>int16</code> 对应C语言中的 <code>short</code> 型，<code>int64</code> 对应C语言中的 <code>long</code> 型</p></li><li><p><strong>浮点型</strong>：Go语言支持两种浮点型数：<code>float32</code> 和 <code>float64</code> 。这两种浮点型数据格式遵循 <code>IEEE 754</code> 标准： <code>float32</code> 的浮点数的最大范围约为<code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code></p></li><li><p><strong>复数</strong>：<code>complex64</code> 和 <code>complex128</code> ，复数有实部和虚部，<code>complex64</code> 的实部和虚部为 32 位，<code>complex128</code> 的实部和虚部为 64 位</p></li><li><p><strong>布尔值</strong>：Go语言中以 <code>bool</code> 类型进行声明布尔型数据，布尔型数据只有 <code>true</code> 和 <code>false</code> 两个值</p><ul><li>注意：布尔类型变量的默认值为 <code>false</code> ，<strong>Go 语言中不允许将整型强制转换为布尔型，布尔型无法参与数值运算，也无法与其他类型进行转换</strong></li></ul></li><li><p><strong>字符串</strong>：Go 语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用 UTF-8 编码。 字符串的值为双引号中的内容，可以在Go语言的源码中直接添加非 <code>ASCII</code> 码字符，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;你好&#34;</span> <span style=color:#75715e>// 非 ASCII码</span>
</span></span></code></pre></div></li><li><p><strong>多行字符串</strong>：Go 语言中使用<strong>反引号</strong>定义多行字符串，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`第一行
</span></span></span><span style=display:flex><span><span style=color:#e6db74>第二行
</span></span></span><span style=display:flex><span><span style=color:#e6db74>第三行
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>)
</span></span></code></pre></div></li><li><p><strong>字符串常用操作</strong>：</p></li></ol><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+ 或 fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割字符串</td></tr><tr><td>strings.Contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix, strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>strings.Index(), strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join 操作</td></tr></tbody></table><ol start=8><li><p><strong>byte 和 rune 类型</strong>：</p><ul><li><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号 <code>’</code> 包裹起来，如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#39;中&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#39;x&#39;</span>
</span></span></code></pre></div></li><li><p>Go 语言的字符有以下两种：</p><ul><li><code>uint8</code> 类型，或者叫 <code>byte</code> 型，代表了 ASCII 码的一个字符</li><li><code>rune</code> 类型，代表一个 UTF-8 字符</li></ul></li><li><p>当需要处理中文、日文或者其他复合字符时，则需要用到 <code>rune</code> 类型。<code>rune</code> 类型实际是一个 <code>int32</code> 。 Go 使用了特殊的 <code>rune</code> 类型来处理 <code>Unicode</code>，让基于 <code>Unicode</code> 的文本处理更为方便，也可以使用 <code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 遍历字符串</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>traversalString</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;pprof.cn博客&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> { <span style=color:#75715e>//byte</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v(%c) &#34;</span>, <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span> { <span style=color:#75715e>//rune</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v(%c) &#34;</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下：</p><pre tabindex=0><code>112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢)
112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客)
</code></pre><ul><li>因为 UTF8 编码下一个中文汉字由 3~4 个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果</li><li>字符串底层是一个 byte 数组，所以可以和 []byte 类型相互转换。 rune 类型用来表示 UTF-8 字符，一个 rune 字符由一个或多个 byte 组成，注意：<strong>字符串是不能修改的</strong></li></ul></li></ul></li><li><p><strong>修改字符串</strong>：要修改字符串，需要先将其转换成 <code>[]rune</code> 或 <code>[]byte</code> ，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>changeString</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 强制类型转换</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>byteS1</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>byteS1</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#e6db74>&#39;H&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>byteS1</span>)) <span style=color:#75715e>// 输出：Hello</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;博客&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>runeS2</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>runeS2</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#e6db74>&#39;狗&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>runeS2</span>)) <span style=color:#75715e>// 输出：狗客</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>类型转换</strong>：Go 语言中只有强制类型转换，<strong>没有隐式类型转换</strong>。该语法只能在两个类型之间支持相互转换的时候使用</p><ul><li><p>基本语法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>T</span>(<span style=color:#a6e22e>表达式</span>)
</span></span></code></pre></div><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><p>比如计算直角三角形的斜边长时使用 math 包的 Sqrt() 函数，该函数接收的是 float64 类型的参数，而变量 a 和 b 都是 int 类型的，这个时候就需要将 a 和 b 强制类型转换为 float64 类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sqrtDemo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// math.Sqrt()接收的参数是float64类型，需要强制转换</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> = int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Sqrt</span>(float64(<span style=color:#a6e22e>a</span><span style=color:#f92672>*</span><span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>*</span><span style=color:#a6e22e>b</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ol><h2 id=数组-array>数组 Array<a hidden class=anchor aria-hidden=true href=#数组-array>#</a></h2><ol><li><p>数组定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> [<span style=color:#a6e22e>len</span>]<span style=color:#66d9ef>int</span>
</span></span></code></pre></div><ul><li>比如：<code>var a [5]int</code> ，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变</li><li>长度是数组类型的一部分，因此，<code>var a[5]int</code> 和 <code>var a[10]int</code> 是不同的类型</li><li>数组是值类型，<strong>赋值和传参会复制整个数组</strong>，而不是指针。因此改变副本的值，不会改变本身的值</li><li>指针数组 <code>[n]*T</code>，数组指针 <code>*[n]T</code></li></ul></li><li><p>一维数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 全局：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr0</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr1</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr2</span> = [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>str</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>string</span>{<span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#34;hello world&#34;</span>, <span style=color:#ae81ff>4</span>: <span style=color:#e6db74>&#34;tom&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 局部：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}           <span style=color:#75715e>// 未初始化元素值为 0。</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}   <span style=color:#75715e>// 通过初始化值确定数组长度。</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>: <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>4</span>: <span style=color:#ae81ff>200</span>} <span style=color:#75715e>// 使用索引号初始化元素。</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>}{
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>&#34;user1&#34;</span>, <span style=color:#ae81ff>10</span>}, <span style=color:#75715e>// 可省略元素类型。</span>
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>&#34;user2&#34;</span>, <span style=color:#ae81ff>20</span>}, <span style=color:#75715e>// 别忘了最后一行的逗号。</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr0</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr1</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr2</span> = [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>str</span> = [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>string</span>{<span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#34;hello world&#34;</span>, <span style=color:#ae81ff>4</span>: <span style=color:#e6db74>&#34;tom&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}           <span style=color:#75715e>// 未初始化元素值为 0。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}   <span style=color:#75715e>// 通过初始化值确定数组长度。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>: <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>4</span>: <span style=color:#ae81ff>200</span>} <span style=color:#75715e>// 使用引号初始化元素。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    }{
</span></span><span style=display:flex><span>        {<span style=color:#e6db74>&#34;user1&#34;</span>, <span style=color:#ae81ff>10</span>}, <span style=color:#75715e>// 可省略元素类型。</span>
</span></span><span style=display:flex><span>        {<span style=color:#e6db74>&#34;user2&#34;</span>, <span style=color:#ae81ff>20</span>}, <span style=color:#75715e>// 别忘了最后一行的逗号。</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr0</span>, <span style=color:#a6e22e>arr1</span>, <span style=color:#a6e22e>arr2</span>, <span style=color:#a6e22e>str</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>输出结果：
[1 2 3 0 0] [1 2 3 4 5] [1 2 3 4 5 6] [   hello world tom]
[1 2 0] [1 2 3 4] [0 0 100 0 200] [{user1 10} {user2 20}]
</code></pre></li><li><p>多维数组 & 多维数组遍历</p><ul><li>参考：https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84Array.html</li></ul></li><li><p>数组拷贝和传参</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printArr</span>(<span style=color:#a6e22e>arr</span> <span style=color:#f92672>*</span>[<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 循环中 i 是元素下标，v 是元素数值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr1</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printArr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr2</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>10</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printArr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>arr2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>输出结果：
0 10
1 0
2 0
3 0
4 0
[10 0 0 0 0]
0 10
1 4
2 6
3 8
4 10
[10 4 6 8 10]
</code></pre></li></ol><h2 id=切片-slice>切片 Slice<a hidden class=anchor aria-hidden=true href=#切片-slice>#</a></h2><ol><li><p><code>slice</code> 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案</p><ul><li><p>切片是数组的一个引用，但自身是结构体，通过值拷贝传递</p></li><li><p>切片的长度可以改变，因此切片是一个可变数组</p></li><li><p>切片遍历方式和数组一样，可以用 <code>len()</code> 求长度，表示可用元素数量，读写操作不能超过该限制</p></li><li><p><code>cap()</code> 可以求出切片最大扩张容量，不能超出数组限制：<code>0 &lt;= len(slice) &lt;= len(array)</code> ，其中 <code>array</code> 是 <code>slice</code> 引用的数组</p></li><li><p>定义：<code>var 变量名 []类型</code> ，比如：<code>var str []string</code> 、<code>var arr []int</code></p></li><li><p>如果 <code>slice == nil</code> ，那么 <code>len()、cap()</code> 结果都等于 0</p></li></ul></li><li><p>创建切片的各种方式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#75715e>//1.使用 var 声明切片 s1，s1 是一个 nil 切片，没有分配内存</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s1</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;是空&#34;</span>)
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;不是空&#34;</span>)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 2.使用 := 简短声明，创建切片 s2 并初始化为空切片</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 空切片与 nil 切片不同，空切片底层数组已分配内存，但是容量为 0，而 nil 切片没有分配内存</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 3.使用 make() 创建切片，可以指定切片长度和容量</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s3</span> []<span style=color:#66d9ef>int</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>, <span style=color:#a6e22e>s2</span>, <span style=color:#a6e22e>s3</span>)
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 4.初始化赋值</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s4</span> []<span style=color:#66d9ef>int</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s4</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>s5</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s5</span>)
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 5.从数组切片</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s6</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 前包后不包</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>s6</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s6</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意：切片的长度是当前切片<strong>存储的元素数量</strong>，通过 <code>len()</code> 获取切片长度；切片容量是从切片的起始位置到底层数组的末尾的元素数量，也就是<strong>切片能容纳的元素的最大数量</strong>，通过 <code>cap()</code> 获取切片长度</p></li><li><p>切片初始化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 全局：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> = [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice0</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>start</span>:<span style=color:#a6e22e>end</span>] 
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice1</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[:<span style=color:#a6e22e>end</span>]        
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice2</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>start</span>:]        
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice3</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[:] 
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice4</span> = <span style=color:#a6e22e>arr</span>[:len(<span style=color:#a6e22e>arr</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]      <span style=color:#75715e>//去掉切片的最后一个元素</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 局部：</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>arr2</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice5</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>start</span>:<span style=color:#a6e22e>end</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice6</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[:<span style=color:#a6e22e>end</span>]        
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice7</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#a6e22e>start</span>:]     
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice8</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[:]  
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice9</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[:len(<span style=color:#a6e22e>arr</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e>//去掉切片的最后一个元素</span>
</span></span></code></pre></div><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/02/10/RAmfQsxkaM2XCBI.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> = [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice0</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>8</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice1</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>6</span>]        <span style=color:#75715e>//可以简写为 var slice []int = arr[:end]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice2</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>5</span>:<span style=color:#ae81ff>10</span>]       <span style=color:#75715e>//可以简写为 var slice[]int = arr[start:]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice3</span> []<span style=color:#66d9ef>int</span> = <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>:len(<span style=color:#a6e22e>arr</span>)] <span style=color:#75715e>//var slice []int = arr[:]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice4</span> = <span style=color:#a6e22e>arr</span>[:len(<span style=color:#a6e22e>arr</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]      <span style=color:#75715e>//去掉切片的最后一个元素</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：arr %v\n&#34;</span>, <span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：slice0 %v\n&#34;</span>, <span style=color:#a6e22e>slice0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：slice1 %v\n&#34;</span>, <span style=color:#a6e22e>slice1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：slice2 %v\n&#34;</span>, <span style=color:#a6e22e>slice2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：slice3 %v\n&#34;</span>, <span style=color:#a6e22e>slice3</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;全局变量：slice4 %v\n&#34;</span>, <span style=color:#a6e22e>slice4</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;-----------------------------------\n&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>arr2</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice5</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>8</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice6</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>6</span>]         <span style=color:#75715e>//可以简写为 slice := arr[:end]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice7</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>5</span>:<span style=color:#ae81ff>10</span>]        <span style=color:#75715e>//可以简写为 slice := arr[start:]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice8</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>0</span>:len(<span style=color:#a6e22e>arr</span>)]  <span style=color:#75715e>//slice := arr[:]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice9</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arr</span>[:len(<span style=color:#a6e22e>arr</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e>//去掉切片的最后一个元素</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： arr2 %v\n&#34;</span>, <span style=color:#a6e22e>arr2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： slice5 %v\n&#34;</span>, <span style=color:#a6e22e>slice5</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： slice6 %v\n&#34;</span>, <span style=color:#a6e22e>slice6</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： slice7 %v\n&#34;</span>, <span style=color:#a6e22e>slice7</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： slice8 %v\n&#34;</span>, <span style=color:#a6e22e>slice8</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;局部变量： slice9 %v\n&#34;</span>, <span style=color:#a6e22e>slice9</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>输出结果：
全局变量：arr [0 1 2 3 4 5 6 7 8 9]
全局变量：slice0 [2 3 4 5 6 7]
全局变量：slice1 [0 1 2 3 4 5]
全局变量：slice2 [5 6 7 8 9]
全局变量：slice3 [0 1 2 3 4 5 6 7 8 9]
全局变量：slice4 [0 1 2 3 4 5 6 7 8]
-----------------------------------
局部变量： arr2 [9 8 7 6 5 4 3 2 1 0]
局部变量： slice5 [2 3 4 5 6 7]
局部变量： slice6 [0 1 2 3 4 5]
局部变量： slice7 [5 6 7 8 9]
局部变量： slice8 [0 1 2 3 4 5 6 7 8 9]
局部变量： slice9 [0 1 2 3 4 5 6 7 8]
</code></pre></li><li><p>通过 make 来创建切片</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice</span> []<span style=color:#66d9ef>type</span> = make([]<span style=color:#66d9ef>type</span>, <span style=color:#a6e22e>len</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>type</span>, <span style=color:#a6e22e>len</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>type</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span>)
</span></span></code></pre></div><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/06/29/So5u2iRAg8eyJ3Q.png></p><p>切片的内存布局如下：</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/06/29/IQ5aGTLpkEMKiCO.png></p><p>读写操作实际目标是切片指向的底层数组，需要注意索引号的差别</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>输出如下：
[102 203]
[0 1 102 203 4 5]
</code></pre><p>可直接创建 slice 对象，自动分配底层数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>: <span style=color:#ae81ff>100</span>} <span style=color:#75715e>// 通过初始化表达式构造，可使用索引号。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>, len(<span style=color:#a6e22e>s1</span>), cap(<span style=color:#a6e22e>s1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>) <span style=color:#75715e>// 使用 make 创建，指定 len 和 cap 值。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s2</span>, len(<span style=color:#a6e22e>s2</span>), cap(<span style=color:#a6e22e>s2</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s3</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>6</span>) <span style=color:#75715e>// 省略 cap，相当于 cap = len。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s3</span>, len(<span style=color:#a6e22e>s3</span>), cap(<span style=color:#a6e22e>s3</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出如下：</p><pre tabindex=0><code>[0 1 2 3 0 0 0 0 100] 9 9
[0 0 0 0 0 0] 6 8
[0 0 0 0 0 0] 6 6
</code></pre><p>使用 make 动态创建 slice，避免了数组必须用常量做长度的麻烦，还可用指针直接访问底层数组，退化成普通数组操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>2</span>] <span style=color:#75715e>// *int, 获取底层数组元素指针。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>[0 1 102 3]
</code></pre></li><li><p>使用 append 操作切片</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice a : %v\n&#34;</span>, <span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice b : %v\n&#34;</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice c : %v\n&#34;</span>, <span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>c</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice d : %v\n&#34;</span>, <span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>d</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice e : %v\n&#34;</span>, <span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>slice a : [1 2 3]
slice b : [4 5 6]
slice c : [1 2 3 4 5 6]
slice d : [1 2 3 4 5 6 7]
slice e : [1 2 3 4 5 6 7 8 9 10]
</code></pre><p>append: 向 slice 尾部添加数据，<strong>返回新的 slice 对象</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>s1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%p\n&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>, <span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>0xc42000a060
0xc42000a080
[] [1]
</code></pre></li><li><p>超出原 slice.cap 限制，就会重新分配底层数组，让该 slice 引用新的底层数组，即使原数组并未填满</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>10</span>: <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>[:<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>) <span style=color:#75715e>// 一次 append 两个值，超出 s.cap 限制。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>data</span>)         <span style=color:#75715e>// 重新分配底层数组，与原数组无关。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>], <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#75715e>// 比对底层数组起始指针。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>[0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0]
0xc4200160f0 0xc420070060
</code></pre><p>go 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收</p></li><li><p>slice 中 cap 重新分配规律</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> cap(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>50</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> cap(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>n</span> &gt; <span style=color:#a6e22e>c</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;cap: %d -&gt; %d\n&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>cap: 1 -&gt; 2
cap: 2 -&gt; 4
cap: 4 -&gt; 8
cap: 8 -&gt; 16
cap: 16 -&gt; 32
cap: 32 -&gt; 64
</code></pre></li><li><p>切片拷贝</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice s1 : %v\n&#34;</span>, <span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice s2 : %v\n&#34;</span>, <span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>    copy(<span style=color:#a6e22e>s2</span>, <span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;copied slice s1 : %v\n&#34;</span>, <span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;copied slice s2 : %v\n&#34;</span>, <span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s3</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice s3 : %v\n&#34;</span>, <span style=color:#a6e22e>s3</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s3</span> = append(<span style=color:#a6e22e>s3</span>, <span style=color:#a6e22e>s2</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;appended slice s3 : %v\n&#34;</span>, <span style=color:#a6e22e>s3</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s3</span> = append(<span style=color:#a6e22e>s3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;last slice s3 : %v\n&#34;</span>, <span style=color:#a6e22e>s3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>slice s1 : [1 2 3 4 5]
slice s2 : [0 0 0 0 0 0 0 0 0 0]
copied slice s1 : [1 2 3 4 5]
copied slice s2 : [1 2 3 4 5 0 0 0 0 0]
slice s3 : [1 2 3]
appended slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0]
last slice s3 : [1 2 3 1 2 3 4 5 0 0 0 0 0 4 5 6]
</code></pre><p>copy: 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠</p><p>应及时讲所需数据 copy 到较小的 slice，以便释放超大号底层数组内存</p></li><li><p>slice 遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> [<span style=color:#f92672>...</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>[:]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>slice</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;inde : %v , value : %v\n&#34;</span>, <span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>inde : 0 , value : 0
inde : 1 , value : 1
inde : 2 , value : 2
inde : 3 , value : 3
inde : 4 , value : 4
inde : 5 , value : 5
inde : 6 , value : 6
inde : 7 , value : 7
inde : 8 , value : 8
inde : 9 , value : 9
</code></pre></li><li><p>切片 resize</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice a : %v , len(a) : %v\n&#34;</span>, <span style=color:#a6e22e>a</span>, len(<span style=color:#a6e22e>a</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice b : %v , len(b) : %v\n&#34;</span>, <span style=color:#a6e22e>b</span>, len(<span style=color:#a6e22e>b</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;slice c : %v , len(c) : %v\n&#34;</span>, <span style=color:#a6e22e>c</span>, len(<span style=color:#a6e22e>c</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>slice a : [1 3 4 5] , len(a) : 4
slice b : [3] , len(b) : 1
slice c : [3 4 5] , len(c) : 3
</code></pre><ol start=11><li><p>字符串与切片</p><p>string 底层是一个 byte 数组，因此也可以进行切片操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>str</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>5</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>str</span>[<span style=color:#ae81ff>6</span>:]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>hello
world
</code></pre><p>string 本身是不可变的，要改变 string 中的字符，需要如下操作：</p><ul><li><p>英文字符串：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Hello world&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>str</span>) <span style=color:#75715e>//中文字符需要用[]rune(str)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>6</span>] = <span style=color:#e6db74>&#39;G&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>s</span>[:<span style=color:#ae81ff>8</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> = append(<span style=color:#a6e22e>s</span>, <span style=color:#e6db74>&#39;!&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> = string(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>str</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Hello Go!
</code></pre></li><li><p>含有中文字符</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;你好，世界！hello world！&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>str</span>) 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>3</span>] = <span style=color:#e6db74>&#39;够&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>4</span>] = <span style=color:#e6db74>&#39;浪&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>12</span>] = <span style=color:#e6db74>&#39;g&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>s</span>[:<span style=color:#ae81ff>14</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> = string(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>str</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>你好，够浪！hello go
</code></pre></li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>