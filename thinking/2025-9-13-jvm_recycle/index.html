<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>浅谈 JVM 垃圾回收机制 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content='垃圾回收的概念从何而来
垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 堆内存 中已经死亡或者长时间未使用的对象进行清除回收。
Java 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 手动 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：
class Person {
private:
    std::string name;
    int age;

public:
    // 构造函数
    Person(const std::string& personName, int personAge) : name(personName), age(personAge) {}

    // 析构函数
    ~Person() {}

    void introduce() {
        std::cout << "Hello，my name is " << name << "， and I&#39;m " << age << " years old now" << std::endl;
    }
};
在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。
那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？
在 1960 年，基于 MIT 的 Lisp 首先提出了 垃圾回收 的概念，用于处理 C/C++ 语言不停析构的操作。'><meta name=author content><link rel=canonical href=https://yukipedia.cn/thinking/2025-9-13-jvm_recycle/><link crossorigin=anonymous href=../../assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/thinking/2025-9-13-jvm_recycle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/thinking/2025-9-13-jvm_recycle/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="浅谈 JVM 垃圾回收机制"><meta property="og:description" content='垃圾回收的概念从何而来 垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 堆内存 中已经死亡或者长时间未使用的对象进行清除回收。
Java 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 手动 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：
class Person { private: std::string name; int age; public: // 构造函数 Person(const std::string& personName, int personAge) : name(personName), age(personAge) {} // 析构函数 ~Person() {} void introduce() { std::cout << "Hello，my name is " << name << "， and I&#39;m " << age << " years old now" << std::endl; } }; 在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。
那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？
在 1960 年，基于 MIT 的 Lisp 首先提出了 垃圾回收 的概念，用于处理 C/C++ 语言不停析构的操作。'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="thinking"><meta property="article:published_time" content="2025-09-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="浅谈 JVM 垃圾回收机制"><meta name=twitter:description content='垃圾回收的概念从何而来
垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 堆内存 中已经死亡或者长时间未使用的对象进行清除回收。
Java 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 手动 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：
class Person {
private:
    std::string name;
    int age;

public:
    // 构造函数
    Person(const std::string& personName, int personAge) : name(personName), age(personAge) {}

    // 析构函数
    ~Person() {}

    void introduce() {
        std::cout << "Hello，my name is " << name << "， and I&#39;m " << age << " years old now" << std::endl;
    }
};
在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。
那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？
在 1960 年，基于 MIT 的 Lisp 首先提出了 垃圾回收 的概念，用于处理 C/C++ 语言不停析构的操作。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Thinkings","item":"https://yukipedia.cn/thinking/"},{"@type":"ListItem","position":2,"name":"浅谈 JVM 垃圾回收机制","item":"https://yukipedia.cn/thinking/2025-9-13-jvm_recycle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浅谈 JVM 垃圾回收机制","name":"浅谈 JVM 垃圾回收机制","description":"垃圾回收的概念从何而来 垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 堆内存 中已经死亡或者长时间未使用的对象进行清除回收。\nJava 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 手动 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：\nclass Person { private: std::string name; int age; public: // 构造函数 Person(const std::string\u0026amp; personName, int personAge) : name(personName), age(personAge) {} // 析构函数 ~Person() {} void introduce() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello，my name is \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;， and I\u0026#39;m \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; years old now\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。\n那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？\n在 1960 年，基于 MIT 的 Lisp 首先提出了 垃圾回收 的概念，用于处理 C/C++ 语言不停析构的操作。\n","keywords":[],"articleBody":"垃圾回收的概念从何而来 垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 堆内存 中已经死亡或者长时间未使用的对象进行清除回收。\nJava 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 手动 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：\nclass Person { private: std::string name; int age; public: // 构造函数 Person(const std::string\u0026 personName, int personAge) : name(personName), age(personAge) {} // 析构函数 ~Person() {} void introduce() { std::cout \u003c\u003c \"Hello，my name is \" \u003c\u003c name \u003c\u003c \"， and I'm \" \u003c\u003c age \u003c\u003c \" years old now\" \u003c\u003c std::endl; } }; 在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。\n那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？\n在 1960 年，基于 MIT 的 Lisp 首先提出了 垃圾回收 的概念，用于处理 C/C++ 语言不停析构的操作。\n到 1995 年 Java 问世，把垃圾回收的机制发扬光大。\nJVM \u0026 垃圾判断算法 Java 虚拟机（Java Virtual Machine, JVM）是一种能够执行 Java 字节码的虚拟机。Java “一次编写，处处运行” 的特性离不开 JVM。\n具体来说，Java 代码（.java 文件）编译后生成 字节码（.class 文件），JVM 负责将字节码动态翻译成 目标平台的机器码，从而实现在不同操作系统上运行同一份字节码文件。\n同时，JVM 也承担着管理内存 —— 垃圾回收 的重任。\n既然 JVM 要做垃圾回收，就要搞清楚堆内存中什么是垃圾，通常会有两种算法来确定一个对象是否为垃圾：引用计数算法 和 可达性分析算法。\n引用计数算法 该算法的原理比较简单：通过在对象头中分配一个空间来保存该对象被引用的次数，如果该对象被其他对象引用，引用计数 +1，如果删除对该对象的引用，引用计数 -1。\n当该对象的引用计数为 0，那么该对象就会被回收。\n这个算法实现简单，效率高，但目前主流的虚拟机中并没有选择该算法来管理内存，主要是因为它很难解决 循环引用 问题：\npublic class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } 如上面代码所示，objA 和 objB 除了相互引用对方之外再无其他引用，但是因为它们的相互引用，导致两者的引用计数都不为 0，那么 JVM 就无法回收它们，导致内存浪费。\n可达性分析算法 这个算法的基本思想是通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为 引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被 JVM 回收。\n上图中 obj4、obj5、obj6 GC Roots 不可达，会被 JVM 回收。\n通过可达性分析算法，解决了上面引用计数法的 “循环依赖” 问题。只要对象无法与 GC Root 建立直接 or 间接的连接，系统就会判定其为可回收对象。\n既然这个方法是通过 GC Root 判断对象是否存活，那 GC Root 到底是什么？🤔\n所谓 GC Roots，就是一组必须活跃的引用，不是对象，它们是程序运行时的起点，一切引用链的源头。在 Java 中 GC Roots 包括以下几种：\n虚拟机栈中的引用（比如方法的参数、局部变量） 本地方法栈中 JNI 的引用 类静态变量 运行时常量池中的常量（String 或者 Class 类型） 更具体一点，在代码中我们如何辨认 GC Roots 呢？下面以上面提到的前两种为例。\n虚拟机栈中的引用（方法的参数、局部变量等） public class StackReference { public void greet() { Object localVar = new Object(); // 这里的 localVar 是一个局部变量，存在于虚拟机栈中 System.out.println(localVar.toString()); } public static void main(String[] args) { new StackReference().greet(); } } 在 greet() 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。在该方法执行期间，localVar 引用的对象是活跃的，因为它们是从 GC Root 出发可达的。当 greet() 方法执行完毕，localVar 作用域结束，如果没有其他引用指向这些对象，它们就可以被视作垃圾进行回收。\n本地方法栈中 JNI 的引用 JNI（Java Native Interface） 是 Java 提供的一种机制，允许 Java 代码调用本地代码（C/C++）。和调用 Java 方法类似，当调用本地方法时，虚拟机会通过 动态链接 直接调用指定的本地方法。\n// 假设的JNI方法 public native void nativeMethod(); // 假设在C/C++中实现的本地方法 /* * Class: NativeExample * Method: nativeMethod * Signature: ()V */ JNIEXPORT void JNICALL Java_NativeExample_nativeMethod(JNIEnv *env, jobject thisObj) { jobject localRef = (*env)-\u003eNewObject(env, ...); // 在本地方法栈中创建JNI引用 // localRef 引用的Java对象在本地方法执行期间是活跃的 } 比如上面的代码，在本地代码（Java_NativeExample_nativeMethod）中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可被认为是 GC Roots。一旦这个本地方法执行完毕，除非 localRef 的引用是全局的，否则它指向的对象会被作为垃圾回收掉。\n垃圾收集算法 垃圾收集算法 负责完成垃圾回收，主要包括：\n标记 - 清除算法 标记 - 整理算法 复制算法 分代收集算法 这部分比较容易理解，不再过多赘述。\n堆空间的分代 堆（Heap）是 JVM 中最大的一块内存区域，也是垃圾回收器管理的主要区域。\n堆空间主要分为两个区域，年轻代和老年代，其中年轻代又分为 Eden 区和 Survivor 区，而 Survivor 区又分为 From 和 To 两个区。\nEden 区 绝大多数对象存活时间并不会很长，因此 Java 对象在创建后会优先在 Eden 区进行内存分配，当 Eden 区没有足够空间时，JVM 会发起一次 Minor GC。\nMinor GC 后，Eden 区中绝大部分对象会被回收，存活下来的对象会进到 From Survivor 区，如果 From 区不够，则直接进入 To 区。\nSurvivor 区 Q1：为什么需要 Survivor 区，直接 Eden 到老年代不好吗？为什么还需要加这么一层？\n由于 Eden 区的 Minor GC 进行得比较频繁，如果没有 Survivor 区，存活的对象就会直接进入老年代，这样的话老年代很快就会被塞满，从而触发 Major GC，导致 STW，严重影响程序性能。\n同时，有些对象虽然不会在 Minor GC 被回收，但也不会存活的太久，这时候直接放到老年代不太合适。所以 Survivor 存在的意义是 减少被送到老年代的对象，进而减少 Major GC 的发生。\nQ2：Survivor 区为什么需要被划分成 From 和 To 两个区域？\nSurvivor 区被划分为两个区域，主要是为了高效地实施 复制算法，避免内存碎片，提升垃圾回收（尤其是 Minor GC）的效率。\n具体来说，每次 Minor GC 时，JVM 会将 Eden 区和一个 Survivor 区（From）中仍然存活的对象复制到另一个 空的 Survivor 区（To）。复制完成后，Eden 和 From 会被完全清空，此时，From 和 To 的角色会进行交换，原来的 To 区编程下一次 GC 的 From 区，原来的 From 区则变为新的空 To 区。\n如果只有一块 Survivor 区：\nMinor GC 后，Eden 和 Survivor 中都会有存活和死亡的对象交错存在 若要清理 Survivor 中的垃圾，可能需要用 标记 - 清除 算法，产生内存碎片；就算采用 标记 - 整理 算法，也会有 性能损耗大、停顿时间长 的问题 内存碎片会导致无法给大对象分配连续的空间，可能触发不必要的垃圾回收 Old 区 老年代占堆空间的 2/3，只有在 Major GC/Full GC 时才会进行清理，每次 GC 都会触发 STW，内存越大，STW 的时间越长。\n由于复制算法在对象存活率较高的老年代会进行多次赋值操作，效率低，所以老年代采用 标记 - 整理 算法。\n另外，由于 内存担保机制 的存在，以下几种对象会直接进入老年代：\n需要大量连续内存的对象 长期存活对象 动态对象年龄：不强制要求对象年龄到 15 岁再放入老年代，如果 Survivor 中某个年龄段及以上的对象总大小超过 Survivor 的一半，也会在下一次 GC 时晋升到老年代 ","wordCount":"505","inLanguage":"en","datePublished":"2025-09-13T00:00:00Z","dateModified":"2025-09-13T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/thinking/2025-9-13-jvm_recycle/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">浅谈 JVM 垃圾回收机制</h1><div class=post-meta><span title='2025-09-13 00:00:00 +0000 UTC'>September 13, 2025</span></div></header><div class=post-content><h2 id=垃圾回收的概念从何而来>垃圾回收的概念从何而来<a hidden class=anchor aria-hidden=true href=#垃圾回收的概念从何而来>#</a></h2><p>垃圾回收（Garbage Collection, GC），顾名思义就是释放垃圾占用的空间，避免爆内存。具体来说，垃圾回收需要对 <strong>堆内存</strong> 中已经死亡或者长时间未使用的对象进行清除回收。</p><p>Java 语言问世之前，程序员大多数都是在写 C/C++ 程序。我们知道，C++ 这种没有 GC 机制的语言，创建对象时需要不断地开辟内存空间，不用该对象的时候又需要 <strong>手动</strong> 的去释放空间，既要写构造函数，又要写析构函数。比如下面使用 C++ 编写的 Person 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Person(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> personName, <span style=color:#66d9ef>int</span> personAge) <span style=color:#f92672>:</span> name(personName), age(personAge) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>Person() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>introduce</span>() {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello，my name is &#34;</span> <span style=color:#f92672>&lt;&lt;</span> name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;， and I&#39;m &#34;</span> <span style=color:#f92672>&lt;&lt;</span> age <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; years old now&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在日常写代码的过程中，我们偏向于创建对象、调用对象方法来完成一个个的任务。但每次创建对象后如果都需要手动释放内存空间，会在代码段中引入大量的析构函数，既带来了不太丝滑的编程体验，也增加了阅读代码的工作量。</p><p>那么我们能不能专门写一段程序来实现析构函数的功能，每次创建对象、释放内存空间的时候复用这段代码？</p><p>在 1960 年，基于 MIT 的 Lisp 首先提出了 <strong>垃圾回收</strong> 的概念，用于处理 C/C++ 语言不停析构的操作。</p><p>到 1995 年 Java 问世，把垃圾回收的机制发扬光大。</p><h2 id=jvm--垃圾判断算法>JVM & 垃圾判断算法<a hidden class=anchor aria-hidden=true href=#jvm--垃圾判断算法>#</a></h2><p>Java 虚拟机（Java Virtual Machine, JVM）是一种能够执行 Java 字节码的虚拟机。Java “一次编写，处处运行” 的特性离不开 JVM。</p><p>具体来说，Java 代码（.java 文件）编译后生成 <strong>字节码</strong>（.class 文件），JVM 负责将字节码动态翻译成 <strong>目标平台的机器码</strong>，从而实现在不同操作系统上运行同一份字节码文件。</p><p>同时，JVM 也承担着管理内存 —— <strong>垃圾回收</strong> 的重任。</p><p>既然 JVM 要做垃圾回收，就要搞清楚堆内存中什么是垃圾，通常会有两种算法来确定一个对象是否为垃圾：<strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong>。</p><h3 id=引用计数算法>引用计数算法<a hidden class=anchor aria-hidden=true href=#引用计数算法>#</a></h3><p>该算法的原理比较简单：通过在对象头中分配一个空间来保存该对象被引用的次数，如果该对象被其他对象引用，引用计数 +1，如果删除对该对象的引用，引用计数 -1。</p><p><strong>当该对象的引用计数为 0，那么该对象就会被回收。</strong></p><p>这个算法实现简单，效率高，但目前主流的虚拟机中并没有选择该算法来管理内存，主要是因为它很难解决 <strong>循环引用</strong> 问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReferenceCountingGc</span> {
</span></span><span style=display:flex><span>    Object instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        ReferenceCountingGc objA <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReferenceCountingGc();
</span></span><span style=display:flex><span>        ReferenceCountingGc objB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReferenceCountingGc();
</span></span><span style=display:flex><span>        objA.<span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> objB;
</span></span><span style=display:flex><span>        objB.<span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> objA;
</span></span><span style=display:flex><span>        objA <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        objB <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上面代码所示，<code>objA</code> 和 <code>objB</code> 除了相互引用对方之外再无其他引用，但是因为它们的相互引用，导致两者的引用计数都不为 0，那么 JVM 就无法回收它们，导致内存浪费。</p><h3 id=可达性分析算法>可达性分析算法<a hidden class=anchor aria-hidden=true href=#可达性分析算法>#</a></h3><p>这个算法的基本思想是通过一系列称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为 <strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被 JVM 回收。</p><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/09/13/QL7tlf39kimo8xZ.png></p><p>上图中 <code>obj4</code>、<code>obj5</code>、<code>obj6</code> GC Roots 不可达，会被 JVM 回收。</p><p>通过可达性分析算法，解决了上面引用计数法的 “循环依赖” 问题。只要对象无法与 GC Root 建立直接 or 间接的连接，系统就会判定其为可回收对象。</p><p>既然这个方法是通过 GC Root 判断对象是否存活，那 GC Root 到底是什么？🤔</p><p>所谓 GC Roots，就是一组必须活跃的引用，<strong>不是对象</strong>，它们是程序运行时的起点，一切引用链的源头。在 Java 中 GC Roots 包括以下几种：</p><ul><li>虚拟机栈中的引用（比如方法的参数、局部变量）</li><li>本地方法栈中 JNI 的引用</li><li>类静态变量</li><li>运行时常量池中的常量（String 或者 Class 类型）</li></ul><p><img alt=image.png loading=lazy src=https://s2.loli.net/2025/09/27/Jm2lwBIu4KoNHVR.png></p><p>更具体一点，在代码中我们如何辨认 GC Roots 呢？下面以上面提到的前两种为例。</p><ol><li><strong>虚拟机栈中的引用（方法的参数、局部变量等）</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StackReference</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>greet</span>() {
</span></span><span style=display:flex><span>        Object localVar <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object(); <span style=color:#75715e>// 这里的 localVar 是一个局部变量，存在于虚拟机栈中</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(localVar.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> StackReference().<span style=color:#a6e22e>greet</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>greet()</code> 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。在该方法执行期间，localVar 引用的对象是活跃的，因为它们是从 GC Root 出发可达的。当 <code>greet()</code> 方法执行完毕，localVar 作用域结束，<strong>如果没有其他引用指向这些对象</strong>，它们就可以被视作垃圾进行回收。</p><ol start=2><li>本地方法栈中 JNI 的引用</li></ol><p>JNI（Java Native Interface） 是 Java 提供的一种机制，允许 Java 代码调用本地代码（C/C++）。和调用 Java 方法类似，当调用本地方法时，虚拟机会通过 <strong>动态链接</strong> 直接调用指定的本地方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 假设的JNI方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>native</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nativeMethod</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 假设在C/C++中实现的本地方法</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Class:     NativeExample
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Method:    nativeMethod
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Signature: ()V
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>JNIEXPORT <span style=color:#66d9ef>void</span> JNICALL <span style=color:#a6e22e>Java_NativeExample_nativeMethod</span>(JNIEnv <span style=color:#f92672>*</span>env, jobject thisObj) {
</span></span><span style=display:flex><span>    jobject localRef <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>env)<span style=color:#f92672>-&gt;</span>NewObject(env, ...); <span style=color:#75715e>// 在本地方法栈中创建JNI引用</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localRef 引用的Java对象在本地方法执行期间是活跃的</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>比如上面的代码，在本地代码（Java_NativeExample_nativeMethod）中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可被认为是 GC Roots。一旦这个本地方法执行完毕，除非 localRef 的引用是全局的，否则它指向的对象会被作为垃圾回收掉。</p><h2 id=垃圾收集算法>垃圾收集算法<a hidden class=anchor aria-hidden=true href=#垃圾收集算法>#</a></h2><p>垃圾收集算法 <strong>负责完成垃圾回收</strong>，主要包括：</p><ol><li>标记 - 清除算法</li><li>标记 - 整理算法</li><li>复制算法</li><li>分代收集算法</li></ol><p>这部分比较容易理解，不再过多赘述。</p><h2 id=堆空间的分代>堆空间的分代<a hidden class=anchor aria-hidden=true href=#堆空间的分代>#</a></h2><p>堆（Heap）是 JVM 中最大的一块内存区域，也是垃圾回收器管理的主要区域。</p><p>堆空间主要分为两个区域，<strong>年轻代和老年代</strong>，其中年轻代又分为 Eden 区和 Survivor 区，而 Survivor 区又分为 From 和 To 两个区。</p><p><img alt=image-20250927144904773 loading=lazy src=c:\\Users\\18627\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250927144904773.png></p><h3 id=eden-区>Eden 区<a hidden class=anchor aria-hidden=true href=#eden-区>#</a></h3><p>绝大多数对象存活时间并不会很长，因此 Java 对象在创建后会优先在 Eden 区进行内存分配，当 Eden 区没有足够空间时，JVM 会发起一次 <strong>Minor GC</strong>。</p><p>Minor GC 后，Eden 区中绝大部分对象会被回收，存活下来的对象会进到 From Survivor 区，如果 From 区不够，则直接进入 To 区。</p><h3 id=survivor-区>Survivor 区<a hidden class=anchor aria-hidden=true href=#survivor-区>#</a></h3><p><strong>Q1：为什么需要 Survivor 区，直接 Eden 到老年代不好吗？为什么还需要加这么一层？</strong></p><p>由于 Eden 区的 Minor GC 进行得比较频繁，如果没有 Survivor 区，存活的对象就会直接进入老年代，这样的话老年代很快就会被塞满，从而触发 Major GC，导致 STW，严重影响程序性能。</p><p>同时，有些对象虽然不会在 Minor GC 被回收，但也不会存活的太久，这时候直接放到老年代不太合适。所以 Survivor 存在的意义是 <strong>减少被送到老年代的对象</strong>，进而减少 Major GC 的发生。</p><p><strong>Q2：Survivor 区为什么需要被划分成 From 和 To 两个区域？</strong></p><p>Survivor 区被划分为两个区域，主要是为了高效地实施 <strong>复制算法</strong>，避免内存碎片，提升垃圾回收（尤其是 Minor GC）的效率。</p><p>具体来说，每次 Minor GC 时，JVM 会将 Eden 区和一个 Survivor 区（From）中仍然存活的对象复制到另一个 <strong>空的</strong> Survivor 区（To）。复制完成后，Eden 和 From 会被完全清空，此时，<strong>From 和 To 的角色会进行交换</strong>，原来的 To 区编程下一次 GC 的 From 区，原来的 From 区则变为新的空 To 区。</p><p><strong>如果只有一块 Survivor 区</strong>：</p><ul><li>Minor GC 后，Eden 和 Survivor 中都会有存活和死亡的对象交错存在</li><li>若要清理 Survivor 中的垃圾，可能需要用 <strong>标记 - 清除</strong> 算法，产生内存碎片；就算采用 <strong>标记 - 整理</strong> 算法，也会有 <strong>性能损耗大、停顿时间长</strong> 的问题</li><li>内存碎片会导致无法给大对象分配连续的空间，可能触发不必要的垃圾回收</li></ul><h3 id=old-区>Old 区<a hidden class=anchor aria-hidden=true href=#old-区>#</a></h3><p>老年代占堆空间的 2/3，只有在 Major GC/Full GC 时才会进行清理，每次 GC 都会触发 STW，内存越大，STW 的时间越长。</p><p>由于复制算法在对象存活率较高的老年代会进行多次赋值操作，效率低，所以老年代采用 <strong>标记 - 整理</strong> 算法。</p><p>另外，由于 <strong>内存担保机制</strong> 的存在，以下几种对象会直接进入老年代：</p><ul><li>需要大量连续内存的对象</li><li>长期存活对象</li><li>动态对象年龄：不强制要求对象年龄到 15 岁再放入老年代，如果 Survivor 中某个年龄段及以上的对象总大小超过 Survivor 的一半，也会在下一次 GC 时晋升到老年代</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>