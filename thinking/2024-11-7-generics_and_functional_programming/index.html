<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>泛型与函数式编程 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="泛型与函数式编程 - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yukipedia.cn/thinking/2024-11-7-generics_and_functional_programming/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/thinking/2024-11-7-generics_and_functional_programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/thinking/2024-11-7-generics_and_functional_programming/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="泛型与函数式编程"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="thinking"><meta property="article:published_time" content="2024-11-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-07T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="泛型与函数式编程"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Thinkings","item":"https://yukipedia.cn/thinking/"},{"@type":"ListItem","position":2,"name":"泛型与函数式编程","item":"https://yukipedia.cn/thinking/2024-11-7-generics_and_functional_programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"泛型与函数式编程","name":"泛型与函数式编程","description":"","keywords":[],"articleBody":"泛型与函数式编程 函数式编程：在Java中，函数式编程是一种编程范式，它把计算视为数学上的函数求值，并且避免了状态和可变数据。这意味着在函数式编程中，函数是“一等公民”，它们可以作为参数传递给其他函数，也可以作为结果从函数中返回。此外，函数式编程鼓励使用不可变对象来减少副作用，从而提高代码的可读性和可维护性。 泛型：泛型是Java语言的一个重要特性，它允许你在定义类、接口和方法时使用类型参数。这样做的好处是可以重用相同的代码来处理不同的数据类型，同时还能获得编译时的类型安全检查，避免运行时出现类型错误。简单来说，泛型就是一种参数化类型的机制，即所操作的数据类型可以被指定为一个参数，这种参数类型可以在使用时确定。 应用 我们以下面的需求为例子：\n方法 1： 方法 1 需要将任意 java 对象序列化为 json 并存储在 string 类型的 key 中，还需要设置 TTL 过期时间。显然这个方法并不需要返回值，我们可以复用 StringRedisTemplate 的 set 方法，并结合 JSONUtil 工具包的 toJsonStr 方法实现该功能。\n由于需要存储在 string 类型的 key 中，所以需要传入一个 String 类型的变量 key ；由于是任意 java 对象，因此 value 定义成 Object 类型；对于设置 TTL 过期时间，我们可以仿照 Spring 的风格，传入一个 Long 类型的 time 和一个 TimeUnit（时间单位）。\npublic void set(String key, Object value, Long time, TimeUnit unit) { stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } 方法 2： 在方法 1 的基础上需要添加一个逻辑过期时间，这里逻辑过期时间的作用是防止 redis 出现缓存击穿的情况，缓存击穿、穿透、雪崩的介绍在：https://yuk1pedia.github.io/2024/11/Cache-penetration,-cache-avalanche,-and-cache-breakdown/\n为了实现这个需求，我们额外定义一个 RedisData 类：\n@Data public class RedisData { private LocalDateTime expireTime; // 逻辑过期时间 private Object data; } 在这个类中，将具体的数据封装到 Object 对象 data 里，另外用 LocalDateTime 封装逻辑过期时间。\n于是我们就可以把用户传进来的数据封装到 RedisData 对象里了：\npublic void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) { // 设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); // 写入 redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } 上述两个存储缓存的方法并不需要用到函数式编程和泛型，下面查询缓存的方法就需要这两种编程技巧了。\n方法 3： 为了解决缓存穿透的问题，我们需要将查询到空值的 id 写入 redis 缓存中，那么下次查询相同的 id 时，访问就会落到缓存上，不会给数据库带来过大的压力。\nredis 中存放的对象类型很多，但 redis 是基于 key-value 的 NoSQL 数据库，查询的逻辑都是通过 key 值来找到对应的 value 值，所以这里考虑用同一套查询逻辑实现对不同类型对象的查询。\n在 redis 中，对象一般是以 json 字符串的形式存放，我们从中拿到需要的数据后要进行反序列化，但问题是我们要将 json 字符串反序列化成什么类型的对象？很明显，这个信息在后端工程里无法得到，需要用户指定。因此这里就可以利用到 java 的泛型特点，我们将方法 3 的返回类型指定成泛型，用户传入需要查询的对象类型后执行一套查询逻辑，将查询结果返回给用户。\n查询前我们需要得知用户想根据哪个 key 查询，考虑到 redis 的 NoSQL 特性，传入的这个 key 不一定是 Long 类型或者 Int 类型，因此还需要定义另外一个传入参数的泛型。\n当用户传入了需要查询的对象类型和 key 后，我们可以调用 StringRedisTemplate 的 get 方法到缓存数据库中查询。如果缓存命中，就直接返回；如果缓存没有命中，这个访问就落到后端数据库上，我们就需要进行后端数据库的查询操作。\n但这里有一个问题，我们并不知道如何查询后端数据库，因为我们编写的是一个工具类，并不会在这个类里注入持久层的对象进行数据库的查询，于是这里就需要用到函数式编程的特性：将查询的方法作为参数，传入工具类的查询方法里。\n// 解决缓存穿透的根据 id 查询方法 public \u003cR, ID\u003e R queryWithPassThrough( String keyPrefix, ID id, Class\u003cR\u003e type, Function\u003cID, R\u003e dbFallback, Long time, TimeUnit unit) { String key = CACHE_SHOP_KEY + id; // 根据 id 查询商铺缓存 String Json = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(Json)) { // redis 中存在，直接返回（isNotBlank只有在字符串为\"abc\"这种时才返回 true，空字符串、空格回车都返回 false） return JSONUtil.toBean(Json, type); } // 判断命中的是否为空值 if (Json != null) { return null; } // redis 中不存在，查询后端数据库 R r = dbFallback.apply(id); if (r == null) { // 往 redis 里写入空值，防止缓存穿透 stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES); return null; } // 后端数据库存在对应店铺，就写入 redis 缓存中 this.set(key, r, time, unit); return r; } 方法 4： 方法 4 和方法 3 的思路相同，也要用到函数式编程和泛型，具体不再赘述。可以看看方法 4 是如何使用逻辑过期来解决缓存击穿问题的。\n// 使用逻辑过期解决缓存击穿问题 public \u003cR, ID\u003e R queryWithLogicalExpire( String keyPrefix, ID id, Class\u003cR\u003e type, Function\u003cID, R\u003e dbFallback, Long time, TimeUnit unit) { String key = CACHE_SHOP_KEY + id; // 根据 id 查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isBlank(shopJson)) { // 没有命中就返回（命中了还需要查询是否逻辑过期） return null; } // 命中，需要判断过期时间 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime(); // 判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 没有过期 return r; } // 已经过期，进行缓存重建 String lockKey = LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 判断获取锁是否成功 if (isLock) { // 获取锁成功，开启独立线程实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u003e { try { // 查询数据库 R r1 = dbFallback.apply(id); // 写入 redis this.setWithLogicalExpire(key, r1, time, unit); } catch (Exception e) { throw new RuntimeException(e); } finally { unLock(lockKey); } }); } return r; } 完整工具类和调用过程代码 工具类：\n@Component @Slf4j public class CacheClient { private final StringRedisTemplate stringRedisTemplate; public CacheClient(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public void set(String key, Object value, Long time, TimeUnit unit) { stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit); } public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) { // 设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time))); // 写入 redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } // 解决缓存穿透的根据 id 查询方法 public \u003cR, ID\u003e R queryWithPassThrough( String keyPrefix, ID id, Class\u003cR\u003e type, Function\u003cID, R\u003e dbFallback, Long time, TimeUnit unit) { String key = CACHE_SHOP_KEY + id; // 根据 id 查询商铺缓存 String Json = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isNotBlank(Json)) { // redis 中存在，直接返回（isNotBlank只有在字符串为\"abc\"这种时才返回 true，空字符串、空格回车都返回 false） return JSONUtil.toBean(Json, type); } // 判断命中的是否为空值 if (Json != null) { return null; } // redis 中不存在，查询后端数据库 R r = dbFallback.apply(id); if (r == null) { // 往 redis 里写入空值，防止缓存穿透 stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES); return null; } // 后端数据库存在对应店铺，就写入 redis 缓存中 this.set(key, r, time, unit); return r; } // 线程池 private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); // 使用逻辑过期解决缓存击穿问题 public \u003cR, ID\u003e R queryWithLogicalExpire( String keyPrefix, ID id, Class\u003cR\u003e type, Function\u003cID, R\u003e dbFallback, Long time, TimeUnit unit) { String key = CACHE_SHOP_KEY + id; // 根据 id 查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isBlank(shopJson)) { // 没有命中就返回（命中了还需要查询是否逻辑过期） return null; } // 命中，需要判断过期时间 RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); R r = JSONUtil.toBean((JSONObject) redisData.getData(), type); LocalDateTime expireTime = redisData.getExpireTime(); // 判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 没有过期 return r; } // 已经过期，进行缓存重建 String lockKey = LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 判断获取锁是否成功 if (isLock) { // 获取锁成功，开启独立线程实现缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -\u003e { try { // 查询数据库 R r1 = dbFallback.apply(id); // 写入 redis this.setWithLogicalExpire(key, r1, time, unit); } catch (Exception e) { throw new RuntimeException(e); } finally { unLock(lockKey); } }); } return r; } private boolean tryLock(String key) { Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } private void unLock(String key) { stringRedisTemplate.delete(key); } } 在应用层的调用：\n@Resource private CacheClient cacheClient; /** * 根据缓存实现 id 查询商铺 * @param id * @return */ @Override public Result queryById(Long id) { // 防止缓存穿透的查询方式 // Shop shop = cacheClient // .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); // 互斥锁解决缓存击穿 // Shop shop = queryWithMutex(id); // 逻辑过期解决缓存击穿 Shop shop = cacheClient .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES); if (shop == null) { return Result.fail(\"店铺不存在！\"); } return Result.ok(shop); } ","wordCount":"787","inLanguage":"en","datePublished":"2024-11-07T00:00:00Z","dateModified":"2024-11-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/thinking/2024-11-7-generics_and_functional_programming/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">泛型与函数式编程</h1><div class=post-meta><span title='2024-11-07 00:00:00 +0000 UTC'>November 7, 2024</span></div></header><div class=post-content><h2 id=泛型与函数式编程>泛型与函数式编程<a hidden class=anchor aria-hidden=true href=#泛型与函数式编程>#</a></h2><ul><li>函数式编程：在Java中，函数式编程是一种编程范式，它把计算视为数学上的函数求值，并且避免了状态和可变数据。这意味着在函数式编程中，函数是“一等公民”，<strong>它们可以作为参数传递给其他函数，也可以作为结果从函数中返回</strong>。此外，函数式编程鼓励使用不可变对象来减少副作用，从而提高代码的可读性和可维护性。</li><li>泛型：泛型是Java语言的一个重要特性，它允许你在定义类、接口和方法时使用<strong>类型参数</strong>。这样做的好处是<strong>可以重用相同的代码来处理不同的数据类型</strong>，同时还能获得编译时的类型安全检查，避免运行时出现类型错误。简单来说，泛型就是一种参数化类型的机制，即所操作的数据类型可以被指定为一个参数，这种参数类型可以在使用时确定。</li></ul><h2 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h2><p>我们以下面的需求为例子：</p><p><img alt=1.png loading=lazy src=https://s2.loli.net/2024/11/07/sWRkoalcH5EjJKQ.png></p><h4 id=方法-1>方法 1：<a hidden class=anchor aria-hidden=true href=#方法-1>#</a></h4><p>方法 1 需要将任意 java 对象序列化为 json 并存储在 string 类型的 key 中，还需要设置 TTL 过期时间。显然这个方法并不需要返回值，我们可以复用 <code>StringRedisTemplate</code> 的 <code>set</code> 方法，并结合 <code>JSONUtil</code> 工具包的 <code>toJsonStr</code> 方法实现该功能。</p><p>由于需要存储在 string 类型的 key 中，所以需要传入一个 String 类型的变量 key ；由于是任意 java 对象，因此 value 定义成 Object 类型；对于设置 TTL 过期时间，我们可以仿照 Spring 的风格，传入一个 Long 类型的 time 和一个 TimeUnit（时间单位）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String key, Object value, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>    stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, JSONUtil.<span style=color:#a6e22e>toJsonStr</span>(value), time, unit);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=方法-2>方法 2：<a hidden class=anchor aria-hidden=true href=#方法-2>#</a></h4><p>在方法 1 的基础上需要添加一个<strong>逻辑过期时间</strong>，这里逻辑过期时间的作用是防止 redis 出现<strong>缓存击穿</strong>的情况，缓存击穿、穿透、雪崩的介绍在：https://yuk1pedia.github.io/2024/11/Cache-penetration,-cache-avalanche,-and-cache-breakdown/</p><p>为了实现这个需求，我们额外定义一个 <code>RedisData</code> 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RedisData</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> LocalDateTime expireTime; <span style=color:#75715e>// 逻辑过期时间</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Object data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个类中，将具体的数据封装到 <code>Object</code> 对象 data 里，另外用 <code>LocalDateTime</code> 封装逻辑过期时间。</p><p>于是我们就可以把用户传进来的数据封装到 <code>RedisData</code> 对象里了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setWithLogicalExpire</span>(String key, Object value, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置逻辑过期</span>
</span></span><span style=display:flex><span>    RedisData redisData <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RedisData();
</span></span><span style=display:flex><span>    redisData.<span style=color:#a6e22e>setData</span>(value);
</span></span><span style=display:flex><span>    redisData.<span style=color:#a6e22e>setExpireTime</span>(LocalDateTime.<span style=color:#a6e22e>now</span>().<span style=color:#a6e22e>plusSeconds</span>(unit.<span style=color:#a6e22e>toSeconds</span>(time)));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 写入 redis</span>
</span></span><span style=display:flex><span>    stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, JSONUtil.<span style=color:#a6e22e>toJsonStr</span>(redisData));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述两个存储缓存的方法并不需要用到函数式编程和泛型，下面查询缓存的方法就需要这两种编程技巧了。</p><h4 id=方法-3>方法 3：<a hidden class=anchor aria-hidden=true href=#方法-3>#</a></h4><p>为了解决缓存穿透的问题，我们需要将查询到空值的 id 写入 redis 缓存中，那么下次查询相同的 id 时，访问就会落到缓存上，不会给数据库带来过大的压力。</p><p>redis 中存放的<strong>对象类型很多</strong>，但 redis 是基于 <code>key-value</code> 的 NoSQL 数据库，查询的逻辑都是通过 key 值来找到对应的 value 值，<strong>所以这里考虑用同一套查询逻辑实现对不同类型对象的查询</strong>。</p><p>在 redis 中，对象一般是以 json 字符串的形式存放，我们从中拿到需要的数据后要进行反序列化，但问题是<strong>我们要将 json 字符串反序列化成什么类型的对象</strong>？很明显，这个信息在后端工程里无法得到，需要用户指定。因此这里就可以利用到 java 的<strong>泛型</strong>特点，我们将方法 3 的返回类型指定成泛型，用户传入需要查询的对象类型后执行一套查询逻辑，将查询结果返回给用户。</p><p>查询前我们需要得知用户想根据哪个 key 查询，考虑到 redis 的 NoSQL 特性，传入的这个 key 不一定是 Long 类型或者 Int 类型，<strong>因此还需要定义另外一个传入参数的泛型</strong>。</p><p>当用户传入了需要查询的对象类型和 key 后，我们可以调用 <code>StringRedisTemplate</code> 的 <code>get</code> 方法到缓存数据库中查询。如果缓存命中，就直接返回；如果缓存没有命中，这个访问就落到后端数据库上，<strong>我们就需要进行后端数据库的查询操作</strong>。</p><p>但这里有一个问题，<strong>我们并不知道如何查询后端数据库</strong>，因为我们编写的是一个工具类，并不会在这个类里注入持久层的对象进行数据库的查询，于是这里就需要用到<strong>函数式编程</strong>的特性：将查询的方法作为参数，传入工具类的查询方法里。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 解决缓存穿透的根据 id 查询方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R, ID<span style=color:#f92672>&gt;</span> R <span style=color:#a6e22e>queryWithPassThrough</span>(
</span></span><span style=display:flex><span>        String keyPrefix, ID id, Class<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> type, Function<span style=color:#f92672>&lt;</span>ID, R<span style=color:#f92672>&gt;</span> dbFallback, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>    String key <span style=color:#f92672>=</span> CACHE_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据 id 查询商铺缓存</span>
</span></span><span style=display:flex><span>    String Json <span style=color:#f92672>=</span> stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (StrUtil.<span style=color:#a6e22e>isNotBlank</span>(Json)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// redis 中存在，直接返回（isNotBlank只有在字符串为&#34;abc&#34;这种时才返回 true，空字符串、空格回车都返回 false）</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> JSONUtil.<span style=color:#a6e22e>toBean</span>(Json, type);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断命中的是否为空值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Json <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// redis 中不存在，查询后端数据库</span>
</span></span><span style=display:flex><span>    R r <span style=color:#f92672>=</span> dbFallback.<span style=color:#a6e22e>apply</span>(id);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 往 redis 里写入空值，防止缓存穿透</span>
</span></span><span style=display:flex><span>        stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, <span style=color:#e6db74>&#34;&#34;</span>, CACHE_NULL_TTL, TimeUnit.<span style=color:#a6e22e>MINUTES</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 后端数据库存在对应店铺，就写入 redis 缓存中</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>set</span>(key, r, time, unit);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=方法-4>方法 4：<a hidden class=anchor aria-hidden=true href=#方法-4>#</a></h3><p>方法 4 和方法 3 的思路相同，也要用到函数式编程和泛型，具体不再赘述。可以看看方法 4 是如何使用逻辑过期来解决缓存击穿问题的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 使用逻辑过期解决缓存击穿问题</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R, ID<span style=color:#f92672>&gt;</span> R <span style=color:#a6e22e>queryWithLogicalExpire</span>(
</span></span><span style=display:flex><span>        String keyPrefix, ID id, Class<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> type, Function<span style=color:#f92672>&lt;</span>ID, R<span style=color:#f92672>&gt;</span> dbFallback, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>    String key <span style=color:#f92672>=</span> CACHE_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据 id 查询商铺缓存</span>
</span></span><span style=display:flex><span>    String shopJson <span style=color:#f92672>=</span> stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (StrUtil.<span style=color:#a6e22e>isBlank</span>(shopJson)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 没有命中就返回（命中了还需要查询是否逻辑过期）</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 命中，需要判断过期时间</span>
</span></span><span style=display:flex><span>    RedisData redisData <span style=color:#f92672>=</span> JSONUtil.<span style=color:#a6e22e>toBean</span>(shopJson, RedisData.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>    R r <span style=color:#f92672>=</span> JSONUtil.<span style=color:#a6e22e>toBean</span>((JSONObject) redisData.<span style=color:#a6e22e>getData</span>(), type);
</span></span><span style=display:flex><span>    LocalDateTime expireTime <span style=color:#f92672>=</span> redisData.<span style=color:#a6e22e>getExpireTime</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断是否过期</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (expireTime.<span style=color:#a6e22e>isAfter</span>(LocalDateTime.<span style=color:#a6e22e>now</span>())) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 没有过期</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 已经过期，进行缓存重建</span>
</span></span><span style=display:flex><span>    String lockKey <span style=color:#f92672>=</span> LOCK_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> isLock <span style=color:#f92672>=</span> tryLock(lockKey);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断获取锁是否成功</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isLock) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取锁成功，开启独立线程实现缓存重建</span>
</span></span><span style=display:flex><span>        CACHE_REBUILD_EXECUTOR.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 查询数据库</span>
</span></span><span style=display:flex><span>                R r1 <span style=color:#f92672>=</span> dbFallback.<span style=color:#a6e22e>apply</span>(id);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 写入 redis</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setWithLogicalExpire</span>(key, r1, time, unit);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                unLock(lockKey);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=完整工具类和调用过程代码>完整工具类和调用过程代码<a hidden class=anchor aria-hidden=true href=#完整工具类和调用过程代码>#</a></h2><p>工具类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CacheClient</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> StringRedisTemplate stringRedisTemplate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>CacheClient</span>(StringRedisTemplate stringRedisTemplate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>stringRedisTemplate</span> <span style=color:#f92672>=</span> stringRedisTemplate;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String key, Object value, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>        stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, JSONUtil.<span style=color:#a6e22e>toJsonStr</span>(value), time, unit);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setWithLogicalExpire</span>(String key, Object value, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置逻辑过期</span>
</span></span><span style=display:flex><span>        RedisData redisData <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RedisData();
</span></span><span style=display:flex><span>        redisData.<span style=color:#a6e22e>setData</span>(value);
</span></span><span style=display:flex><span>        redisData.<span style=color:#a6e22e>setExpireTime</span>(LocalDateTime.<span style=color:#a6e22e>now</span>().<span style=color:#a6e22e>plusSeconds</span>(unit.<span style=color:#a6e22e>toSeconds</span>(time)));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写入 redis</span>
</span></span><span style=display:flex><span>        stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, JSONUtil.<span style=color:#a6e22e>toJsonStr</span>(redisData));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解决缓存穿透的根据 id 查询方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R, ID<span style=color:#f92672>&gt;</span> R <span style=color:#a6e22e>queryWithPassThrough</span>(
</span></span><span style=display:flex><span>            String keyPrefix, ID id, Class<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> type, Function<span style=color:#f92672>&lt;</span>ID, R<span style=color:#f92672>&gt;</span> dbFallback, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>        String key <span style=color:#f92672>=</span> CACHE_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据 id 查询商铺缓存</span>
</span></span><span style=display:flex><span>        String Json <span style=color:#f92672>=</span> stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (StrUtil.<span style=color:#a6e22e>isNotBlank</span>(Json)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// redis 中存在，直接返回（isNotBlank只有在字符串为&#34;abc&#34;这种时才返回 true，空字符串、空格回车都返回 false）</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> JSONUtil.<span style=color:#a6e22e>toBean</span>(Json, type);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断命中的是否为空值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Json <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// redis 中不存在，查询后端数据库</span>
</span></span><span style=display:flex><span>        R r <span style=color:#f92672>=</span> dbFallback.<span style=color:#a6e22e>apply</span>(id);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 往 redis 里写入空值，防止缓存穿透</span>
</span></span><span style=display:flex><span>            stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(key, <span style=color:#e6db74>&#34;&#34;</span>, CACHE_NULL_TTL, TimeUnit.<span style=color:#a6e22e>MINUTES</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 后端数据库存在对应店铺，就写入 redis 缓存中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>set</span>(key, r, time, unit);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 线程池</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ExecutorService CACHE_REBUILD_EXECUTOR <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(10);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用逻辑过期解决缓存击穿问题</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>R, ID<span style=color:#f92672>&gt;</span> R <span style=color:#a6e22e>queryWithLogicalExpire</span>(
</span></span><span style=display:flex><span>            String keyPrefix, ID id, Class<span style=color:#f92672>&lt;</span>R<span style=color:#f92672>&gt;</span> type, Function<span style=color:#f92672>&lt;</span>ID, R<span style=color:#f92672>&gt;</span> dbFallback, Long time, TimeUnit unit) {
</span></span><span style=display:flex><span>        String key <span style=color:#f92672>=</span> CACHE_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据 id 查询商铺缓存</span>
</span></span><span style=display:flex><span>        String shopJson <span style=color:#f92672>=</span> stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (StrUtil.<span style=color:#a6e22e>isBlank</span>(shopJson)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 没有命中就返回（命中了还需要查询是否逻辑过期）</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 命中，需要判断过期时间</span>
</span></span><span style=display:flex><span>        RedisData redisData <span style=color:#f92672>=</span> JSONUtil.<span style=color:#a6e22e>toBean</span>(shopJson, RedisData.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        R r <span style=color:#f92672>=</span> JSONUtil.<span style=color:#a6e22e>toBean</span>((JSONObject) redisData.<span style=color:#a6e22e>getData</span>(), type);
</span></span><span style=display:flex><span>        LocalDateTime expireTime <span style=color:#f92672>=</span> redisData.<span style=color:#a6e22e>getExpireTime</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断是否过期</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (expireTime.<span style=color:#a6e22e>isAfter</span>(LocalDateTime.<span style=color:#a6e22e>now</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 没有过期</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 已经过期，进行缓存重建</span>
</span></span><span style=display:flex><span>        String lockKey <span style=color:#f92672>=</span> LOCK_SHOP_KEY <span style=color:#f92672>+</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> isLock <span style=color:#f92672>=</span> tryLock(lockKey);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断获取锁是否成功</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isLock) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取锁成功，开启独立线程实现缓存重建</span>
</span></span><span style=display:flex><span>            CACHE_REBUILD_EXECUTOR.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 查询数据库</span>
</span></span><span style=display:flex><span>                    R r1 <span style=color:#f92672>=</span> dbFallback.<span style=color:#a6e22e>apply</span>(id);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 写入 redis</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setWithLogicalExpire</span>(key, r1, time, unit);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    unLock(lockKey);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryLock</span>(String key) {
</span></span><span style=display:flex><span>        Boolean flag <span style=color:#f92672>=</span> stringRedisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>setIfAbsent</span>(key, <span style=color:#e6db74>&#34;1&#34;</span>, 10, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BooleanUtil.<span style=color:#a6e22e>isTrue</span>(flag);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unLock</span>(String key) {
</span></span><span style=display:flex><span>        stringRedisTemplate.<span style=color:#a6e22e>delete</span>(key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在应用层的调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Resource</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> CacheClient cacheClient;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 根据缓存实现 id 查询商铺
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param id
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Result <span style=color:#a6e22e>queryById</span>(Long id) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 防止缓存穿透的查询方式</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        Shop shop = cacheClient</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 互斥锁解决缓存击穿</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        Shop shop = queryWithMutex(id);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 逻辑过期解决缓存击穿</span>
</span></span><span style=display:flex><span>    Shop shop <span style=color:#f92672>=</span> cacheClient
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>queryWithLogicalExpire</span>(CACHE_SHOP_KEY, id, Shop.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>this</span>::getById, CACHE_SHOP_TTL, TimeUnit.<span style=color:#a6e22e>MINUTES</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (shop <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Result.<span style=color:#a6e22e>fail</span>(<span style=color:#e6db74>&#34;店铺不存在！&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Result.<span style=color:#a6e22e>ok</span>(shop);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>