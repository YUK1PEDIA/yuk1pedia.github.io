<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>常用设计模式&面向对象设计法则 | YUKIPEDIA's blog</title><meta name=keywords content><meta name=description content="常用设计模式&面向对象设计法则 - YUKIPEDIA's blog"><meta name=author content><link rel=canonical href=https://yukipedia.cn/thinking/2025-6-18-design_pattern/><link crossorigin=anonymous href=../../assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://yukipedia.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yukipedia.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yukipedia.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://yukipedia.cn/apple-touch-icon.png><link rel=mask-icon href=https://yukipedia.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yukipedia.cn/thinking/2025-6-18-design_pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yukipedia.cn/thinking/2025-6-18-design_pattern/"><meta property="og:site_name" content="YUKIPEDIA's blog"><meta property="og:title" content="常用设计模式&面向对象设计法则"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="thinking"><meta property="article:published_time" content="2025-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="常用设计模式&面向对象设计法则"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Thinkings","item":"https://yukipedia.cn/thinking/"},{"@type":"ListItem","position":2,"name":"常用设计模式\u0026面向对象设计法则","item":"https://yukipedia.cn/thinking/2025-6-18-design_pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"常用设计模式\u0026面向对象设计法则","name":"常用设计模式\u0026面向对象设计法则","description":"","keywords":[],"articleBody":"常用的设计模式 创建型 Factory Method (工厂方法)：“ 让子类决定生产什么对象 ”，父类定规则，子类做决定，把对象的创建延迟到子类，避免硬编码 new 解决了什么问题？ 解耦，客户端（Main 类）不需要知道具体实现，只依赖抽象 扩展性，新增种类时只需要增加新的实现类 符合开闭原则 Abstract Factory (抽象工厂方法)：“ 一站式生产整套产品 ”，定义一个超级工厂接口，让具体工厂生产同一品牌的全套产品 解决了什么问题？ 保证产品兼容性 切换产品族方便 符合开闭原则 Builder(建造者模式)：“ 分步骤组装复杂对象 ”，当一个对象参数很多，用构造函数传参会很臃肿，并且难以扩展。可以采用 Builder 模式，分步骤设置参数，最后统一组装对象 解决了什么问题？ 参数灵活，可以只设置需要的参数 代码可读，链式调用清晰表达组装逻辑 避免无效状态，通过 build() 方法统一校验参数 Singleton(单例模式)：“ 一个类只能有一个实例 ”，某些对象（如配置管理器、数据库连接池）必须全局唯一，重复创建会浪费资源或导致数据不一致 结构型 Adapter(适配器模式)：“ 转换接口，兼容新旧 ”，两个系统或类因为接口不兼容无法直接合作（比如老代码调用新库，或第三方接口不匹配）。适配器模式加一个 中间层（适配器），把 “旧接口” 转换成 “新接口” 举个例子，假设你的电商系统需要同时支持 微信支付 和 支付宝，但它们的接口完全不同：微信的接口返回 boolean 表示成功与否，支付宝返回 PayResult 对象。但你希望对外提供统一的支付接口，屏蔽底层差异，这里就可以使用 adaptor Bridge(桥接模式)：“ 把抽象和实现分开，让它们自由组合 ”，当一个类有多个变化维度（比如“形状”和“颜色”），用继承会导致类爆炸（不用为每种组合创建子类） 类比一下，抽象 相当于遥控器的按钮（开/关、调音量），实现 相当于不同品牌的电视（索尼、小米），桥接 相当于遥控器持有电视的引用，但不知道具体品牌 Decorator(装饰器模式)：“ 给对象动态加功能，像套娃一样层层包装 ”，当我们想给一个对象添加新功能，但不想修改它的源代码（避免破坏原有逻辑），就可以用 装饰器类 包裹原始对象，在 不改变原对象 的基础上，动态添加功能 Flyweight(享元模式)：“ 共享相同部分，节省内存 ”，当程序需要创建大量相似对象时（比如游戏中的子弹、棋子、文字），每个对象都独立存储数据会浪费内存，我们就可以采用 享元模式，拆分对象的属性为内部状态（不变的、可共享的数据）和外部状态（变化的，不可共享的数据） Proxy(代理模式)：“ 找个替身帮你干活 ”，直接访问某个对象可能会带来问题（比如性能开销、权限控制、远程调用等），于是我们引入一个代理对象，在客户端和目标对象之间加一层控制，由代理决定如何处理请求 行为型 Template(模板方法模式)：“ 定好流程大纲，具体步骤自己填 ” ，多个任务有 相同的流程，但某些步骤的具体实现不同（比如做咖啡和泡茶，步骤类似，但细节不同），于是我们可以抽象父类的整体流程（模板方法），子类只需要实现自己需要定制的步骤 Method(方法模式)：“ 把复杂操作拆成小步骤，让代码更清晰 ”，当一个方法过于复杂（比如几十行代码，混合了多种逻辑），会导致难以阅读和维护，并且无法复用部分代码，于是我们 把大方法拆分成多个小方法，每个小方法只做一件事，再组合起来完成大功能 Chain Of Responsibility(责任链模式)：\" 踢皮球，一个请求在多个对象之间传递 “，一个请求需要经过多个处理者，但不确定具体由谁处理（比如不同金额的报销需要不同级别审批），于是我们把多个处理者串成一条链，请求沿着链传递，直到被处理或链结束 解决了什么问题？ 解耦，请求发送者不需要知道具体谁处理 动态调整，可以随时增减或调整处理者顺序 灵活性，每个处理者只需关注自己的责任范围 Iterator(迭代器模式)：“ 统一遍历所有对象，不关心底层结构 ”，不同的集合（如数组、链表、树）遍历方式不同，直接暴露内部结构会让代码混乱，于是提供统一的遍历接口，隐藏集合的内部实现 解决了什么问题？ 解耦，遍历代码不依赖具体集合实现（数组、链表、树都能用同一套遍历逻辑） 简化调用，用户只需调 hasNext() 和 next()，不用关心底层是 for 循环还是 while Observer(观察者模式)：“ 微信订阅号，作者发布，粉丝自动收到推送 ”，当一个对象（如天气数据）变化时，需要自动通知多个依赖对象（如手机App、广告牌），但 不想让它们紧密耦合，我们可以这样解决： 被观察者（Subject）：维护一个订阅者列表，提供 添加/删除 订阅的方法 观察者（Observer）：定义统一的更新接口（如 update()） 流程：被观察者状态变化 → 遍历订阅者列表 → 调用每个观察者的 update() State(状态模式)：“ 对象变，行为跟着变 ”，当一个对象的行为 取决于它的状态（比如订单的 “待支付”、“已发货”），如果用一堆 if-else 判断状态，代码会臃肿且难维护，于是我们可以 把状态抽成独立的类，对象内部切换状态，行为自动变化 Strategy(策略模式)：“ 算法随便换，调用不改变 ”，当一个任务有 多种算法（如排序、支付、导航），用 if-else 硬编码会导致代码臃肿且难扩展，于是我们可以定义算法接口，将每种算法封装成独立类，运行时动态的切换算法，调用方无需关心细节 比如导航 App，选 “最快路线” 或 “最省钱路线”，App 自动计算，但导航按钮始终是同一个；支付系统，用户选微信支付或支付宝，支付流程不变，只是底层实现不同 解决了什么问题？ 开闭原则，新增算法只需要加新类，不需要改旧代码 复用性，同一套算法可被多个场景共享 面向对象（OO）的设计法则 单一职责原则：一个类只干一件事 开闭原则：对扩展开放，对修改关闭 里氏替换原则：子类必须能替换父类，且行为一致（防止调用父类方法时，子类抛出 不支持的操作 异常） 接口隔离原则：接口要小而专，不能让用户实现用不到的方法 比如：Animal 接口有 fly()、swim()、run()，但 Dog 类被迫实现无用的 fly() 依赖倒置原则：依赖抽象，不依赖具体 比如： 错误设计：OrderService 直接调用 MySQLDatabase 正确设计：OrderService 依赖 Database 接口，具体用 MySQL 还是 Mongo 由配置决定 迪米特法则：少管闲事，只和朋友通信（减少类之间的耦合） 组合由于继承原则：多用组合，少用继承 ","wordCount":"171","inLanguage":"en","datePublished":"2025-06-18T00:00:00Z","dateModified":"2025-06-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://yukipedia.cn/thinking/2025-6-18-design_pattern/"},"publisher":{"@type":"Organization","name":"YUKIPEDIA's blog","logo":{"@type":"ImageObject","url":"https://yukipedia.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yukipedia.cn/ accesskey=h title="YUKIPEDIA's blog (Alt + H)">YUKIPEDIA's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yukipedia.cn/about title="About me?"><span>About me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">常用设计模式&面向对象设计法则</h1><div class=post-meta><span title='2025-06-18 00:00:00 +0000 UTC'>June 18, 2025</span></div></header><div class=post-content><h2 id=常用的设计模式>常用的设计模式<a hidden class=anchor aria-hidden=true href=#常用的设计模式>#</a></h2><ol><li>创建型<ul><li><strong>Factory Method (工厂方法)</strong>：“ <strong>让子类决定生产什么对象</strong> ”，父类定规则，子类做决定，把对象的创建延迟到子类，避免硬编码 new<ul><li>解决了什么问题？<ul><li>解耦，客户端（<code>Main</code> 类）不需要知道具体实现，只依赖抽象</li><li>扩展性，新增种类时只需要增加新的实现类</li><li>符合开闭原则</li></ul></li></ul></li><li><strong>Abstract Factory (抽象工厂方法)</strong>：“ <strong>一站式生产整套产品</strong> ”，定义一个超级工厂接口，让具体工厂生产同一品牌的全套产品<ul><li>解决了什么问题？<ul><li>保证产品兼容性</li><li>切换产品族方便</li><li>符合开闭原则</li></ul></li></ul></li><li><strong>Builder(建造者模式)</strong>：“ <strong>分步骤组装复杂对象</strong> ”，当一个对象参数很多，用构造函数传参会很臃肿，并且难以扩展。可以采用 Builder 模式，<strong>分步骤设置参数</strong>，最后统一组装对象<ul><li>解决了什么问题？<ul><li>参数灵活，可以只设置需要的参数</li><li>代码可读，链式调用清晰表达组装逻辑</li><li>避免无效状态，通过 <code>build()</code> 方法统一校验参数</li></ul></li></ul></li><li><strong>Singleton(单例模式)</strong>：“ <strong>一个类只能有一个实例</strong> ”，某些对象（如配置管理器、数据库连接池）必须<strong>全局唯一</strong>，重复创建会浪费资源或导致数据不一致</li></ul></li><li>结构型<ul><li><strong>Adapter(适配器模式)</strong>：“ <strong>转换接口，兼容新旧</strong> ”，两个系统或类因为<strong>接口不兼容</strong>无法直接合作（比如老代码调用新库，或第三方接口不匹配）。适配器模式加一个 <strong>中间层（适配器）</strong>，把 “旧接口” 转换成 “新接口”<ul><li>举个例子，假设你的电商系统需要同时支持 <strong>微信支付</strong> 和 <strong>支付宝</strong>，但它们的接口完全不同：微信的接口返回 boolean 表示成功与否，支付宝返回 PayResult 对象。但你希望对外提供统一的支付接口，屏蔽底层差异，这里就可以使用 adaptor</li></ul></li><li><strong>Bridge(桥接模式)</strong>：“ <strong>把抽象和实现分开，让它们自由组合</strong> ”，当一个类有多个变化维度（比如“形状”和“颜色”），用继承会导致类爆炸（不用为每种组合创建子类）<ul><li>类比一下，<strong>抽象</strong> 相当于遥控器的按钮（开/关、调音量），<strong>实现</strong> 相当于不同品牌的电视（索尼、小米），<strong>桥接</strong> 相当于遥控器持有电视的引用，但不知道具体品牌</li></ul></li><li><strong>Decorator(装饰器模式)</strong>：“ <strong>给对象动态加功能，像套娃一样层层包装</strong> ”，当我们想给一个对象添加新功能，但不想修改它的源代码（避免破坏原有逻辑），就可以用 <strong>装饰器类</strong> 包裹原始对象，在 <strong>不改变原对象</strong> 的基础上，动态添加功能</li><li><strong>Flyweight(享元模式)</strong>：“ <strong>共享相同部分，节省内存</strong> ”，当程序需要创建<strong>大量相似对象</strong>时（比如游戏中的子弹、棋子、文字），每个对象都独立存储数据会浪费内存，我们就可以采用 <strong>享元模式</strong>，拆分对象的属性为内部状态（不变的、可共享的数据）和外部状态（变化的，不可共享的数据）</li><li><strong>Proxy(代理模式)</strong>：“ <strong>找个替身帮你干活</strong> ”，直接访问某个对象可能会带来问题（比如性能开销、权限控制、远程调用等），于是我们引入一个代理对象，在客户端和目标对象之间加一层控制，由代理决定如何处理请求</li></ul></li><li>行为型<ul><li><strong>Template(模板方法模式)</strong>：“ <strong>定好流程大纲，具体步骤自己填</strong> ” ，多个任务有 <strong>相同的流程</strong>，但某些步骤的具体实现不同（比如做咖啡和泡茶，步骤类似，但细节不同），于是我们可以抽象父类的整体流程（模板方法），子类只需要实现自己需要定制的步骤</li><li><strong>Method(方法模式)</strong>：“ <strong>把复杂操作拆成小步骤，让代码更清晰</strong> ”，当一个方法过于复杂（比如几十行代码，混合了多种逻辑），会导致难以阅读和维护，并且无法复用部分代码，于是我们 <strong>把大方法拆分成多个小方法</strong>，每个小方法只做一件事，再组合起来完成大功能</li><li><strong>Chain Of Responsibility(责任链模式)</strong>：" <strong>踢皮球，一个请求在多个对象之间传递</strong> &ldquo;，一个请求需要经过多个处理者，但不确定具体由谁处理（比如不同金额的报销需要不同级别审批），于是我们把多个处理者串成一条链，请求沿着链传递，直到被处理或链结束<ul><li>解决了什么问题？<ul><li>解耦，请求发送者不需要知道具体谁处理</li><li>动态调整，可以随时增减或调整处理者顺序</li><li>灵活性，每个处理者只需关注自己的责任范围</li></ul></li></ul></li><li><strong>Iterator(迭代器模式)</strong>：“ <strong>统一遍历所有对象，不关心底层结构</strong> ”，不同的集合（如数组、链表、树）遍历方式不同，直接暴露内部结构会让代码混乱，于是提供统一的遍历接口，隐藏集合的内部实现<ul><li>解决了什么问题？<ul><li>解耦，遍历代码不依赖具体集合实现（数组、链表、树都能用同一套遍历逻辑）</li><li>简化调用，用户只需调 <code>hasNext()</code> 和 <code>next()</code>，不用关心底层是 <code>for</code> 循环还是 <code>while</code></li></ul></li></ul></li><li><strong>Observer(观察者模式)</strong>：“ <strong>微信订阅号，作者发布，粉丝自动收到推送</strong> ”，当一个对象（如天气数据）变化时，需要自动通知多个依赖对象（如手机App、广告牌），但 <strong>不想让它们紧密耦合</strong>，我们可以这样解决：<ul><li><strong>被观察者（Subject）</strong>：维护一个订阅者列表，提供 <code>添加/删除</code> 订阅的方法</li><li><strong>观察者（Observer）</strong>：定义统一的更新接口（如 <code>update()</code>）</li><li><strong>流程</strong>：被观察者状态变化 → 遍历订阅者列表 → 调用每个观察者的 <code>update()</code></li></ul></li><li><strong>State(状态模式)</strong>：“ <strong>对象变，行为跟着变</strong> ”，当一个对象的行为 <strong>取决于它的状态</strong>（比如订单的 “待支付”、“已发货”），如果用一堆 <code>if-else</code> 判断状态，代码会臃肿且难维护，于是我们可以 <strong>把状态抽成独立的类</strong>，对象内部切换状态，行为自动变化</li><li><strong>Strategy(策略模式)</strong>：“ <strong>算法随便换，调用不改变</strong> ”，当一个任务有 <strong>多种算法</strong>（如排序、支付、导航），用 <code>if-else</code> 硬编码会导致代码臃肿且难扩展，于是我们可以定义算法接口，将每种算法封装成独立类，运行时动态的切换算法，调用方无需关心细节<ul><li>比如导航 App，选 “最快路线” 或 “最省钱路线”，App 自动计算，但导航按钮始终是同一个；支付系统，用户选微信支付或支付宝，支付流程不变，只是底层实现不同</li><li>解决了什么问题？<ul><li>开闭原则，新增算法只需要加新类，不需要改旧代码</li><li>复用性，同一套算法可被多个场景共享</li></ul></li></ul></li></ul></li></ol><h2 id=面向对象oo的设计法则>面向对象（OO）的设计法则<a hidden class=anchor aria-hidden=true href=#面向对象oo的设计法则>#</a></h2><ol><li>单一职责原则：一个类只干一件事</li><li>开闭原则：对扩展开放，对修改关闭</li><li>里氏替换原则：子类必须能替换父类，且行为一致（防止调用父类方法时，子类抛出 <strong>不支持的操作</strong> 异常）</li><li>接口隔离原则：接口要小而专，不能让用户实现用不到的方法<ul><li>比如：Animal 接口有 fly()、swim()、run()，但 Dog 类被迫实现无用的 fly()</li></ul></li><li>依赖倒置原则：依赖抽象，不依赖具体<ul><li>比如：<ul><li>错误设计：OrderService 直接调用 MySQLDatabase</li><li>正确设计：OrderService 依赖 Database 接口，具体用 MySQL 还是 Mongo 由配置决定</li></ul></li></ul></li><li>迪米特法则：少管闲事，只和朋友通信（减少类之间的耦合）</li><li>组合由于继承原则：多用组合，少用继承</li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yukipedia.cn/>YUKIPEDIA's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>